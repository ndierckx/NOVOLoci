#!/usr/bin/env perl
######################################################
#         SOFTWARE COPYRIGHT NOTICE AGREEMENT        #
#  Copyright (C) {2022-2025}  {Nicolas Dierckxsens}  #
#              All Rights Reserved                   #
#         See file LICENSE for details.              #
######################################################
#           NOVOLoci - Haplotype-aware assembly
#           nicolasdierckxsens@hotmail.com

use strict;

my @modules = ("Getopt::Long", "MCE::Child", "MCE::Channel", "Parallel::ForkManager");

foreach my $module (@modules) 
{
	eval "require $module";
    if ($@) 
	{
        print "Module $module is not installed: $@\n";
		system('perl', '-MCPAN', '-e', "install $module") == 0
        or die "Failed to install $module: $?\n";
    }
}

require Getopt::Long;
Getopt::Long->import();
require MCE::Child;
MCE::Child->import();
require MCE::Channel;
MCE::Channel->import();
require Parallel::ForkManager;
Parallel::ForkManager->import();
require MCE;
MCE->import();

use MCE::Channel;
use MCE::Child;
#use MCE::Channel::Threads;
use Parallel::ForkManager;
use IO::Handle;
use Time::HiRes qw(time);
use Time::HiRes qw(sleep);
#use POSIX ":sys_wait_h";

my $sequencing_depth_NP = '30';
my $sequencing_depth_PB = '30';
my $y = '1';
my $y0 = '1';
my %y;
undef %y;
my $iterations = "10000000000";
my $overlap = "12";
my $find_haps_in_seed = "";
my $keep_read_ids = "";
my $config = "";
my $project = "";
my $batch_file = "";
my $assembly_length_max = "";
my $assembly_refine = "";
my %assembly_refine_done;
undef %assembly_refine_done;
my %assembly_length_prev;
undef %assembly_length_prev;
my $type = "";
my $subsample = "";
my $save_reads = "";
my $seed_input0 = "";
my $ploidy = "1";
my $reference = "";
my $variance_detection = "";
my $NP_reads = "";
my $NP_reads_support = "";
my $NP_reads_support_SNR = "";
my $PB_reads = "";
my $output_path = "";
my $reverse_seed = "yes";
my $maxProcs = '5';
my $minimum_read_length_NP = '500';
my $minimum_read_length_PB = '500';
my $circular = "";

my $input_reads_DB_folder_NP = "";
my $input_reads_DB_folder_PB = "";
my $clip_read = '0';
my $SNR_read_ahead = "";
my $SNR_read_back_ahead = "";
my $seed_batch = "";
my $seed_input = "";
my $use_quality_scores_NP = "";
my %quality_scores_NP;
undef %quality_scores_NP;

my $read = "";
my $read_back = "";
my $seed_id2 = "";
my $id = "";
my $position = '0';
my $position_back = '0';
my $compare_haps = "";
my $compare_haps_stop = "";
my %compare_haps_stop_final;
undef %compare_haps_stop_final;
my %no_hap_track;
undef %no_hap_track;
my $skip_hap = "";
my $reduce_last_600_PB = '1000';
my $reduce_last_600_NP = "";
my $allow_multi_match = "yes";
my %last_non_complex_region;
undef %last_non_complex_region;
my %original_seed_length;
undef %original_seed_length;
my $min_seed_length_PB = '100';

my %filehandle;
undef %filehandle;
my %filehandle3;
undef %filehandle3;
my %filehandle4;
undef %filehandle4;
my %save_reads;
undef %save_reads;
my %seed;
undef %seed;
my %position;
undef %position;
my %position_back;
undef %position_back;

my %split_positions;
undef %split_positions;
my %split_positions_extra;
undef %split_positions_extra;
my %split_positions_DUP;
undef %split_positions_DUP;
my %split_positions_DUP2;
undef %split_positions_DUP2;
my %split_positions_VIP;
undef %split_positions_VIP;
my %split_positions_back;
undef %split_positions_back;
my %quality_scores;
undef %quality_scores;
my %quality_scores_gap;
undef %quality_scores_gap;
my %assembled_reads;
undef %assembled_reads;
my %printed_reads_NP;
undef %printed_reads_NP;
my %printed_reads_PB;
undef %printed_reads_PB;
my %cut_repeat_seq;
undef %cut_repeat_seq;
#my %position_correction;
my %hap_compare_pos;
undef %hap_compare_pos;
my $hap_compare_mismatch_extend = '0';
my %PB_split_nucs;
undef %PB_split_nucs;
my %PB_split_ids;
undef %PB_split_ids;
my $PB_extension = "";
my %contig_length;
undef %contig_length;

my @seed_list_sorted;
undef @seed_list_sorted;
my $print_sep = '1';
my $repetitive_detect1 = "";
my $repetitive_detect2 = "";

my $full_reset_NP = "";
my $unresolvable_NP = "";
my $split_contigs_NP = "";
my $split_contigs_PB = "";
my $full_reset_PB = "";
my $unresolvable_PB = "";
my $TMP_directory = "";
my $max_file_count = '9990';
my $retry_NP = "";
my $retry_PB = "";
my $average_length_NP = "";
my $average_length_PB = "15000";
my $halle5 = "";
my $genome_size = "";
my $last_merge_check_pos = '';
my $high_quality_ONT = "";

my %save_alignment_data_NP;
undef %save_alignment_data_NP;
my %rejected_alignment_data_NP;
undef %rejected_alignment_data_NP;
my %rejected_alignment_data_PB;
undef %rejected_alignment_data_PB;
my %save_alignment_data_NP_back;
undef %save_alignment_data_NP_back;
my %save_alignment_data_PB;
undef %save_alignment_data_PB;
my %save_alignment_data_PB_back;
undef %save_alignment_data_PB_back;
my %trace_back_split_NP;
undef %trace_back_split_NP;
my %trace_back_split_NP_backup;
undef %trace_back_split_NP_backup;
my %trace_back_split_NP_exclude;
undef %trace_back_split_NP_exclude;
my %track_split_NP;
undef %track_split_NP;
my %trace_back_split_PB;
undef %trace_back_split_PB;
my %track_split_PB;
undef %track_split_PB;
my %prev_position_hap_compare;
undef %prev_position_hap_compare;
my %first_back_assembly;
undef %first_back_assembly;
my %rejected_rej_reads;
undef %rejected_rej_reads;
my %full_reset_time;
undef %full_reset_time;
my %full_reset_time_stop;
undef %full_reset_time_stop;
my %track_coverage;
undef %track_coverage;
my %WG_rejected_reads;
undef %WG_rejected_reads;


#Read the config file----------------------------------------------------------------------------------------------

GetOptions (
            "c=s" => \$config,
            ) or die "Incorrect usage!\n";

open(CONFIG, $config) or die "Error:Can't open the configuration file, please check the manual!\n\nUsage: perl NOVOLoci0.1.pl -c config.txt\n";

while (my $line = <CONFIG>)
{
    $line =~ tr/\r//d;
    $line =~ s/\R/\012/;
	$line =~ s/[ \t\xA0]+$//;                                                       #CHECK THISSSSSSSSSSSSSSSSSSSSSSSSSSs
    if ($line =~ m/.*Project name\s+\=\s+(.*?)(Assembly length.*)*$/)
    {
        $project = $1;
        chomp $project;
        my $project_tmp = $project;
        my $ggg;
        if ($project =~ m/batch\:(.*)/)
        {
            my $batch_file_tmp = $1;
            if ($batch_file eq "")
            {
                $batch_file = $batch_file_tmp;
                print "Batch file detected...\n\n";
                open(BATCH, $batch_file) or die "Error: $!\nCan't open the batch file, please check the manual!\n";
                $ggg = "yes";
            }
            while (my $line = <BATCH>)
            {
                $project = $line;
                chomp $project;
                last;
            }
            if ($project eq $project_tmp || $project eq "")
            {
                goto EXIT;
            }
            elsif ($ggg ne "yes")
            {
                print "\n\n------------------------------\n------------------------------\n";
                print "        NEXT SAMPLE\n";
                print "------------------------------\n------------------------------\n\n\n";
            }
        }
    }
    if ($line =~ m/.*Assembly length\s+\=\s+(.*?)(Save assembled reads.*)*$/)
    {
        $assembly_length_max = $1;
        chomp $assembly_length_max;
        if ($assembly_length_max eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $assembly_length_max = $line;
                chomp $assembly_length_max;
                last;
            }
        }    
    }     
    if ($line =~ m/.*Save assembled reads\s+\=\s+(.*?)(Seed Input.*)*$/)
    {
        $save_reads = $1;
        chomp $save_reads;
        if ($save_reads eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $save_reads = $line;
                chomp $save_reads;
                last;
            }
        }
    }
	if ($line =~ m/.*Seed Input\s+\=\s+(.*?)(Genome size.*)*$/)
    {
        $seed_input0 = $1;
        chomp $seed_input0;
        if ($seed_input0 eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $seed_input0 = $line;
                chomp $seed_input0;
                last;
            }
        }
    }
	if ($line =~ m/.*Genome size\s+\=\s+(.*?)(Ploidy.*)*$/)
    {
        $genome_size = $1;
        chomp $genome_size;
        if ($genome_size eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $genome_size = $line;
                chomp $genome_size;
                last;
            }
        }
    }   
    if ($line =~ m/.*Ploidy\s+\=\s+(.*?)(Circular.*)*$/)
    {
        $ploidy = $1;
        chomp $ploidy;
        if ($ploidy eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $ploidy = $line;
                chomp $ploidy;
                last;
            }
        }
    }
	if ($line =~ m/.*Circular\s+\=\s+(.*?)(Threads.*)*$/)
    {
        $circular = $1;
        chomp $circular;
        if ($circular eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $circular = $line;
                chomp $circular;
                last;
            }
        }
    }
    if ($line =~ m/.*Threads\s+\=\s+(.*?)(Output path.*)*$/)
    {
        $maxProcs = $1;
        chomp $maxProcs;
        if ($maxProcs eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $maxProcs = $line;
                chomp $maxProcs;
                last;
            }
        }
    }
    if ($line =~ m/.*Output path\s+\=\s+(.*?)(TMP path.*)*$/)
    {
        $output_path = $1;
        chomp $output_path;
        if ($output_path eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $output_path = $line;
                chomp $output_path;
                last;
            }
        }
    }
	if ($line =~ m/.*TMP path\s+\=\s+(.*?)(Nanopore reads:.*)*$/)
    {
        $TMP_directory = $1;
        chomp $TMP_directory;
        if ($TMP_directory eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $TMP_directory = $line;
                chomp $TMP_directory;
                last;
            }
        }
    }
	
    if ($line =~ m/.*Nanopore reads\s+\=\s+(.*?)(Local DB and NP reads.*)*$/)
    {
        $NP_reads = $1;
        chomp $NP_reads;
        if ($NP_reads eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $NP_reads = $line;
                chomp $NP_reads;
                last;
            }
        }
    }
    if ($line =~ m/.*Local DB and NP reads\s+\=\s+(.*?)(Sequencing depth NP.*)*$/)
    {
        $input_reads_DB_folder_NP = $1;
        chomp $input_reads_DB_folder_NP;
        if ($input_reads_DB_folder_NP eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $input_reads_DB_folder_NP = $line;
                chomp $input_reads_DB_folder_NP;
                last;
            }
        }
    }
    if ($line =~ m/.*Sequencing depth NP\s+\=\s+(.*?)(R10.*)*$/)
    {
        $sequencing_depth_NP = $1;
        chomp $sequencing_depth_NP;
        if ($sequencing_depth_NP eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $sequencing_depth_NP = $line;
                chomp $sequencing_depth_NP;
                last;
            }
        }    
    }
	if ($line =~ m/.*R10\s+\=\s+(.*?)(Min read length NP.*)*$/)
    {
        $high_quality_ONT = $1;
        chomp $high_quality_ONT;
        if ($high_quality_ONT eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $high_quality_ONT = $line;
                chomp $high_quality_ONT;
                last;
            }
        }    
    }
	if ($line =~ m/.*Min read length NP\s+\=\s+(.*?)(Use Quality scores.*)*$/)
    {
        $minimum_read_length_NP = $1;
        chomp $minimum_read_length_NP;
        if ($minimum_read_length_NP eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $minimum_read_length_NP = $line;
                chomp $minimum_read_length_NP;
                last;
            }
        }    
    }
	if ($line =~ m/.*Use Quality scores\s+\=\s+(.*?)(PacBio reads:.*)*$/)
    {
        $use_quality_scores_NP = $1;
        chomp $sequencing_depth_NP;
        if ($use_quality_scores_NP eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $use_quality_scores_NP = $line;
                chomp $use_quality_scores_NP;
                last;
            }
        }    
    }
    
    if ($line =~ m/.*PacBio reads\s+\=\s+(.*?)(Local DB and PB reads.*)*$/)
    {
        $PB_reads = $1;
        chomp $PB_reads;
        if ($PB_reads eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $PB_reads = $line;
                chomp $PB_reads;
                last;
            }
        }
    }
    if ($line =~ m/.*Local DB and PB reads\s+\=\s+(.*?)(Sequencing depth PB.*)*$/)
    {
        $input_reads_DB_folder_PB = $1;
        chomp $input_reads_DB_folder_PB;
        if ($input_reads_DB_folder_PB eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $input_reads_DB_folder_PB = $line;
                chomp $input_reads_DB_folder_PB;
                last;
            }
        }
    }
    if ($line =~ m/.*Sequencing depth PB\s+\=\s+(.*?)(Min read length PB.*)*$/)
    {
        $sequencing_depth_PB = $1;
        chomp $sequencing_depth_PB;
        if ($sequencing_depth_PB eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $sequencing_depth_PB = $line;
                chomp $sequencing_depth_PB;
                last;
            }
        }    
    }
	if ($line =~ m/.*Min read length PB\s+\=\s+(.*?)$/)
    {
        $minimum_read_length_PB = $1;
        chomp $minimum_read_length_PB;
        if ($minimum_read_length_PB eq "batch" && $batch_file ne "")
        {
            while (my $line = <BATCH>)
            {
                $minimum_read_length_PB = $line;
                chomp $minimum_read_length_PB;
                last;
            }
        }    
    }
}

close CONFIG;

if ($variance_detection eq "no")
{
    $variance_detection = "";
}
$project =~ tr/: /__/;

if ($output_path eq "")
{
    die "\nPlease give an output path in the config file: $output_path, $!\n";
}
my $output_path_test = substr $output_path, -1, 1;
my $output_path_test2 = substr $output_path, 0, 1;

if ($output_path_test2 ne "\\" && $output_path_test2 ne "/" )
{
    die "\nPlease give the full output path that starts and end with a directory separator (/ or \): $output_path, $!\n";                         
}
if ($output_path_test ne "\\" && $output_path_test ne "/" && $output_path_test2 ne "\\" && $output_path_test2 ne "/" )
{
    die "\nCan not recognize the output path, it should start and end with a directory separator (/ or \): $output_path, $!\n";                         
}
elsif ($output_path ne "")
{
    if ($output_path_test ne "\\" && $output_path_test ne "/")
	{
		$output_path .= $output_path_test2;
		$output_path_test = $output_path_test2;
	}
	unless (-d $output_path)
    {
        mkdir $output_path;
    }
}
my $TMP_path_test = substr $TMP_directory, -1 , 1;
my $TMP_path_test2 = substr $TMP_directory, 0 , 1;

if ($TMP_directory eq "")
{
	$TMP_directory = $output_path;
	print "\nNo TMP directory was given, therefore the output path will be used as TMP directory, which could slow down the assembly: $TMP_directory, $!\n";
}
if ($TMP_path_test2 ne "\\" && $TMP_path_test2 ne "/" )
{
    die "\nPlease give the full TMP path that starts and end with a directory separator (/ or \): $TMP_directory, $!\n";                         
}
elsif ($TMP_directory ne "")
{
    if ($TMP_path_test ne "\\" && $TMP_path_test ne "/")
	{
		$TMP_directory .= $TMP_path_test2;
	}
	unless (-d $TMP_directory)
    {
        mkdir $TMP_directory;
    }
}

if ($input_reads_DB_folder_NP ne "")
{
	my $DB_folder_NP_path_test = substr $input_reads_DB_folder_NP, -1 , 1;
	my $DB_folder_NP_path_test2 = substr $input_reads_DB_folder_NP, 0 , 1;
	
	if ($DB_folder_NP_path_test2 ne "\\" && $DB_folder_NP_path_test2 ne "/")
	{
		die "\nPlease give the full Database path that starts and end with a directory separator (/ or \): $input_reads_DB_folder_NP, $!\n";                         
	}
	elsif ($DB_folder_NP_path_test ne "\\" && $DB_folder_NP_path_test ne "/")
	{
		$input_reads_DB_folder_NP .= $DB_folder_NP_path_test2;
	}
}

my $final_assembly_file = $output_path."assembly_raw_".$project.".fasta";
my $final_assembly_file_check = "";
my $output_file4  = $output_path."log_".$project.".txt";

if (-s $final_assembly_file)
{
	$final_assembly_file_check = "ye";
}

unless (-e $output_file4)
{	
	open(OUTPUT4, ">".$output_file4) or die "Can't open file $output_file4, $!\n";
}
else
{
	open(OUTPUT4, ">>".$output_file4) or die "Can't open file $output_file4, $!\n";
}

print "\n\n-----------------------------------------------";
print "\nNOVOLoci\n";
print "Version 0.1\n";
print "Author: Nicolas Dierckxsens, (c) 2022-2025\n";
print "-----------------------------------------------\n\n";

print "\nInput parameters from the configuration file:   *** Verify if everything is correct ***\n\n";
print "Project:\n";
print "-----------------------\n";
print "Project name          = ".$project."\n";
print "Assembly length       = ".$assembly_length_max."\n";
print "Save assembled reads  = ".$save_reads."\n";
print "Seed Input            = ".$seed_input0."\n";
print "Genome size           = ".$genome_size."\n";
print "Ploidy                = ".$ploidy."\n";
print "Circular              = ".$circular."\n";
print "Threads               = ".$maxProcs."\n";
print "Output path           = ".$output_path."\n";
print "TMP path              = ".$TMP_directory."\n\n";

print "Nanopore reads:\n";
print "-----------------------\n";
print "Nanopore reads        = ".$NP_reads."\n";
print "Local DB and NP reads = ".$input_reads_DB_folder_NP."\n";
print "Sequencing depth NP   = ".$sequencing_depth_NP."\n";
print "R10                   = ".$high_quality_ONT."\n";
print "Min read length NP    = ".$minimum_read_length_NP."\n";

print "PacBio reads:\n";
print "-----------------------\n";
print "PacBio reads          = ".$PB_reads."\n";
print "Local DB and PB reads = ".$input_reads_DB_folder_PB."\n";
print "Sequencing depth PB   = ".$sequencing_depth_PB."\n";
print "Min read length PB    = ".$minimum_read_length_PB."\n\n";



print OUTPUT4 "\n\n-----------------------------------------------";
print OUTPUT4 "\nNOVOLoci\n";
print OUTPUT4 "Version 0.1\n";
print OUTPUT4 "Author: Nicolas Dierckxsens, (c) 2022-2025\n";
print OUTPUT4 "-----------------------------------------------\n\n";

print OUTPUT4 "\nInput parameters from the configuration file:   *** Verify if everything is correct ***\n\n";
print OUTPUT4 "Project:\n";
print OUTPUT4 "-----------------------\n";
print OUTPUT4 "Project name          = ".$project."\n";
print OUTPUT4 "Assembly length       = ".$assembly_length_max."\n";
print OUTPUT4 "Save assembled reads  = ".$save_reads."\n";
print OUTPUT4 "Seed Input            = ".$seed_input0."\n";
print OUTPUT4 "Genome size           = ".$genome_size."\n";
print OUTPUT4 "Ploidy                = ".$ploidy."\n";
print OUTPUT4 "Circular              = ".$circular."\n";
print OUTPUT4 "Threads               = ".$maxProcs."\n";
print OUTPUT4 "Output path           = ".$output_path."\n";
print OUTPUT4 "TMP path              = ".$TMP_directory."\n\n";

print OUTPUT4 "Nanopore reads:\n";
print OUTPUT4 "-----------------------\n";
print OUTPUT4 "Nanopore reads        = ".$NP_reads."\n";
print OUTPUT4 "Local DB and NP reads = ".$input_reads_DB_folder_NP."\n";
print OUTPUT4 "Sequencing depth NP   = ".$sequencing_depth_NP."\n";
print OUTPUT4 "R10                   = ".$high_quality_ONT."\n";
print OUTPUT4 "Min read length NP    = ".$minimum_read_length_NP."\n";

print OUTPUT4 "PacBio reads:\n";
print OUTPUT4 "-----------------------\n";
print OUTPUT4 "PacBio reads          = ".$PB_reads."\n";
print OUTPUT4 "Local DB and PB reads = ".$input_reads_DB_folder_PB."\n";
print OUTPUT4 "Sequencing depth PB   = ".$sequencing_depth_PB."\n";
print OUTPUT4 "Min read length PB    = ".$minimum_read_length_PB."\n\n";


#Warning messages-----------------------------------------------------------------------------------------------------------------------------
if (($sequencing_depth_NP < 1 || $sequencing_depth_NP eq "") && ($NP_reads ne "" || $input_reads_DB_folder_NP ne "") && $genome_size eq "")
{
	die "\n'Please give an estimation of the Nanopore sequencing depth in the config file!\n";
}
if (($sequencing_depth_PB < 1 || $sequencing_depth_PB eq "") && ($PB_reads ne "" || $input_reads_DB_folder_PB ne "") && $genome_size eq "")
{
	die "\n'Please give an estimation of the PacBio sequencing depth in the config file!\n";
}
if ($ploidy ne "1" && $ploidy ne "2")
{
    die "\n'The Ploidy option has to be '1' or '2'! Polyploid (>2) assemblies will be supported in the future\n";
}

if ($genome_size =~ m/^\d*\.*\d*$/)
{
}
elsif ($genome_size ne "")
{
    die "\n'Genome size' can only be an integer, the amount is always in Gbp, don't add a unit!\n";
}

if ($high_quality_ONT ne "yes")
{
	$high_quality_ONT = "";
}
if ($variance_detection eq "yes" && $reference eq "")
{
    #die "\nWhen variance detection is on, you must give a reference sequence, please check the configuration file!\n";
}
if ($save_reads ne "yes" && $save_reads ne "1" && $save_reads ne "2" && $save_reads ne ""  && $save_reads ne "no")
{
    die "\n'Save assembled reads' has to be '1', '2' or empty, please check the configuration file!\n";
}
if ($subsample =~ m/^\d*\.*\d*$/)
{
}
else
{
    die "\n'Subsample' can only be an integer!\n";
}
if ($save_reads eq "no")
{
    $save_reads = "";
}

my $USAGE = "\nUsage: perl NOVOLoci0.1.pl -c config_example.txt";

if (($NP_reads ne "" || $input_reads_DB_folder_NP ne "") && ($PB_reads ne "" || $input_reads_DB_folder_PB ne ""))
{
    $NP_reads_support = "yes";
}

chomp($maxProcs);
if ($maxProcs > 0)
{}
else
{
    die "\nMax Threads: '$maxProcs' has to be a value above 1!\n";
}

my $tmp_sequences_directory_NP = $output_path."tmp_sequences_NP";
my $tmp_sequences_directory_PB = $output_path."tmp_sequences_PB";

if ($input_reads_DB_folder_NP eq "" && $NP_reads ne "")
{
    mkdir $tmp_sequences_directory_NP;
}
if ($input_reads_DB_folder_PB eq "" && $PB_reads ne "")
{
    mkdir $tmp_sequences_directory_PB;
}

if ($input_reads_DB_folder_NP ne "")
{
    $tmp_sequences_directory_NP = $input_reads_DB_folder_NP."tmp_sequences_NP";
}
if ($input_reads_DB_folder_PB ne "")
{
    $tmp_sequences_directory_PB = $input_reads_DB_folder_PB."tmp_sequences_PB";
}

my $directory_DB_NP = $output_path."BLAST_DB_NP";
my $directory_DB_PB = $output_path."BLAST_DB_PB";

if ($input_reads_DB_folder_NP eq "" && $NP_reads ne "")
{
    mkdir $directory_DB_NP;
}
else
{
    $directory_DB_NP = $input_reads_DB_folder_NP."BLAST_DB_NP";
}

if ($input_reads_DB_folder_PB eq "" && $PB_reads ne "")
{
    mkdir $directory_DB_PB;
}
else
{
    $directory_DB_PB = $input_reads_DB_folder_PB."BLAST_DB_PB";
}


if ($use_quality_scores_NP ne "" && $use_quality_scores_NP ne "yes")
{
	open(INPUT7a, $use_quality_scores_NP) or die "\nCan't open quality score file, if you have a quality score file, you should give the path to that file,
	if it is your first run on this dataset, you should write \"yes\". If you don't want to use quality scores, leave it blank.\n";
	close INPUT7a;
}

if ($minimum_read_length_NP eq "")
{
	$minimum_read_length_NP = '1000';
}
if ($minimum_read_length_PB eq "")
{
	$minimum_read_length_PB = '500';
}


sub AT_rich_test
{
    my @str = @_;
    my $region_to_check = $str[0];
    $region_to_check =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
    my $extra = $str[1];
    my $AT_rich = "";

    my $A_rich_test = $region_to_check =~ tr/A/A/;
    my $T_rich_test = $region_to_check =~ tr/T/T/;
    my $G_rich_test = $region_to_check =~ tr/G/G/;
    my $C_rich_test = $region_to_check =~ tr/C/C/;
	my $AT_rich_test = $region_to_check =~ s/AT/AT/g;
	my $CG_rich_test = $region_to_check =~ s/CG/CG/g;
	my $TA_rich_test = $region_to_check =~ s/TA/TA/g;
	my $GC_rich_test = $region_to_check =~ s/GC/GC/g;
    my $dot_rich_test3 = $region_to_check =~ tr/\./\./;
    
    if (($A_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra || $T_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra
        || $G_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra || $C_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra
        || $AT_rich_test+$dot_rich_test3 >= (length($region_to_check)-$extra)/2 || $CG_rich_test+$dot_rich_test3 >= (length($region_to_check)-$extra)/2
		|| $TA_rich_test+$dot_rich_test3 >= (length($region_to_check)-$extra)/2 || $GC_rich_test+$dot_rich_test3 >= (length($region_to_check)-$extra)/2)
		&& $dot_rich_test3 < length($region_to_check)*0.2)
    {
        $AT_rich = "yes";
    }	
	if (length($region_to_check) > 18)
	{
		if ($A_rich_test+$T_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra)
		{
			 $AT_rich = "yes";
		}
		elsif ($G_rich_test+$C_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra)
		{
			 $AT_rich = "yes";
		}
		elsif ($C_rich_test+$T_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra)
		{
			$AT_rich = "yes";
		}
		elsif ($C_rich_test+$A_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra)
		{
			$AT_rich = "yes";
		}
	}
    return $AT_rich;
}
sub AT_rich_test2
{
    my @str = @_;
    my $region_to_check = $str[0];
    $region_to_check =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
    my $extra = $str[1];
    my $AT_rich = "";

    my $A_rich_test = $region_to_check =~ tr/A/A/;
    my $T_rich_test = $region_to_check =~ tr/T/T/;
    my $G_rich_test = $region_to_check =~ tr/G/G/;
    my $C_rich_test = $region_to_check =~ tr/C/C/;
    my $dot_rich_test3 = $region_to_check =~ tr/\./\./;
    
    if (($A_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra || $T_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra
        || $C_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra || $G_rich_test+$dot_rich_test3 >= length($region_to_check)-$extra)
		&& $dot_rich_test3 < length($region_to_check)*0.3)
    {
        $AT_rich = "yes";
    }
    return $AT_rich;
}
#Check in the extensions if an SNR is ahead---------------------------------------------------------------------------------------------
sub SNR_ahead
{
    my @str = @_;
    my %extensions_tmp = %{$str[0]};
    my $skip = $str[1];
    my $back = $str[2];
    my $SNR_ahead = '0';
    my %total;
	undef %total;
AHEAD:foreach my $extension_id_tmp (keys %extensions_tmp)
    {
        my $extension_tmp = $extensions_tmp{$extension_id_tmp};
        if (length($extension_tmp) > 10)
        {
            my $first11 = substr $extension_tmp, $skip, 12;
            #$first11 =~ tr/1234/ACTG/;
            my $A = $first11 =~ tr/1A/1A/;
            my $C = $first11 =~ tr/2C/2C/;
            my $T = $first11 =~ tr/3T/3T/;
            my $G = $first11 =~ tr/4G/4G/;
            my $N = $first11 =~ tr/N/N/;
            if ($A > 7 || $C > 7 || $T > 7 || $G > 7)
            {
                $SNR_ahead++;
                $total{'A'} = $A+$total{'A'};
                $total{'C'} = $C+$total{'C'};
                $total{'T'} = $T+$total{'T'};
                $total{'G'} = $A+$total{'G'};
            }
            elsif ($N < 2)
            {
                $SNR_ahead--;
            }
        }
        if ($SNR_ahead > 10 || $SNR_ahead < -2)
        {
            last AHEAD;
        }
    }
    if ($SNR_ahead > 7)
    {
        $SNR_ahead = "yes";
        my $highest = '0';
        foreach my $total (keys %total)
        {
            if ($total{$total} > $highest)
            {
                $highest = $total{$total};
                if ($back eq "yes")
                {
                    $SNR_read_back_ahead = $total;
                }
                else
                {
                    $SNR_read_ahead = $total;
                }        
            }  
        }
    }
    else
    {
        $SNR_ahead = "";
    }
    return $SNR_ahead;
}

my $output_file5  = $output_path."log_extended_".$project.".txt";
my $output_file10 = $output_path."Assembled_reads_PB_".$project.".fasta";
my $output_file11 = $output_path."Assembled_reads_NP_".$project.".fasta";
my $output_file12 = $output_path."structural_variation_".$project.".vcf";
my $output_file13 = $output_path."quality_scores_".$project.".txt";

if ($seed_input0 ne "")
{
    open(INPUT3, $seed_input0) or die "Can't open the seed file, $!\n";
}

if ($save_reads ne "" && ($PB_reads ne "" || $input_reads_DB_folder_PB ne ""))
{
	unless (-e $output_file10)
	{	
		open(OUTPUT10, ">".$output_file10) or die "Can't open saved reads file $output_file10, $!\n";
	}
	else
	{
		open(OUTPUT10, ">>".$output_file10) or die "Can't open saved reads file $output_file10, $!\n";
	}
}
if ($save_reads ne "" && ($NP_reads ne "" || $input_reads_DB_folder_NP ne ""))
{
	unless (-e $output_file11)
	{	
		open(OUTPUT11, ">".$output_file11) or die "Can't open saved reads file $output_file11, $!\n";
	}
	else
	{
		open(OUTPUT11, ">>".$output_file11) or die "Can't open saved reads file $output_file11, $!\n";
	}
}
if ($variance_detection eq "yes")
{
    unless (-e $output_file12)
	{	
		open(OUTPUT12, ">" .$output_file12) or die "Can't open variation file $output_file12, $!\n";
	}
	else
	{
		open(OUTPUT12, ">>".$output_file12) or die "Can't open variation file $output_file12, $!\n";
	}
}

#Open variance vcf file----------------------------------------------------------------------------------------------------------------------------------
if ($variance_detection eq "yes")
{
    my ($wday, $mon, $mday, $hour, $min, $sec, $year) = localtime;
    my @localtime = split / /, localtime;
    my %mon2num = qw(
    Jan 01  Feb 02  Mar 03  Apr 04  May 05  Jun 06
    Jul 07  Aug 08  Sep 09  Oct 10 Nov 11 Dec 12
    );
    my $month = $localtime[1];
    if (exists($mon2num{$localtime[1]}))
    {
       $month = $mon2num{$localtime[1]};
    }
    print OUTPUT12 "##fileformat=VCFv4.0\n";
    print OUTPUT12 "##fileDate=".$localtime[4].$month.$localtime[2]."\n";
    print OUTPUT12 "##reference=".$reference."\n";
    print OUTPUT12 "##INFO=<ID=AF,Number=1,Type=Float,Description=\"Allele Frequency\">\n";
    print OUTPUT12 "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Raw Depth\">\n";
    #print OUTPUT12 "##INFO=<ID=FR,Number=1,Type=Flag,Description=\"Detected on the forward(F) and/or reverse(R) strand\">\n";
    print OUTPUT12 "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n";
}

#Make hash of reference----------------------------------------------------------------------------------------------------------------------------------

my %hashref;
undef %hashref;
my %hashref2;
undef %hashref2;

if ($reference ne "")
{
    select(STDERR);
    $| = 1;
    select(STDOUT); # default
    $| = 1;
    print "\nScan reference sequence...";
    open(INPUT5, $reference) or die "\n\nCan't open reference file $reference, $!\n";
    my $ff2 = '0';
    my $value_ref2 = "";
    
    while (my $line = <INPUT5>)
    {
        if ($ff2 < 1)
        {
            $ff2++;
            next;
        }
        chomp $line;    
        $line =~ tr/actgn/ACTGN/;
        my $first = substr $line, 0, 1;
        my $line3;
        if ($first eq '>' || $first eq '@')
        {
            $line3 = $value_ref2."NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN";
        }
        else
        {
            $line3 = $value_ref2.$line;
        }
        
        while (length($line3) > ((30*3)-1))
        {
            my $value_ref2b = substr $line3, 0, 30;
            my $line2 = $line3;
            $line3 = substr $line2, 1;
            
            if (exists($hashref{$value_ref2b}))
            {
                $hashref{$value_ref2b} .= ",".$ff2;
            }
            else
            {
                $hashref{$value_ref2b} = $ff2;
            }
            if (exists($hashref2{$ff2}))
            {
                $hashref2{$ff2} .= ",".$value_ref2b;
            }
            else
            {
                $hashref2{$ff2} = $value_ref2b;
            }
            $ff2++;
        }
        $value_ref2 = $line3;
    }
    while (length($value_ref2) > 1)
    {
        my $value_ref2b = substr $value_ref2, 0, 30;
        my $value_ref2bc = $value_ref2;
        $value_ref2 = substr $value_ref2bc, 1;
        
        if (exists($hashref{$value_ref2b}))
        {
            $hashref{$value_ref2b} .= ",".$ff2;
        }
        else
        {
            $hashref{$value_ref2b} = $ff2;
        }
        if (exists($hashref2{$ff2}))
        {
            $hashref2{$ff2} .= ",".$value_ref2b;
        }
        else
        {
            $hashref2{$ff2} = $value_ref2b;
        }
        $ff2++;
    }
    close INPUT5;
    print "...OK\n\n";
}

my %delete_input_files;
undef %delete_input_files;
my %original_input_files;
undef %original_input_files;
my @QUALITY_HASH;

my $maxProcs_tmp = $maxProcs-1;
if ($maxProcs_tmp < 1)
{
	$maxProcs_tmp = '1';
}

#--------------------------------------------------------------------------------------------------------------------------------------------------------
#Make hash of ONT reads----------------------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------------------------------------------

my $read_count_NP = '0';
my $total_read_length_NP = '0';
my $max_read_length_NP = '0';
my $min_read_length_NP = '0';
my $removed_reads_min_NP = '0';
my $removed_reads_total_length_NP = '0';
my $N50_NP = '0';
my @read_lengths_NP;

my $pm = new Parallel::ForkManager($maxProcs_tmp);
my %ret_data_NP;
undef %ret_data_NP;
my %ret_data2_NP;
undef %ret_data2_NP;

$pm->run_on_finish(
sub
{ 
    my @str = @_;
    my %hash_tmp = %{$str[5]};
    my $pid = $str[0];

    # retrieve data structure from child
    if (defined($pid))
    {  # children are not forced to send anything
        my $string = $hash_tmp{'1'};  # child passed a string reference
        my $string2 = $hash_tmp{'2'};
        my $string3 = $hash_tmp{'3'};
        my $string4 = $hash_tmp{'4'};
        my $string5 = $hash_tmp{'5'};
        my $string6 = $hash_tmp{'6'};
        my $string7 = $hash_tmp{'7'};
		my $string8 = $hash_tmp{'8'};
        my @string9 = @{$hash_tmp{'9'}};

        $ret_data_NP{$pid} = $string;
        $ret_data2_NP{$pid} = $string3;
        $read_count_NP += $string2;
        $total_read_length_NP += $string4;
        if ($string6 > $max_read_length_NP)
        {
            $max_read_length_NP = $string6;
        }
        if ($string5 < $min_read_length_NP || $min_read_length_NP eq '0')
        {
            $min_read_length_NP = $string5;
        }
        $removed_reads_min_NP += $string7;
		$removed_reads_total_length_NP += $string8;
        @read_lengths_NP = (@read_lengths_NP, @string9);
    }
    #else {  # problems occurring during storage or retrieval will throw a warning
  #print qq|No message received from child process $data_structure_reference!\n|;
#}
});

my $long_id_NP = '0';

if ($NP_reads ne "" || $input_reads_DB_folder_NP ne "")
{   
	my $NP_check_directory = substr $NP_reads, -1;
	if ($input_reads_DB_folder_NP eq "" && $NP_reads ne "")
	{
		if ($NP_check_directory eq $output_path_test)
		{
			$NP_check_directory = "yes";
		}
		elsif (-d $NP_reads)
		{
			$NP_reads .= $output_path_test;
			$NP_check_directory = "yes";
		}
		elsif (-e $NP_reads)
		{
		}
		else
		{
			die "\nThe Nanopore input doesn't not seems to be an existing file or folder!: ".$NP_reads."\n";
		}
	}
	
	select(STDERR);
    $| = 1;
    select(STDOUT); # default
    $| = 1;
    print "\nBuilding local databases for the Nanopore reads...";
    
    
    my %NP_reads;
	undef %NP_reads;
    my $count_files = '1';
    if ($NP_reads ne "")
    {
        my $disered_db_count = $maxProcs_tmp;
        if ($NP_check_directory eq "yes")
        {
            opendir(DIR_NP, $NP_reads) or die "Could not open $NP_reads\n";
            
            for my $filename (sort readdir(DIR_NP))
            {
                my $last5 = substr $filename, -5;
                if ($last5 eq "fasta" || $last5 eq "fastq" || $last5 eq "tq.gz" || $last5 eq "ta.gz" || $last5 eq "q.bz2" || $last5 eq "a.bz2")
                {
                    my $NP_reads_tmp = $NP_reads.$filename;
                    $NP_reads{$NP_reads_tmp} = $count_files."a";
                    $original_input_files{$NP_reads_tmp} = undef;
                    $count_files++;
                }
                elsif ($filename ne "." && $filename ne "..")
                {
                    print "\n".$filename.": File extension not recognized!\n";
                    print OUTPUT4 "\n".$filename.": File extension not recognized!\n";
                }
            }
            closedir DIR_NP;
        }
        else
        {
            $NP_reads{$NP_reads} = "1a";
            $original_input_files{$NP_reads} = undef;
            $count_files++;
        }

        #my $total_filesize = '0';
        my $total_lines = '0';
        #my %file_sizes;
        #undef %file_sizes;
        my %file_lines;
		undef %file_lines;
        
        foreach my $NP_reads_tmp (keys %NP_reads)
        {
            #my $filesize = "";
            my $check_zip_long = substr $NP_reads_tmp, -2;
            my $check_zip_long2 = substr $NP_reads_tmp, -3;           
            
            if ($check_zip_long eq "gz")
            {
                #my $FILE_LONG;
                #open $FILE_LONG, '<:raw', $NP_reads_tmp or die "Could not open file '$NP_reads_tmp': $!";
                #seek $FILE_LONG, -4, 2;  # Seek to four bytes from the end of the file
                
                #my $buf;
                #read $FILE_LONG, $buf, 4;  # Read the last four bytes
                #my $uncompressed_size = unpack 'V', $buf;  # Unpack the four bytes as a little-endian unsigned integer
                #$total_filesize += $uncompressed_size;    
                #close $FILE_LONG;
                
                my $new_filename = substr $NP_reads_tmp, 0, -3;
                my @new_filename = split /$output_path_test/, $new_filename;
                my $g = @new_filename;
                $g--;
                $new_filename = $output_path.$new_filename[$g];
                my $return_value = system("gzip -c -q -k -d ".$NP_reads_tmp." > ".$new_filename);
                
                $delete_input_files{$new_filename} = undef;
                
                #$file_sizes{$new_filename}{'2'} = $uncompressed_size;
                $NP_reads{$new_filename} = $NP_reads{$NP_reads_tmp};
                delete $NP_reads{$NP_reads_tmp};
                my $count_lines = qx(wc -l $new_filename);
                chomp($count_lines);
                my @count_lines = split /\s+/, $count_lines;
                $total_lines += $count_lines[0];
                $file_lines{$new_filename} = $count_lines[0];
            }
            elsif ($check_zip_long2 eq "bz2")
            {
                die "Can't read bz2 files, pleas decompress: $NP_reads_tmp, $!\n";
            }
            elsif ($check_zip_long2 eq "zip")
            {
                die "Can't read zip files, pleas decompress: $NP_reads_tmp, $!\n";
            }
            else
            {
                #$filesize = -s $NP_reads_tmp;
                #$total_filesize += $filesize;
                #$file_sizes{$NP_reads_tmp}{'2'} = $filesize;
                my $count_lines = qx(wc -l $NP_reads_tmp);
                chomp($count_lines);
                my @count_lines = split /\s+/, $count_lines;
                $total_lines += $count_lines[0];
                $file_lines{$NP_reads_tmp} = $count_lines[0];
            }        
        }
        #my $bytes_perDB = int($total_filesize/int(($maxProcs-1)/2))+100000;
        my $lines_perDB = int($total_lines/$maxProcs_tmp)+8;
        my $adjusted_lines_perDB = (int($lines_perDB/4) * 4)+4;
		                                          #print "\n".$lines_perDB.": ".$adjusted_lines_perDB." adjusted lines\n";
        
		my $NP_reads_DB = "";
NP_READS_DB: 
		
		my $count_total_files = keys %file_lines;
        my $count_files_tmp = '0';
        my $merge_files_check = "";
        my $merge_files_check_first = "";
        my %file_lines_merged;
		undef %file_lines_merged;
        my %NP_reads_tmp;
		undef %NP_reads_tmp;
     
        foreach my $NP_reads_tmp (sort keys %file_lines)
        {
            $count_files_tmp++;
#print $file_lines{$NP_reads_tmp}." FILE_LINES\n";
#print $count_files_tmp." COUNT_LINES\n";
#print $count_total_files." COUNT_LINES_TOTAL\n";
            if ($file_lines{$NP_reads_tmp} > $adjusted_lines_perDB*1.15)
            {
                my $command_split = "split --additional-suffix=".$NP_reads{$NP_reads_tmp}.".fasta -l ".$adjusted_lines_perDB." ".$NP_reads_tmp." ".$directory_DB_NP.$output_path_test;                   
                my $return_value = system($command_split);
                
                my $expected_files = $file_lines{$NP_reads_tmp}/$adjusted_lines_perDB;
                my $expected_files0 = $file_lines{$NP_reads_tmp}/$adjusted_lines_perDB;
                if ($expected_files0 > int($expected_files0))
                {
                    $expected_files = int($expected_files0)+1;
                }
                my $found_files = 0;

                while ($found_files < $expected_files)
                {
                    $found_files = 0;
                    
                    # Check for the existence of the expected files
                    for my $file (glob("$directory_DB_NP$output_path_test*"))
                    {
                        if (-s $file)
						{
							$found_files++;
						}
                    }           
                    # Sleep for a bit if not all files have been found
                    sleep(10) if $found_files < $expected_files;
                }
                delete $NP_reads{$NP_reads_tmp};
				delete $file_lines{$NP_reads_tmp};
            }
            elsif ($merge_files_check ne "")
            {
                my $combined_lines = $file_lines{$NP_reads_tmp} + $file_lines_merged{$merge_files_check};

                if ($combined_lines < $adjusted_lines_perDB*1.15)
                {  
                    my $output_tmp = $directory_DB_NP.$output_path_test.$count_files_tmp."m".$merge_files_check_first.".fasta";
                    my $command_merge = "cat ".$merge_files_check." ".$NP_reads_tmp." > ".$output_tmp;                   
                    my $return_value = system($command_merge);
                    delete $NP_reads{$NP_reads_tmp};
                    delete $NP_reads{$merge_files_check};
					delete $file_lines{$NP_reads_tmp};

                    my $time_before_check_tmp = time;
COUNT_LINES:                   
                    my $count_lines = qx(wc -l $output_tmp);
                    chomp($count_lines);
                    my @count_lines = split /\s+/, $count_lines;
                    my $count_lines2 = $count_lines[0];

                    if ($count_lines2 eq $combined_lines)
                    {      
                        unless (exists($original_input_files{$merge_files_check}))
                        {
                            unlink $merge_files_check;
                        }
                        unless (exists($original_input_files{$NP_reads_tmp}))
                        {
                            unlink $NP_reads_tmp;
                        } 
                    }
                    elsif (time > $time_before_check_tmp+600)
                    {
                        print "ERROR: Can't merge input files\n";
                        goto END1;
                    }
                    else
                    {
                        goto COUNT_LINES;
                    }
                    
                    $NP_reads_tmp{$output_tmp} = $count_files_tmp."m".$merge_files_check_first;
                    $merge_files_check = $output_tmp;
                    $file_lines_merged{$merge_files_check} = $combined_lines;
                    my $output_file_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads_tmp{$output_tmp}.".fasta"; 
                    $delete_input_files{$output_file_DB_tmp} = undef;
                    $delete_input_files{$output_tmp} = undef;               
                }
                elsif ($file_lines_merged{$merge_files_check} > $adjusted_lines_perDB/1.4)
                { 
                    $NP_reads{$merge_files_check} = $NP_reads_tmp{$merge_files_check}."a";                  
                    my $output_file_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads{$merge_files_check}.".fasta"; 
                    $delete_input_files{$output_file_DB_tmp} = undef;
                    $merge_files_check = "";
                    $merge_files_check_first = "";
                }
            } 
            if ($file_lines{$NP_reads_tmp} < $adjusted_lines_perDB/1.3 && $count_files_tmp < $count_total_files && $count_total_files > $maxProcs_tmp && $merge_files_check eq "")
            {
                $merge_files_check = $NP_reads_tmp;
                $merge_files_check_first = substr $NP_reads{$NP_reads_tmp}, 0, -1;
                $NP_reads_tmp{$NP_reads_tmp} = substr $NP_reads{$NP_reads_tmp}, 0, -1;
                $file_lines_merged{$NP_reads_tmp} = $file_lines{$NP_reads_tmp};
                next;
            }
            my $output_file_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads{$NP_reads_tmp}.".fasta"; 
            $delete_input_files{$output_file_DB_tmp} = undef;         
        }
        if ($merge_files_check ne "")
        {
            $NP_reads{$merge_files_check} = $NP_reads_tmp{$merge_files_check}."a";
            $delete_input_files{$merge_files_check} = undef;
            my $output_file_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads{$merge_files_check}.".fasta"; 
            $delete_input_files{$output_file_DB_tmp} = undef;
        }
		
		opendir(DIR_NP2, $directory_DB_NP.$output_path_test) or die "Could not open $directory_DB_NP.$output_path_test\n";
		my @files = sort readdir(DIR_NP2);
		foreach my $filename (@files)
		{
			my $last5 = substr $filename, -5;
			if ($last5 eq "fasta" || $last5 eq "fastq")
			{                       
				#my $FILE_tmp3;
				#open ($FILE_tmp3, '<:raw', $NP_reads_tmp) or die "\n\nCan't open long reads file $NP_reads_tmp, $!\n";
				#close $FILE_tmp3;
				my $NP_reads_tmp2 = $directory_DB_NP.$output_path_test.$filename;
				#substr $filename, -6, 6, "";
				$NP_reads{$NP_reads_tmp2} = $count_files."a";
				$count_files++;
				
				$delete_input_files{$NP_reads_tmp2} = undef;
				my $output_file_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads{$NP_reads_tmp2}.".fasta"; 
				$delete_input_files{$output_file_DB_tmp} = undef;
				
				my $count_lines = qx(wc -l $NP_reads_tmp2);
                chomp($count_lines);
                my @count_lines = split /\s+/, $count_lines;
                $total_lines += $count_lines[0];
                $file_lines{$NP_reads_tmp2} = $count_lines[0];
			}
			elsif ($filename ne "." && $filename ne "..")
			{
				print "\n".$filename.": File extension not recognized!\n";
				print OUTPUT4 "\n".$filename.": File extension not recognized!\n";
			}   
		}
		close DIR_NP2;
				
		if ($use_quality_scores_NP eq "yes")
        {
			foreach my $NP_reads_tmp (keys %NP_reads)
			{
				my $output_file16_tmp  = $output_path."QUALITY_SCORES_TMP_".$NP_reads{$NP_reads_tmp}.".txt";
				push @QUALITY_HASH, $output_file16_tmp;
			}
		}
		
		my $file_count = keys %NP_reads;
		
		if ($file_count > $maxProcs_tmp && $NP_reads_DB eq "")
		{
			$NP_reads_DB = "yes";	
			goto NP_READS_DB;
		}

#Build local BLAST databse and save reads to disk---------------------------------------------------------------------------
    
        foreach my $NP_reads_tmp (keys %NP_reads)
        {
            my $pid;
            if ($file_count > 1)
            {
                $pid = $pm->start and next;
            }
       srand();     
            my $check_zip_long = substr $NP_reads_tmp, -2;
            my $check_zip_long2 = substr $NP_reads_tmp, -3;
            my $firstLine_long;
            my $secondLine_long;
            my $thirdLine_long;        

            my $read_count_tmp = '0';
            my $total_read_length_tmp = '0';
            my $max_read_length_tmp = '0';
            my $min_read_length_tmp = '0';
            my $removed_reads_min_tmp = '0';
			my $removed_reads_total_length_tmp = '0';
            my @read_lengths_tmp;
            
            my $FILE_tmp;
            if ($check_zip_long eq "gz")
            {
                open ($FILE_tmp, '-|', 'gzip', '-dc', $NP_reads_tmp) or die "Can't open file $NP_reads_tmp, $!\n";
            }
            elsif ($check_zip_long2 eq "bz2")
            {
                open ($FILE_tmp, '-|', 'bzip2', '-dc', $NP_reads_tmp) or die "Can't open file $NP_reads_tmp, $!\n";
            }
            else
            {
                open ($FILE_tmp, $NP_reads_tmp) or die "\n\nCan't open long reads file $NP_reads_tmp, $!\n";
            }
            $firstLine_long = <$FILE_tmp>;
            chomp $firstLine_long;
            $secondLine_long = <$FILE_tmp>;
            chomp $secondLine_long;
            $thirdLine_long = <$FILE_tmp>;
            chomp $thirdLine_long;
            close $FILE_tmp;
         
            my $no_quality_score_long_tmp = substr $thirdLine_long, 0, 1;
            my $quality_score_long = "";
            if ($thirdLine_long eq "+")
            {
                $quality_score_long = "yes";
            }
            
            my $read_limit = "10000000000000000000000000000000000000000000000000000";
            if ($subsample ne "")
            {
                my $command = "wc -l ".$NP_reads_tmp;
                my $lines = `$command`;
                chomp($lines);
                my @line_count = split / /, $lines;
                $read_limit = $subsample*($line_count[0]/4);
                if ($quality_score_long eq "")
                {
                    $read_limit = $subsample*($line_count[0]/2);
                }
            }
    
            my $FILE_LONG;
            if ($check_zip_long eq "gz")
            {
                open ($FILE_LONG, '-|', 'gzip', '-dc', $NP_reads_tmp) or die "Can't open file $NP_reads_tmp, $!\n";
            }
            elsif ($check_zip_long2 eq "bz2")
            {
                open ($FILE_LONG, '-|', 'bzip2', '-dc', $NP_reads_tmp) or die "Can't open file $NP_reads_tmp, $!\n";
            }
            else
            {
                open($FILE_LONG, $NP_reads_tmp) or die "\n\nCan't open long reads file $NP_reads_tmp, $!\n";
            }

            my $directory_tmp = $output_path."tmp_sequences_NP".$output_path_test.$NP_reads{$NP_reads_tmp};
            mkdir $directory_tmp;
            my $directory_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads{$NP_reads_tmp}.$output_path_test;
            mkdir $directory_DB_tmp;
            
            my $output_file_DB_tmp = $directory_DB_NP.$output_path_test.$NP_reads{$NP_reads_tmp}.".fasta";
            open(OUTPUT_DB_NP1, ">" .$output_file_DB_tmp) or die "\nCan't open file $output_file_DB_tmp, $!\n";
			
			my $FILE_HASH_TMP;
            
            if ($use_quality_scores_NP eq "yes")
            {
                my $output_file16_tmp  = $output_path."QUALITY_SCORES_TMP_".$NP_reads{$NP_reads_tmp}.".txt";
                open($FILE_HASH_TMP, ">".$output_file16_tmp) or die "Can't open file $output_file16_tmp, $!\n";
            }
            
            my $ww = '1';
            my $fail_or_pass = "";
            my $fail_or_pass2 = "";
            my $id_read = "";
			my $id_tmpi = "";
			my $removed_check = "";
            my %hash_NP_reads_kmer_tmp;
            undef %hash_NP_reads_kmer_tmp;
			my $count_files_in_folder = '0';
			my $subfolder_name = '1';
			my $directory_DB_sub_tmp = $output_path."tmp_sequences_NP".$output_path_test.$NP_reads{$NP_reads_tmp}.$output_path_test.$subfolder_name;
            mkdir $directory_DB_sub_tmp;
            
FILE_LONG:  while (my $line = <$FILE_LONG>)
            {
                if ($long_id_NP > $read_limit)
                {
                    last FILE_LONG;
                }
                chomp $line;    
                if ($fail_or_pass eq "fastq_fail" && $fail_or_pass2 > 0)
                {
                    $fail_or_pass2--;
                    next;
                }
                elsif ($ww eq '1')
                {
                    $fail_or_pass = substr $line, 0, 10;
                    if ($fail_or_pass eq "fastq_fail")
                    {
                        if ($quality_score_long eq "")
                        {
                            $fail_or_pass2 = '1';
                        }
                        else
                        {
                            $fail_or_pass2 = '3';
                        }
                        next;
                    }
                    if ($keep_read_ids eq "yes")
                    {
                        my @read_id = split / /, $line;
                        $id_read = $read_id[0];
                    }
                        
                    $ww++;
                    next;
                }
                elsif ($ww eq '2')
                {
                    #$line =~ tr/actgn/ACTGN/;
                    my $pos_tmp = '0';
                    $long_id_NP++;
                    
                    $id_tmpi = $NP_reads{$NP_reads_tmp}.$long_id_NP;
                    if ($keep_read_ids eq "yes")
                    {
                        $id_tmpi = $NP_reads{$NP_reads_tmp}.$id_read;
                    }
                    my $length_tmp = length($line);   
                    $total_read_length_tmp += $length_tmp;
                    
                    if ($length_tmp > $max_read_length_tmp)
                    {
                        $max_read_length_tmp = $length_tmp;
                    }
                    if ($length_tmp < $min_read_length_tmp || $min_read_length_tmp eq '0')
                    {
                        $min_read_length_tmp = $length_tmp;
                    }
                    $read_count_tmp++;
                    
                    push @read_lengths_tmp, $length_tmp;
                    
                    if ($length_tmp >= $minimum_read_length_NP)
                    {
                        #substr $line, 0, 40, "";
                        $count_files_in_folder++;
						if ($count_files_in_folder > $max_file_count)
						{
							$count_files_in_folder = '1';
							$subfolder_name++;
							$directory_DB_sub_tmp = $output_path."tmp_sequences_NP".$output_path_test.$NP_reads{$NP_reads_tmp}.$output_path_test.$subfolder_name;
							mkdir $directory_DB_sub_tmp;
						}
						$id_tmpi .= "a".$subfolder_name;
                        my $output_file_NP1  = $directory_tmp.$output_path_test.$subfolder_name.$output_path_test."sequence_tmp_NP_".$id_tmpi.".fasta";
                        unless (-e $output_file_NP1)
                        {
                            open(OUTPUT_LONG_NP1, ">" .$output_file_NP1) or die "\nCan't open file $output_file_NP1, $!\n";
                            print OUTPUT_LONG_NP1 $line;
                            close OUTPUT_LONG_NP1;
                        }
                        print OUTPUT_DB_NP1 ">".$id_tmpi."\n";
                        print OUTPUT_DB_NP1 $line."\n";
						$removed_check = "";
                    }
                    else
                    {
                        $removed_reads_min_tmp++;
						$removed_reads_total_length_tmp += $length_tmp;
						$removed_check = "yes";
                    }

                    if ($quality_score_long eq "")
                    {
                        $ww = '1';
                    }
                    else
                    {
                        $ww++
                    }
                }
                elsif ($ww eq '3')
                {
                    $ww++;
                    next;
                }
                elsif ($ww eq '4')
                {
                    $ww = '1';
					if ($use_quality_scores_NP eq "yes" && $removed_check eq "")
                    {
                        my $pos_tmp = '0';
						my $tmp_line = "";
						while ($pos_tmp < length($line)-1)
                        {
                            my $qscore = substr $line, $pos_tmp, 1;
                            $pos_tmp++;
							if ($qscore eq "!" || $qscore eq "\"" || $qscore eq "#" || $qscore eq "\$" || $qscore eq "%" || $qscore eq "&" || $qscore eq "'" || $qscore eq "(")
							{	
								if ($tmp_line eq "")
								{
									$tmp_line = $pos_tmp;
								}
								else
								{
									$tmp_line .= ",".$pos_tmp;
								}
							}
                        }
						print $FILE_HASH_TMP $id_tmpi."\n";
						print $FILE_HASH_TMP $tmp_line."\n";
                    }
                }
            }
            
            close $FILE_LONG;
			if ($use_quality_scores_NP eq "yes")
            {
				close $FILE_HASH_TMP;
			}
            close OUTPUT_DB_NP1;
            
            my $DB_direc_tmp = $directory_DB_tmp.$NP_reads{$NP_reads_tmp};
            my $DB_output_tmp = $output_path."DB_".$NP_reads{$NP_reads_tmp}."_tmp_file.txt";    
            my $command_make_DB = "makeblastdb -in ".$output_file_DB_tmp." -dbtype nucl -out ".$DB_direc_tmp." > ".$DB_output_tmp."";
            system($command_make_DB);
                      
            my %hash_tmp;
			undef %hash_tmp;
            if ($file_count > 1)
            {
                $hash_tmp{'1'} = $DB_direc_tmp;
                $hash_tmp{'2'} = $read_count_tmp;
                $hash_tmp{'3'} = $DB_output_tmp;
                $hash_tmp{'4'} = $total_read_length_tmp;
                $hash_tmp{'5'} = $min_read_length_tmp;
                $hash_tmp{'6'} = $max_read_length_tmp;
                $hash_tmp{'7'} = $removed_reads_min_tmp;
				$hash_tmp{'8'} = $removed_reads_total_length_tmp;
                $hash_tmp{'9'} = [@read_lengths_tmp];
                $pm->finish(0, \%hash_tmp);
            }
            else
            {
                $ret_data_NP{'1'} = $DB_direc_tmp;
                $ret_data2_NP{'1'} = $DB_output_tmp;
                $read_count_NP += $read_count_tmp;
                $total_read_length_NP += $total_read_length_tmp;
                $min_read_length_NP = $min_read_length_tmp;
                $max_read_length_NP = $max_read_length_tmp;
                $removed_reads_min_NP = $removed_reads_min_tmp;
				$removed_reads_total_length_NP = $removed_reads_total_length_tmp;
                @read_lengths_NP = (@read_lengths_NP, @read_lengths_tmp);
            }
        }
        if ($file_count > 1)
        {
            $pm->wait_all_children;
        }
        #my $long1 = keys %hash_long_reads;
        #my $long2 = keys %hash_long_reads_kmer;
        #print $long1." LONG1\n";
        #print $long2." LONG2\n";
    }
    print "...OK\n\n";
}

if ($input_reads_DB_folder_NP ne "")
{
    my $directory_DB_tmp1 = $directory_DB_NP.$output_path_test;
    opendir(DIR2, $directory_DB_tmp1) or die "Could not open $directory_DB_tmp1\n";
    my $count_tmp = '1';
    while (my $filename = readdir(DIR2))
    {
        if (-d $directory_DB_tmp1.$filename && $filename ne "." && $filename ne "..")
        {
            my $directory_DB_tmp2 = $directory_DB_tmp1.$filename.$output_path_test.$filename;
            $ret_data_NP{$count_tmp} = $directory_DB_tmp2;
            $count_tmp++;
        }
    }
    closedir DIR2;
}

if ($read_count_NP > 0)
{
    my $total_read_length_NP_tmp = '0';
    
    foreach my $read_length_tmp (sort {$b <=> $a} @read_lengths_NP)
    {
        $total_read_length_NP_tmp += $read_length_tmp;
        if ($total_read_length_NP_tmp > $total_read_length_NP/2)
        {
            $N50_NP = $read_length_tmp;
            last;
        }
    }
	
	my $statistics_NP  = $output_path.$output_path_test."BLAST_DB_NP".$output_path_test."statistics.txt";
	$average_length_NP = int($total_read_length_NP/$read_count_NP);

	open(STATS_NP, ">" .$statistics_NP) or die "\nCan't open file $statistics_NP, $!\n";
	print STATS_NP "Nanopore reads\n";
    print STATS_NP "--------------\n";
    print STATS_NP "Total count             : ".$read_count_NP."\n";
	print STATS_NP "Total length            : ".$total_read_length_NP." bp\n";
    print STATS_NP "N50                     : ".$N50_NP." bp\n";
    print STATS_NP "Average read length     : ".$average_length_NP." bp\n";
    print STATS_NP "Max read length         : ".$max_read_length_NP." bp\n";
    print STATS_NP "Min read length         : ".$min_read_length_NP." bp\n";
    print STATS_NP "Reads below min length  : ".$removed_reads_min_NP."\n";
	print STATS_NP "Total removed bp        : ".$removed_reads_total_length_NP." bp\n\n";
	close STATS_NP;	
    
    print "\n\nNanopore reads\n";
    print "--------------\n";
    print "Total count             : ".$read_count_NP."\n";
	print "Total length            : ".$total_read_length_NP." bp\n";
    print "N50                     : ".$N50_NP." bp\n";
    print "Average read length     : ".$average_length_NP." bp\n";
    print "Max read length         : ".$max_read_length_NP." bp\n";
    print "Min read length         : ".$min_read_length_NP." bp\n";
    print "Reads below min length  : ".$removed_reads_min_NP."\n";
	print "Total removed bp        : ".$removed_reads_total_length_NP." bp\n\n";
    
    print OUTPUT4 "\n\nNanopore reads\n";
    print OUTPUT4 "--------------\n";
    print OUTPUT4 "Total count             : ".$read_count_NP."\n";
	print OUTPUT4 "Total length            : ".$total_read_length_NP." bp\n";
    print OUTPUT4 "N50                     : ".$N50_NP." bp\n";
    print OUTPUT4 "Average read length     : ".$average_length_NP." bp\n";
    print OUTPUT4 "Max read length         : ".$max_read_length_NP." bp\n";
    print OUTPUT4 "Min read length         : ".$min_read_length_NP." bp\n";
    print OUTPUT4 "Reads below min length  : ".$removed_reads_min_NP."\n";
	print OUTPUT4 "Total removed bp        : ".$removed_reads_total_length_NP." bp\n\n";
}
elsif ($NP_reads ne "" || $input_reads_DB_folder_NP ne "")
{
	my $statistics_NP  = $input_reads_DB_folder_NP."BLAST_DB_NP".$output_path_test."statistics.txt";

	open(STATS_NP, $statistics_NP) or die "\nCan't open file $statistics_NP, $!\n";
	
	my $count_tmp = '0';
	while (my $line_tmp = <STATS_NP>)
	{
		$count_tmp++;
		if ($count_tmp eq '4')
		{
			my @line_tmp = split /\s+/, $line_tmp;
			$total_read_length_NP = $line_tmp[3];
		}
		if ($count_tmp eq '6')
		{
			my @line_tmp = split /\s+/, $line_tmp;
			$average_length_NP = $line_tmp[4];
		}
		if ($count_tmp eq '10')
		{
			my @line_tmp = split /\s+/, $line_tmp;
			$removed_reads_total_length_NP = $line_tmp[4];
		}
	}
	close STATS_NP;
}

if ($assembly_length_max ne "WG")
{
	unless ($assembly_length_max =~ /^\d+$/ )
	{
		my $output_path_test2b = substr $assembly_length_max, 0, 1;
		
		if ($output_path_test2b ne "\\" && $output_path_test2b ne "/" )
		{
			die "\nPlease give the full output path that starts and end with a directory separator (/ or \): $assembly_length_max, $!\n";                         
		}
		$assembly_refine = $assembly_length_max;
		$ploidy = '1';
	}
}

if ($sequencing_depth_NP eq "" && $genome_size > 0)
{
	$genome_size *= 1000000000;
	$sequencing_depth_NP = $total_read_length_NP/$genome_size;
}
$sequencing_depth_NP *= 0.7;
$sequencing_depth_NP /= $ploidy;

if ($total_read_length_NP > 0 && $removed_reads_total_length_NP > 0)
{
	my $reduced_fraction_NP = $removed_reads_total_length_NP/$total_read_length_NP;
	$sequencing_depth_NP -= int($reduced_fraction_NP*$sequencing_depth_NP);
	
	print "Reduced sequencing depth: ".($sequencing_depth_NP/0.7)*$ploidy."\n\n";
	print OUTPUT4 "Reduced sequencing depth: ".($sequencing_depth_NP/0.7)*$ploidy."\n\n";
}

#--------------------------------------------------------------------------------------------------------------------------------------------------------
#Make hash of PacBio reads----------------------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------------------------------------------

if ($PB_reads eq "")
{
	goto SKIP_PACBIO;
}
undef %original_input_files;
	
my $read_count_PB = '0';
my $total_read_length_PB = '0';
my $max_read_length_PB = '0';
my $min_read_length_PB = '0';
my $removed_reads_min_PB = '0';
my $removed_reads_total_length_PB = '0';
my $N50_PB = '0';
my @read_lengths_PB;

my $pm_PB = new Parallel::ForkManager($maxProcs_tmp);
my %ret_data_PB;
undef %ret_data_PB;
my %ret_data2_PB;
undef %ret_data2_PB;

$pm_PB->run_on_finish(
sub
{ 
    my @str = @_;
    my %hash_tmp = %{$str[5]};
    my $pid_PB = $str[0];

    # retrieve data structure from child
    if (defined($pid_PB))
    {  # children are not forced to send anything
        my $string = $hash_tmp{'1'};  # child passed a string reference
        my $string2 = $hash_tmp{'2'};
        my $string3 = $hash_tmp{'3'};
        my $string4 = $hash_tmp{'4'};
        my $string5 = $hash_tmp{'5'};
        my $string6 = $hash_tmp{'6'};
        my $string7 = $hash_tmp{'7'};
		my $string8 = $hash_tmp{'8'};
        my @string9 = @{$hash_tmp{'9'}};

        $ret_data_PB{$pid_PB} = $string;
        $ret_data2_PB{$pid_PB} = $string3;
        $read_count_PB += $string2;
        $total_read_length_PB += $string4;
        if ($string6 > $max_read_length_PB)
        {
            $max_read_length_PB = $string6;
        }
        if ($string5 < $min_read_length_PB || $min_read_length_PB eq '0')
        {
            $min_read_length_PB = $string5;
        }
        $removed_reads_min_PB += $string7;
		$removed_reads_total_length_PB += $string8;
        @read_lengths_PB = (@read_lengths_PB, @string9);
    }
    #else {  # problems occurring during storage or retrieval will throw a warning
  #print qq|No message received from child process $data_structure_reference!\n|;
#}
});

my $long_id_PB = '0';

if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
{
    my $PB_check_directory = substr $PB_reads, -1;

	if ($input_reads_DB_folder_PB eq "" && $PB_reads ne "")
	{
		if ($PB_check_directory eq $output_path_test)
		{
			$PB_check_directory = "yes";
		}
		elsif (-d $PB_reads)
		{
			$PB_reads .= $output_path_test;
			$PB_check_directory = "yes";
		}
		elsif (-e $PB_reads)
		{
		}
		else
		{
			die "\nThe PacBio input doesn't not seems to be an existing file or folder!: ".$PB_reads."\n";
		}
	}
	
	select(STDERR);
    $| = 1;
    select(STDOUT); # default
    $| = 1;
     print "\nBuilding local databases for the PacBio reads...";
    
    my %PB_reads;
	undef %PB_reads;
    my $count_files = '1';
   
    if ($PB_reads ne "")
    {
        my $disered_db_count = $maxProcs_tmp;
        if ($PB_check_directory eq "yes")
        {
            opendir(DIR_PB, $PB_reads) or die "Could not open $PB_reads\n";
            
            for my $filename (sort readdir(DIR_PB))
            {
                my $last5 = substr $filename, -5;
                if ($last5 eq "fasta" || $last5 eq "fastq" || $last5 eq "tq.gz" || $last5 eq "ta.gz" || $last5 eq "q.bz2" || $last5 eq "a.bz2")
                {
                    my $PB_reads_tmp = $PB_reads.$filename;
                    $PB_reads{$PB_reads_tmp} = $count_files."a";
                    $original_input_files{$PB_reads_tmp} = undef;
                    $count_files++;
                }
                elsif ($filename ne "." && $filename ne "..")
                {
                    print "\n".$filename.": File extension not recognized!\n";
                    print OUTPUT4 "\n".$filename.": File extension not recognized!\n";
                }
            }
            closedir DIR_PB;
        }
        else
        {
            $PB_reads{$PB_reads} = "1a";
            $original_input_files{$PB_reads} = undef;
            $count_files++;
        }
        
        my $total_lines = '0';
        my %file_lines;
		undef %file_lines;
        
        foreach my $PB_reads_tmp (keys %PB_reads)
        {
            my $check_zip_long = substr $PB_reads_tmp, -2;
            my $check_zip_long2 = substr $PB_reads_tmp, -3;           
            
            if ($check_zip_long eq "gz")
            {
                my $new_filename = substr $PB_reads_tmp, 0, -3;
                my @new_filename = split /$output_path_test/, $new_filename;
                my $g = @new_filename;
                $g--;
                $new_filename = $output_path.$new_filename[$g];
                my $return_value = system("gzip -c -q -k -d ".$PB_reads_tmp." > ".$new_filename);
                
                $delete_input_files{$new_filename} = undef;
                
                $PB_reads{$new_filename} = $PB_reads{$PB_reads_tmp};
                delete $PB_reads{$PB_reads_tmp};
                my $count_lines = qx(wc -l $new_filename);
                chomp($count_lines);
                my @count_lines = split /\s+/, $count_lines;
                $total_lines += $count_lines[0];
                $file_lines{$new_filename} = $count_lines[0];
            }
            elsif ($check_zip_long2 eq "bz2")
            {
                die "Can't read bz2 files, pleas decompress: $PB_reads_tmp, $!\n";
            }
            elsif ($check_zip_long2 eq "zip")
            {
                die "Can't read zip files, pleas decompress: $PB_reads_tmp, $!\n";
            }
            else
            {

                my $count_lines = qx(wc -l $PB_reads_tmp);
                chomp($count_lines);
                my @count_lines = split /\s+/, $count_lines;
                $total_lines += $count_lines[0];
                $file_lines{$PB_reads_tmp} = $count_lines[0];
            }        
        }
        my $lines_perDB = int($total_lines/$maxProcs_tmp)+8;
        my $adjusted_lines_perDB = (int($lines_perDB/4) * 4)+4;
		my $PB_reads_DB = "";
PB_READS_DB: 
		
		my $count_total_files = keys %file_lines;
        my $count_files_tmp = '0';
        my $merge_files_check = "";
        my $merge_files_check_first = "";
        my %file_lines_merged;
		undef %file_lines_merged;
        my %PB_reads_tmp;
		undef %PB_reads_tmp;
     
		foreach my $PB_reads_tmp (sort keys %file_lines)
        {
            $count_files_tmp++;

            if ($file_lines{$PB_reads_tmp} > $adjusted_lines_perDB*1.15)
            {
                my $command_split = "split --additional-suffix=".$PB_reads{$PB_reads_tmp}.".fasta -l ".$adjusted_lines_perDB." ".$PB_reads_tmp." ".$directory_DB_PB.$output_path_test;                   
                my $return_value = system($command_split);
                
                my $expected_files = $file_lines{$PB_reads_tmp}/$adjusted_lines_perDB;
                my $expected_files0 = $file_lines{$PB_reads_tmp}/$adjusted_lines_perDB;
				
                if ($expected_files0 > int($expected_files0))
                {
                    $expected_files = int($expected_files0)+1;
                }
                my $found_files = 0;

                while ($found_files < $expected_files)
                {
                    $found_files = 0;
                    
                    # Check for the existence of the expected files
                    for my $file (glob("$directory_DB_PB$output_path_test*"))
                    {
                        if (-s $file)
						{
							$found_files++;
						}
                    }           
                    # Sleep for a bit if not all files have been found
                    sleep(10) if $found_files < $expected_files;
                }
                delete $PB_reads{$PB_reads_tmp};
				delete $file_lines{$PB_reads_tmp};
            }
            elsif ($merge_files_check ne "")
            {
                my $combined_lines = $file_lines{$PB_reads_tmp} + $file_lines_merged{$merge_files_check};

                if ($combined_lines < $adjusted_lines_perDB*1.15)
                {  
                    my $output_tmp = $directory_DB_PB.$output_path_test.$count_files_tmp."m".$merge_files_check_first.".fasta";
                    my $command_merge = "cat ".$merge_files_check." ".$PB_reads_tmp." > ".$output_tmp;                   
                    my $return_value = system($command_merge);
                    delete $PB_reads{$PB_reads_tmp};
                    delete $PB_reads{$merge_files_check};
					delete $file_lines{$PB_reads_tmp};

                    my $time_before_check_tmp = time;
COUNT_LINES_PB:                   
                    my $count_lines = qx(wc -l $output_tmp);
                    chomp($count_lines);
                    my @count_lines = split /\s+/, $count_lines;
                    my $count_lines2 = $count_lines[0];

                    if ($count_lines2 eq $combined_lines)
                    {      
                        unless (exists($original_input_files{$merge_files_check}))
                        {
                            unlink $merge_files_check;
                        }
                        unless (exists($original_input_files{$PB_reads_tmp}))
                        {
                            unlink $PB_reads_tmp;
                        } 
                    }
                    elsif (time > $time_before_check_tmp+600)
                    {
                        print "ERROR: Can't merge input files\n";
                        goto END1;
                    }
                    else
                    {
                        goto COUNT_LINES_PB;
                    }
                    
                    $PB_reads_tmp{$output_tmp} = $count_files_tmp."m".$merge_files_check_first;
                    $merge_files_check = $output_tmp;
                    $file_lines_merged{$merge_files_check} = $combined_lines;
                    my $output_file_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads_tmp{$output_tmp}.".fasta"; 
                    $delete_input_files{$output_file_DB_tmp} = undef;
                    $delete_input_files{$output_tmp} = undef;               
                }
                elsif ($file_lines_merged{$merge_files_check} > $adjusted_lines_perDB/1.4)
                { 
                    $PB_reads{$merge_files_check} = $PB_reads_tmp{$merge_files_check}."a";                  
                    my $output_file_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads{$merge_files_check}.".fasta"; 
                    $delete_input_files{$output_file_DB_tmp} = undef;
                    $merge_files_check = "";
                    $merge_files_check_first = "";
                }
            } 
            if ($file_lines{$PB_reads_tmp} < $adjusted_lines_perDB/1.3 && $count_files_tmp < $count_total_files && $count_total_files > $maxProcs_tmp && $merge_files_check eq "")
            {
                $merge_files_check = $PB_reads_tmp;
                $merge_files_check_first = substr $PB_reads{$PB_reads_tmp}, 0, -1;
                $PB_reads_tmp{$PB_reads_tmp} = substr $PB_reads{$PB_reads_tmp}, 0, -1;
                $file_lines_merged{$PB_reads_tmp} = $file_lines{$PB_reads_tmp};
                next;
            }
            my $output_file_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads{$PB_reads_tmp}.".fasta"; 
            $delete_input_files{$output_file_DB_tmp} = undef;         
        }      
		if ($merge_files_check ne "")
        {
            $PB_reads{$merge_files_check} = $PB_reads_tmp{$merge_files_check}."a";
            $delete_input_files{$merge_files_check} = undef;
            my $output_file_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads{$merge_files_check}.".fasta"; 
            $delete_input_files{$output_file_DB_tmp} = undef;
        }
		
		opendir(DIR_PB2, $directory_DB_PB.$output_path_test) or die "Could not open $directory_DB_PB.$output_path_test\n";
		my @files = sort readdir(DIR_PB2);
		foreach my $filename (@files)
		{
			my $last5 = substr $filename, -5;
			if ($last5 eq "fasta" || $last5 eq "fastq")
			{                       
				my $PB_reads_tmp2 = $directory_DB_PB.$output_path_test.$filename;
				$PB_reads{$PB_reads_tmp2} = $count_files."a";
				$count_files++;
				
				$delete_input_files{$PB_reads_tmp2} = undef;
				my $output_file_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads{$PB_reads_tmp2}.".fasta"; 
				$delete_input_files{$output_file_DB_tmp} = undef;
				
				my $count_lines = qx(wc -l $PB_reads_tmp2);
                chomp($count_lines);
                my @count_lines = split /\s+/, $count_lines;
                $total_lines += $count_lines[0];
                $file_lines{$PB_reads_tmp2} = $count_lines[0];
			}
			elsif ($filename ne "." && $filename ne "..")
			{
				print "\n".$filename.": File extension not recognized!\n";
				print OUTPUT4 "\n".$filename.": File extension not recognized!\n";
			}   
		}
		close DIR_PB2;
				
		my $file_count = keys %PB_reads;
		
		if ($file_count > $maxProcs_tmp && $PB_reads_DB eq "")
		{
			$PB_reads_DB = "yes";	
			goto PB_READS_DB;
		}
      
#Build local BLAST databse and save reads to disk---------------------------------------------------------------------------
       
        foreach my $PB_reads_tmp (keys %PB_reads)
        {
            my $pid_PB;
            if ($file_count > 1)
            {
                $pid_PB = $pm_PB->start and next;
            }
       srand();     
            my $check_zip_long = substr $PB_reads_tmp, -2;
            my $check_zip_long2 = substr $PB_reads_tmp, -3;
            my $firstLine_long;
            my $secondLine_long;
            my $thirdLine_long;        

            my $read_count_tmp = '0';
            my $total_read_length_tmp = '0';
            my $max_read_length_tmp = '0';
            my $min_read_length_tmp = '0';
            my $removed_reads_min_tmp = '0';
			my $removed_reads_total_length_tmp = '0';
            my @read_lengths_tmp;
            
            my $FILE_tmp;
            if ($check_zip_long eq "gz")
            {
                open ($FILE_tmp, '-|', 'gzip', '-dc', $PB_reads_tmp) or die "Can't open file $PB_reads_tmp, $!\n";
            }
            elsif ($check_zip_long2 eq "bz2")
            {
                open ($FILE_tmp, '-|', 'bzip2', '-dc', $PB_reads_tmp) or die "Can't open file $PB_reads_tmp, $!\n";
            }
            else
            {
                open ($FILE_tmp, $PB_reads_tmp) or die "\n\nCan't open long reads file $PB_reads_tmp, $!\n";
            }
            $firstLine_long = <$FILE_tmp>;
            chomp $firstLine_long;
            $secondLine_long = <$FILE_tmp>;
            chomp $secondLine_long;
            $thirdLine_long = <$FILE_tmp>;
            chomp $thirdLine_long;
            close $FILE_tmp;

            my $no_quality_score_long_tmp = substr $thirdLine_long, 0, 1;
            my $quality_score_long = "";
            if ($thirdLine_long eq "+")
            {
                $quality_score_long = "yes";
            }
			
			my $read_limit = "10000000000000000000000000000000000000000000000000000";
            if ($subsample ne "")
            {
                my $command = "wc -l ".$PB_reads_tmp;
                my $lines = `$command`;
                chomp($lines);
                my @line_count = split / /, $lines;
                $read_limit = $subsample*($line_count[0]/4);
                if ($quality_score_long eq "")
                {
                    $read_limit = $subsample*($line_count[0]/2);
                }
            }
            
            my $FILE_LONG;
            if ($check_zip_long eq "gz")
            {
                open ($FILE_LONG, '-|', 'gzip', '-dc', $PB_reads_tmp) or die "Can't open file $PB_reads_tmp, $!\n";
            }
            elsif ($check_zip_long2 eq "bz2")
            {
                open ($FILE_LONG, '-|', 'bzip2', '-dc', $PB_reads_tmp) or die "Can't open file $PB_reads_tmp, $!\n";
            }
            else
            {
                open($FILE_LONG, $PB_reads_tmp) or die "\n\nCan't open long reads file $PB_reads_tmp, $!\n";
            }

            my $directory_tmp = $output_path."tmp_sequences_PB".$output_path_test.$PB_reads{$PB_reads_tmp};
            mkdir $directory_tmp;
            my $directory_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads{$PB_reads_tmp}.$output_path_test;
            mkdir $directory_DB_tmp;
            
            my $output_file_DB_tmp = $directory_DB_PB.$output_path_test.$PB_reads{$PB_reads_tmp}.".fasta";
            open(OUTPUT_DB_PB1, ">" .$output_file_DB_tmp) or die "\nCan't open file $output_file_DB_tmp, $!\n";
            
            my $ww = '1';
            my $fail_or_pass = "";
            my $fail_or_pass2 = "";
            my $id_read = "";
			my $id_tmpi = "";
			my $removed_check = "";
            my %hash_PB_reads_kmer_tmp;
			undef %hash_PB_reads_kmer_tmp;
			my $count_files_in_folder = '0';
			my $subfolder_name = '1';
			my $directory_DB_sub_tmp = $output_path."tmp_sequences_PB".$output_path_test.$PB_reads{$PB_reads_tmp}.$output_path_test.$subfolder_name;
            mkdir $directory_DB_sub_tmp;
  
FILE_LONG_PB:while (my $line = <$FILE_LONG>)
            {
                if ($long_id_PB > $read_limit)
                {
                    last FILE_LONG_PB;
                }
                chomp $line;    
                if ($fail_or_pass eq "fastq_fail" && $fail_or_pass2 > 0)
                {
                    $fail_or_pass2--;
                    next;
                }
                elsif ($ww eq '1')
                {
                    $fail_or_pass = substr $line, 0, 10;
                    if ($fail_or_pass eq "fastq_fail")
                    {
                        if ($quality_score_long eq "")
                        {
                            $fail_or_pass2 = '1';
                        }
                        else
                        {
                            $fail_or_pass2 = '3';
                        }
                        next;
                    }
                    if ($keep_read_ids eq "yes")
                    {
                        my @read_id = split / /, $line;
                        $id_read = $read_id[0];
                    }
                        
                    $ww++;
                    next;
                }
                elsif ($ww eq '2')
                {
                    #$line =~ tr/actgn/ACTGN/;
                    my $pos_tmp = '0';
                    $long_id_PB++;
                    
                    my $id_tmpi = $PB_reads{$PB_reads_tmp}.$long_id_PB;
                    if ($keep_read_ids eq "yes")
                    {
                        $id_tmpi = $PB_reads{$PB_reads_tmp}.$id_read;
                    }
                    my $length_tmp = length($line);   
                    $total_read_length_tmp += $length_tmp;
                    
                    if ($length_tmp > $max_read_length_tmp)
                    {
                        $max_read_length_tmp = $length_tmp;
                    }
                    if ($length_tmp < $min_read_length_tmp || $min_read_length_tmp eq '0')
                    {
                        $min_read_length_tmp = $length_tmp;
                    }
                    $read_count_tmp++;
                    
                    push @read_lengths_tmp, $length_tmp;
					
					if ($length_tmp >= $minimum_read_length_PB)
                    {
                        #substr $line, 0, 40, "";
                        $count_files_in_folder++;
						if ($count_files_in_folder > $max_file_count)
						{
							$count_files_in_folder = '1';
							$subfolder_name++;
							$directory_DB_sub_tmp = $output_path."tmp_sequences_PB".$output_path_test.$PB_reads{$PB_reads_tmp}.$output_path_test.$subfolder_name;
							mkdir $directory_DB_sub_tmp;
						}
						$id_tmpi .= "a".$subfolder_name;
                        my $output_file_PB1  = $directory_tmp.$output_path_test.$subfolder_name.$output_path_test."sequence_tmp_PB_".$id_tmpi.".fasta";
                        unless (-e $output_file_PB1)
                        {
                            open(OUTPUT_LONG_PB1, ">" .$output_file_PB1) or die "\nCan't open file $output_file_PB1, $!\n";
                            print OUTPUT_LONG_PB1 $line;
                            close OUTPUT_LONG_PB1;
                        }
                        print OUTPUT_DB_PB1 ">".$id_tmpi."\n";
                        print OUTPUT_DB_PB1 $line."\n";
						$removed_check = "";
                    }
                    else
                    {
                        $removed_reads_min_tmp++;
						$removed_reads_total_length_tmp += $length_tmp;
						$removed_check = "yes";
                    }

                    if ($quality_score_long eq "")
                    {
                        $ww = '1';
                    }
                    else
                    {
                        $ww++
                    }
                }
                elsif ($ww eq '3')
                {
                    $ww++;
                    next;
                }
                elsif ($ww eq '4')
                {
                    $ww = '1';
                    next;
                }
            }
            
            close $FILE_LONG;
            close OUTPUT_DB_PB1;
            
            my $DB_direc_tmp = $directory_DB_tmp.$PB_reads{$PB_reads_tmp};
            my $DB_output_tmp = $output_path."DB_".$PB_reads{$PB_reads_tmp}."_tmp_file.txt";    
            my $command_make_DB = "makeblastdb -in ".$output_file_DB_tmp." -dbtype nucl -out ".$DB_direc_tmp." > ".$DB_output_tmp."";
            system($command_make_DB);
                      
            my %hash_tmp;
			undef %hash_tmp;
            if ($file_count > 1)
            {
                $hash_tmp{'1'} = $DB_direc_tmp;
                $hash_tmp{'2'} = $read_count_tmp;
                $hash_tmp{'3'} = $DB_output_tmp;
                $hash_tmp{'4'} = $total_read_length_tmp;
                $hash_tmp{'5'} = $min_read_length_tmp;
                $hash_tmp{'6'} = $max_read_length_tmp;
                $hash_tmp{'7'} = $removed_reads_min_tmp;
				$hash_tmp{'8'} = $removed_reads_total_length_tmp;
                $hash_tmp{'9'} = [@read_lengths_tmp];
                $pm_PB->finish(0, \%hash_tmp);
            }
            else
            {
                $ret_data_PB{$pid_PB} = $DB_direc_tmp;
                $ret_data2_PB{$pid_PB} = $DB_output_tmp;
                $read_count_PB += $read_count_tmp;
                $total_read_length_PB += $total_read_length_tmp;
                $min_read_length_PB = $min_read_length_tmp;
                $max_read_length_PB = $max_read_length_tmp;
                $removed_reads_min_PB = $removed_reads_min_tmp;
				$removed_reads_total_length_PB = $removed_reads_total_length_tmp;
                @read_lengths_PB = (@read_lengths_PB, @read_lengths_tmp);
            }
        }
        if ($file_count > 1)
        {
            $pm_PB->wait_all_children;
        }
    }
    print "...OK\n\n";
}
SKIP_PACBIO:
if ($input_reads_DB_folder_PB ne "")
{
    my $directory_DB_tmp1 = $directory_DB_PB.$output_path_test;
    opendir(DIR_PB3, $directory_DB_tmp1) or die "Could not open $directory_DB_tmp1\n";
    my $count_tmp = '1';
    while (my $filename = readdir(DIR_PB3))
    {
        if (-d $directory_DB_tmp1.$filename && $filename ne "." && $filename ne "..")
        {
            my $directory_DB_tmp2 = $directory_DB_tmp1.$filename.$output_path_test.$filename;
            $ret_data_PB{$count_tmp} = $directory_DB_tmp2;
            $count_tmp++;
        }
    }
    closedir DIR_PB3;
}

if ($read_count_PB > 0)
{
    my $total_read_length_PB_tmp = '0';
    
    foreach my $read_length_tmp (sort {$b <=> $a} @read_lengths_PB)
    {
        $total_read_length_PB_tmp += $read_length_tmp;
        if ($total_read_length_PB_tmp > $total_read_length_PB/2)
        {
            $N50_PB = $read_length_tmp;
            last;
        }
    }

	my $statistics_PB  = $output_path.$output_path_test."BLAST_DB_PB".$output_path_test."statistics.txt";
	$average_length_PB = int($total_read_length_PB/$read_count_PB);
	
	open(STATS_PB, ">" .$statistics_PB) or die "\nCan't open file $statistics_PB, $!\n";
	print STATS_PB "PacBio reads\n";
    print STATS_PB "--------------\n";
    print STATS_PB "Total count             : ".$read_count_PB."\n";
	print STATS_PB "Total length            : ".$total_read_length_PB." bp\n";
    print STATS_PB "N50                     : ".$N50_PB." bp\n";
    print STATS_PB "Average read length     : ".int($total_read_length_PB/$read_count_PB)." bp\n";
    print STATS_PB "Max read length         : ".$max_read_length_PB." bp\n";
    print STATS_PB "Min read length         : ".$min_read_length_PB." bp\n";
    print STATS_PB "Reads below min length  : ".$removed_reads_min_PB."\n";
	print STATS_PB "Total removed bp        : ".$removed_reads_total_length_PB." bp\n\n";
	close STATS_PB;	
    
    print "\n\nPacBio reads\n";
    print "--------------\n";
    print "Total count             : ".$read_count_PB."\n";
	print "Total length            : ".$total_read_length_PB." bp\n";
    print "N50                     : ".$N50_PB." bp\n";
    print "Average read length     : ".int($total_read_length_PB/$read_count_PB)." bp\n";
    print "Max read length         : ".$max_read_length_PB." bp\n";
    print "Min read length         : ".$min_read_length_PB." bp\n";
    print "Reads below min length  : ".$removed_reads_min_PB."\n";
	print "Total removed bp        : ".$removed_reads_total_length_PB." bp\n\n";
    
    print OUTPUT4 "\n\nPacBio reads\n";
    print OUTPUT4 "--------------\n";
    print OUTPUT4 "Total count             : ".$read_count_PB."\n";
	print OUTPUT4 "Total length            : ".$total_read_length_PB." bp\n";
    print OUTPUT4 "N50                     : ".$N50_PB." bp\n";
    print OUTPUT4 "Average read length     : ".int($total_read_length_PB/$read_count_PB)." bp\n";
    print OUTPUT4 "Max read length         : ".$max_read_length_PB." bp\n";
    print OUTPUT4 "Min read length         : ".$min_read_length_PB." bp\n";
    print OUTPUT4 "Reads below min length  : ".$removed_reads_min_PB."\n";
	print OUTPUT4 "Total removed bp        : ".$removed_reads_total_length_PB." bp\n\n";
}
elsif ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
{
	my $statistics_PB  = $input_reads_DB_folder_PB."BLAST_DB_PB".$output_path_test."statistics.txt";

	open(STATS_PB, $statistics_PB) or die "\nCan't open file $statistics_PB, $!\n";
	
	my $count_tmp = '0';
	while (my $line_tmp = <STATS_PB>)
	{
		$count_tmp++;
		if ($count_tmp eq '4')
		{
			my @line_tmp = split /\s+/, $line_tmp;
			$total_read_length_PB = $line_tmp[3];
		}
		if ($count_tmp eq '6')
		{
			my @line_tmp = split /\s+/, $line_tmp;
			$average_length_PB = $line_tmp[4];
		}
		if ($count_tmp eq '10')
		{
			my @line_tmp = split /\s+/, $line_tmp;
			$removed_reads_total_length_PB = $line_tmp[4];
		}
	}
	close STATS_PB;
}

if ($sequencing_depth_PB eq "" && $genome_size > 0)
{
	$genome_size *= 1000000;
	$sequencing_depth_PB = $total_read_length_PB/$genome_size;
}
$sequencing_depth_PB *= 0.7;
$sequencing_depth_PB /= $ploidy;

if ($total_read_length_PB > 0 && $removed_reads_total_length_PB > 0)
{
	my $reduced_fraction_PB = $removed_reads_total_length_PB/$total_read_length_PB;
	$sequencing_depth_PB -= int($reduced_fraction_PB*$sequencing_depth_PB);
	
	print "Reduced sequencing depth: ".$sequencing_depth_PB/0.7."\n\n";
	print OUTPUT4 "Reduced sequencing depth: ".$sequencing_depth_PB/0.7."\n\n";
}

#spin up worker early before creating big hash---------

my $chnl;
$chnl = MCE::Channel->new( impl => 'Simple' );

mce_child
{
    local $SIG{__WARN__} = sub {};
    while ( my ($cmd, @args) = $chnl->recv ) {
        local ($?, $!);
        system($cmd, @args);
        $chnl->send2($?, $!);
    }
};

sub syscmd {
    my $cmd = shift;
    return unless $cmd;

    $chnl->send($cmd, @_);
    my ($status, $errmsg) = $chnl->recv2;
    
    if ($status == -1) {
        print "SYSTEM: failed to execute ($cmd): $errmsg\n";
    }
    elsif ($status & 127) {
        printf "SYSTEM: $cmd died with signal %s, %s coredump\n",
            ($status & 127), ($status & 128) ? 'with' : 'without';
    }
    else {
        #printf "SYSTEM: $cmd exited with status %d\n", $status >> 8;
    }
}


#Load long reads quality hashes from file--------------------------------------------------
if ($use_quality_scores_NP eq "yes")
{
	foreach my $hash_tmp (@QUALITY_HASH)
	{
		my $merge_command2 = "cat ".$hash_tmp." >> ".$output_path."quality_scores_".$project.".txt";
		system($merge_command2);
		my $FILE_Q;
		open($FILE_Q, $hash_tmp) or die "Can't open variation file $hash_tmp, $!\n";
		my $id_tmp = "";
		while (my $line = <$FILE_Q>)
		{
			chomp($line);
			if ($id_tmp eq "")
			{
				$id_tmp = $line;
				next;
			}
			else
			{
				$quality_scores_NP{$id_tmp} = $line;
				$id_tmp = "";
			}   
		}
		close $FILE_Q;
	}
}
elsif ($use_quality_scores_NP ne "")
{
    my $count_kmer = '0';
    my $longest_kmer = '0';
    my $read_count = '0';

    open(INPUT7, $use_quality_scores_NP) or die "Can't open quality score file, $!\n";
    my $id_tmp = "";

    while (my $line = <INPUT7>)
    {
        chomp($line);
        if ($id_tmp eq "")
        {
            $id_tmp = $line;
            next;
        }
        else
        {
            $quality_scores_NP{$id_tmp} = $line;
			$id_tmp = "";
        }   
    }
    close INPUT7;
}

select(STDERR);
$| = 1;
select(STDOUT); # default
$| = 1;

print "\nPrepare seeds...";
print OUTPUT4 "\nPrepare seeds...\n";

#Retrieve first read from the given seed-----------------------------------------------------------------------------------------------------------------------------------

my $si = '0';
my $space_at_end2 = "";
my $id_line = "";
my %seeds_list;
undef %seeds_list;
my %seeds_list_sorted;
undef %seeds_list_sorted;
my $count_seeds0 = '0';

if ($assembly_length_max ne "WG" && $assembly_refine eq "")
{
	while (my $line = <INPUT3>)
	{
		chomp($line);
		$line =~ tr/\r//d;
		$line =~ s/\R/\012/;
		$line =~ s/[ \t\xA0]+$//; 
		if ($si eq 0)
		{
			my $last_character = substr $line, -1;       
			if ($last_character =~ m/\s|\t/g)
			{
				$space_at_end2 = "yes";
			}
			$id_line = $line;
		}
		if ($si > 0)
		{
			my $first_letter = substr $line, 0, 1;
			if ($first_letter eq ">")
			{
				$count_seeds0++;
				my $id_tmp = substr $id_line, 1;
				$seeds_list{$id_tmp} = $seed_input;
				$seeds_list_sorted{$count_seeds0} = $id_tmp;
				$y{$id_tmp} = '1';
				$seed_input = "";
				$seed_batch = "yes";
				$id_line = $line;
			}
			else
			{
				if ($space_at_end2 eq "yes")
				{
					chop($line);
				}
				my $seed_input_tmp = $seed_input;
				$seed_input = $seed_input_tmp.$line;
			}   
		}
		$si++;
	}
	$count_seeds0++;
	my $id_tmp = substr $id_line, 1;
	$seeds_list{$id_tmp} = $seed_input;
	$seeds_list_sorted{$count_seeds0} = $id_tmp;
	$y{$id_tmp} = '1';
}


if ($ploidy > 1 && $count_seeds0 < 2)
{
    $find_haps_in_seed = "yes";
}

my %lengths_ass;
undef %lengths_ass;
my %contigs_ass;
undef %contigs_ass;
my %merged_ass;
undef %merged_ass;
my %merged_ass2;
undef %merged_ass2;
my $first_ass_seed = "";
my $DB_direc_refine_tmp = "";

if ($assembly_refine ne "")
{
	$DB_direc_refine_tmp = $output_path."DB_ASSEMBLY/DB_ASSEMBLY";
	mkdir $DB_direc_refine_tmp;
	my $DB_output_tmp = $output_path."DB_ASSEMBLY_tmp_file.txt";    
	my $command_make_DB = "makeblastdb -in ".$assembly_refine." -dbtype nucl -out ".$DB_direc_refine_tmp." > ".$DB_output_tmp."";
	system($command_make_DB);

	my $FILE_ASS1;
	open($FILE_ASS1, $assembly_refine) or die "\n\nCan't open assembly file $assembly_refine, $!\n";
	my $contig_id1 = "";
	my $contig_seq1 = "";
	
	while (my $line1 = <$FILE_ASS1>)
	{   
		chomp $line1;
		$line1 =~ tr/\r//d;
		$line1 =~ s/\R/\012/;
		my $first_char = substr $line1, 0, 1;
		if ($first_char eq ">" && $contig_id1 eq "")
		{
			$contig_id1 = substr $line1, 1;
			next;
		}
		elsif ($first_char eq ">")
		{	
			$lengths_ass{$contig_id1} = length($contig_seq1);
			$contigs_ass{$contig_id1} = $contig_seq1;
			my $last_nuc_tmp = substr $contig_id1, -1, 1;
			
			if (length($contig_seq1) > 250000 && $first_ass_seed eq "" && $last_nuc_tmp ne "c")
			{
				substr $contig_seq1, 0, 10000, "";
				substr $contig_seq1, -10000, 10000, "";
				$first_ass_seed = $contig_seq1;
				$seeds_list{$contig_id1} = $first_ass_seed;
				$seeds_list_sorted{'1'} = $contig_id1;
				$y{$contig_id1} = '1';
				$seed_input = $first_ass_seed;
				print OUTPUT4 "Assembly contig ID    : ".$contig_id1."\n";
				print OUTPUT4 "Assembly contig length: ".$lengths_ass{$contig_id1}."\n";
			}
			$contig_id1 = substr $line1, 1;
			$contig_seq1 = "";
		}
		else
		{
			$contig_seq1 .= $line1;
		}
	}
	substr $contig_id1, 0, 1, "";
	$lengths_ass{$contig_id1} = length($contig_seq1);
	$contigs_ass{$contig_id1} = $contig_seq1;
	close $FILE_ASS1;
}

my %find_haps_in_seed;
undef %find_haps_in_seed;
my $found_haps_in_seed = "";
my $next_seed_print = "yes";
my $last_seed = "";
my $first_back_assembly = "";

#SEED select for WG mode----------------------------------------------------------------------------------------------------------------

my %split_contigs_reads;
undef %split_contigs_reads;
my %split_contigs_reads2;
undef %split_contigs_reads2;
my %split_contigs_ends;
undef %split_contigs_ends;
my %contig_connections;
undef %contig_connections;
my %reads_as_seeds;
undef %reads_as_seeds;
my $keep_track_of_reads_number = '0';
my $output_file20 = "";
my $contig_number = '1';

if ($assembly_length_max eq "WG")
{
	my $output_file19  = $output_path."Assembled_read_ids_".$project.".txt";
	$output_file20  = $output_path."align_assemblies_".$project.".fasta";
	
	unless (-e $output_file19)
	{	
		open(OUTPUT19, ">".$output_file19) or die "Can't open file $output_file19, $!\n";
	}
	else
	{
		open(INPUT19, $output_file19) or die "Can't open assembled reads file, $!\n";
		while (my $line_tmp = <INPUT19>)
		{
			chomp($line_tmp);
			$reads_as_seeds{$line_tmp} = undef;
		}
		close INPUT19;
		open(OUTPUT19, ">>".$output_file19) or die "Can't open file $output_file19, $!\n";
	}
	unless (-e $output_file20)
	{	
		open(OUTPUT20, ">".$output_file20) or die "Can't open file $output_file20, $!\n";
	}
	else
	{
		open(OUTPUT20, ">>".$output_file20) or die "Can't open file $output_file20, $!\n";
		print OUTPUT20 "\n";
	}
}
my $generated_script = $output_path."next_seed.pl";
my $seed_directory = $output_path."Seed_results";
#Make whole genome seed script--------------------------------------------------------------------------------------
if ($assembly_length_max eq "WG")
{
	# Open the file for writing
	open(my $fh_script, '>', $generated_script) or die "Cannot open $generated_script: $!";
	
	mkdir $seed_directory;
	my $TMP_directory_tmp = substr $TMP_directory, 0, -1;

# Write the content to the new script
print $fh_script <<"END_SCRIPT";
use strict;
use warnings;
use Getopt::Long;

my \$sequence_tmp_file;
my \$file_name_3;
my \$keep_track_of_reads_number;

GetOptions (
            "a=s" => \\\$sequence_tmp_file,
			"b=s" => \\\$file_name_3,
			"c=s" => \\\$keep_track_of_reads_number,
            ) or die "Incorrect usage!\\n";

open(OUTPUT_SEQ_TMP, \$sequence_tmp_file) or die "\\nCan't open file \$sequence_tmp_file, \$!\\n";
my \$seed_input_tmpi = <OUTPUT_SEQ_TMP>;
my \$file_tmp;
my \$output_file25;
my \$output_values_file = "$seed_directory/seed_results_\$keep_track_of_reads_number.txt";
open(OUTPUT_FH, ">", \$output_values_file) or die "Can't open FH OUTPUT file \$output_values_file, \$!\\n";

if (length(\$seed_input_tmpi) > 2500)
{
    \$output_file25 = "$TMP_directory_tmp/Sequence_blast_test_$project\_".\$file_name_3.".fasta";
    open(OUTPUT25, ">".\$output_file25) or die "Can't open file \$output_file25, \$!\\n";
    OUTPUT25->autoflush(1);
    my \$last1000 = substr \$seed_input_tmpi, -1000;
    print OUTPUT25 ">Query\\n";
    print OUTPUT25 \$last1000."\\n";
    close OUTPUT25;
    
    if (-s "$output_file20" && -s \$output_file25)
	{
        \$file_tmp = "$TMP_directory_tmp/blast_seed_test_$project\_".\$file_name_3.".txt";
        my \$command = "blastn -query ".\$output_file25." -subject $output_file20 -out ".\$file_tmp." -outfmt 7 -qcov_hsp_perc 40";
        system(\$command);
        my \$count_tmp = '0';
WG_SEED_ACCEPT:
        if (-s \$file_tmp)
		{
            open(SEED_TEST, \$file_tmp) or die "\\nCan't open file \$file_tmp, \$!\\n";
            my \$count_lines_tmp = '1';
            while (my \$line_tmp = <SEED_TEST>) {
                chomp(\$line_tmp);
                if (\$count_lines_tmp eq '4' && \$line_tmp eq "# 0 hits found")
				{
                    close SEED_TEST;
                    goto WG_SEED_ACCEPT2;
                }
                elsif (\$count_lines_tmp eq '5' && \$line_tmp eq "# BLAST processed 1 queries")
				{
                    close SEED_TEST;
                    goto WG_SEED_ACCEPT;
                }
                elsif (\$count_lines_tmp > 5)
				{
                    my \@line_tmp = split /\t/, \$line_tmp;
                    my \$accuracy_tmp = \$line_tmp[2];
                    if (\$accuracy_tmp > 95 || ("$PB_reads" eq "" && "$input_reads_DB_folder_PB" eq "" && \$accuracy_tmp > 70))
					{
                        close SEED_TEST;
						print OUTPUT_FH "REJECT";
						unlink \$output_file25;
						unlink \$file_tmp;
                        goto WG_SEED_ACCEPT3;
                    }  
                }
                \$count_lines_tmp++;
            }
            close SEED_TEST;
        }
        elsif (\$count_tmp < 100000)
		{
            \$count_tmp++;
            goto WG_SEED_ACCEPT;
        }
    }
WG_SEED_ACCEPT2:
    substr \$seed_input_tmpi, 0, 200, "";
    substr \$seed_input_tmpi, -200, 200, "";   
    unlink \$output_file25;
    unlink \$file_tmp;
    
    # Write values to output file  
    print OUTPUT_FH "\$file_name_3\\n";
    print OUTPUT_FH "\$seed_input_tmpi\\n";
    print OUTPUT_FH "\$keep_track_of_reads_number\\n";
}
else
{
  print OUTPUT_FH "REJECT";
}
WG_SEED_ACCEPT3:
close OUTPUT_SEQ_TMP;
close OUTPUT_FH;
END_SCRIPT

	close($fh_script);
}

my %ret_data_WG;
undef %ret_data_WG;
my %ret_data2_WG;
undef %ret_data2_WG;

NEXT_SEED:

my $found_next_WG = "";
my $found_next_WG_count = '0';

if ($assembly_length_max eq "WG")
{
	foreach my $file_name_tmp (keys %ret_data_WG)
	{
		if ($file_name_tmp ne "")
		{
			goto SKIP_SEED_SEARCH;
		}
	}
	$found_next_WG = "";
	my $output_folder_tmp = $input_reads_DB_folder_NP;
	if ($input_reads_DB_folder_NP eq "")
	{
		$output_folder_tmp = $output_path;
	}
	my $DB_path = $output_folder_tmp."tmp_sequences_NP";
	
	if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
	{
		$output_folder_tmp = $input_reads_DB_folder_PB;
		if ($input_reads_DB_folder_PB eq "")
		{
			$output_folder_tmp = $output_path;
		}
		$DB_path = $output_folder_tmp."tmp_sequences_PB";
	}
	
	opendir(DIR_DB_NP, $DB_path) or die "Could not open $DB_path\n";
	
	my $keep_track_of_reads_number_current = '0';
	
DIR_DB:	for my $filename (sort readdir(DIR_DB_NP))
	{	
		if ($filename ne "." && $filename ne "..")
		{
			if (-d $DB_path.$output_path_test.$filename)
			{
				my $DB_path2 = $output_folder_tmp."tmp_sequences_NP".$output_path_test.$filename;
				
				if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
				{
					$DB_path2 = $output_folder_tmp."tmp_sequences_PB".$output_path_test.$filename;
				}
	
				opendir(DIR_DB_NP2, $DB_path2) or die "Could not open $DB_path2\n";

				for my $filename2 (sort readdir(DIR_DB_NP2))
				{
					if ($filename2 ne "." && $filename2 ne "..")
					{
						if (-d $DB_path2.$output_path_test.$filename2)
						{
							my $DB_path3 = $output_folder_tmp."tmp_sequences_NP".$output_path_test.$filename.$output_path_test.$filename2;
				
							if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
							{
								$DB_path3 = $output_folder_tmp."tmp_sequences_PB".$output_path_test.$filename.$output_path_test.$filename2;
							}
			
							opendir(DIR_DB_NP3, $DB_path3) or die "Could not open $DB_path3\n";

							for my $filename3 (sort readdir(DIR_DB_NP3))
							{
								if ($filename3 ne "." && $filename3 ne ".." && $found_next_WG_count < $maxProcs_tmp)
								{
									my $check_rev = substr $filename3, -9, 3;
									if ($check_rev ne "rev")
									{
										$keep_track_of_reads_number_current++;
										if ($keep_track_of_reads_number_current > $keep_track_of_reads_number - $maxProcs_tmp)
										{
											$keep_track_of_reads_number++;
											substr $filename3, -6, 6, "";
											
											my @file_name = split /_/, $filename3;
											
											if (exists($reads_as_seeds{$file_name[3]}))
											{}
											elsif (-s $output_file20)
											{
												$reads_as_seeds{$file_name[3]} = undef;
												#my $sequence_tmp_file  = $DB_path3.$output_path_test.$filename3.".fasta";
												print OUTPUT19 $file_name[3]."\n";
												$found_next_WG_count++;
												
# Run the generated script with the sequence file, file name, and reads number passed as arguments
												my $sequence_tmp_file = $DB_path3.$output_path_test.$filename3.".fasta";
												my $file_name_3 = $file_name[3];
												my $command_SEED = "perl ".$generated_script." -a ".$sequence_tmp_file." -b ".$file_name_3." -c ".$keep_track_of_reads_number." &";
												#print $command_SEED."\n";
												syscmd($command_SEED);        
											}
											else
											{
												$reads_as_seeds{$file_name[3]} = undef;
												my $sequence_tmp_file  = $DB_path3.$output_path_test.$filename3.".fasta";
												open(OUTPUT_SEQ_TMP, $sequence_tmp_file) or die "\nCan't open file $sequence_tmp_file, $!\n";
												my $seed_input_tmpi = <OUTPUT_SEQ_TMP>;
												print OUTPUT19 $file_name[3]."\n";

												if (length($seed_input_tmpi) > 2500)
												{
													substr $seed_input_tmpi, 0, 500, "";
													substr $seed_input_tmpi, -500, 500, "";

													$ret_data_WG{$file_name[3]} = $seed_input_tmpi;
													$ret_data2_WG{$file_name[3]} = $keep_track_of_reads_number;
													$found_next_WG = "yes";
													close OUTPUT_SEQ_TMP;
													close DIR_DB_NP2;
													close DIR_DB_NP3;
													closedir DIR_DB_NP;
													goto SKIP_SEED_SEARCH;
												}
												close OUTPUT_SEQ_TMP;
												close DIR_DB_NP2;
												close DIR_DB_NP3;
												closedir DIR_DB_NP;
											}
										}
									}
								}
								elsif ($found_next_WG_count >= $maxProcs_tmp)
								{
									#print $found_next_WG_count." FOUND_ENOUGH\n";
									my $files_checked_tmp = '0';
									my $count_tmp = '0';
CHECK_SEED_FILES:									
									opendir(DIR_RESULTS_NP, $seed_directory) or die "Could not open $seed_directory\n";
									for my $filename2 (sort readdir(DIR_RESULTS_NP))
									{
										#print $filename2." FILE\n";
										if ($filename2 ne "." && $filename2 ne ".." && -s $seed_directory.$output_path_test.$filename2)
										{
											$files_checked_tmp++;
											#print $files_checked_tmp." ".$filename2." FILES_CHECKED\n";
											open(OUTPUT_SEED_MATCH, $seed_directory.$output_path_test.$filename2) or die "\nCan't open seed match file $filename2, $!\n";
											my $count_lines_tmp = '1';
											my $file_name_tmp = "";
											my $seed_input_tmpi_tmp = "";
											my $keep_track_of_reads_number_tmp = "";
											while (my $line_tmp = <OUTPUT_SEED_MATCH>)
											{
												chomp($line_tmp);
												if ($count_lines_tmp eq '1' && $line_tmp eq "REJECT")
												{
													close OUTPUT_SEED_MATCH;
													last;
												}
												elsif ($count_lines_tmp eq '1' && $line_tmp ne "")
												{
													$file_name_tmp = $line_tmp;
													$found_next_WG = "yes";
												}
												elsif ($count_lines_tmp eq '2' && $line_tmp ne "")
												{
													$seed_input_tmpi_tmp = $line_tmp;
												}
												elsif ($count_lines_tmp eq '3' && $line_tmp ne "")
												{
													$keep_track_of_reads_number_tmp = $line_tmp;
													close OUTPUT_SEED_MATCH;
													$ret_data_WG{$file_name_tmp} = $seed_input_tmpi_tmp;
													$ret_data2_WG{$file_name_tmp} = $keep_track_of_reads_number_tmp;
													last;
												}
												$count_lines_tmp++;
											}
											unlink $seed_directory.$output_path_test.$filename2;
										}
									}
									close DIR_RESULTS_NP;
									if ($files_checked_tmp < $found_next_WG_count && $count_tmp < 1000)
									{
										$count_tmp++;
										sleep(0.1);
										goto CHECK_SEED_FILES;
									}
									$found_next_WG_count = '0';
								}
								if ($found_next_WG eq "yes")
								{
									close DIR_DB_NP3;
									close DIR_DB_NP2;
									closedir DIR_DB_NP;
									goto SKIP_SEED_SEARCH;
								}
							}
							close DIR_DB_NP3;
						}
					}
				}
				close DIR_DB_NP2;
			}
		}
	}
	closedir DIR_DB_NP;
	
SKIP_SEED_SEARCH:
	my $found_tmp = "";
	foreach my $file_name_tmp (sort keys %ret_data_WG)
	{
		if ($file_name_tmp ne "" && $found_tmp eq "")
		{
			$seeds_list{$file_name_tmp} = $ret_data_WG{$file_name_tmp};
			$seeds_list_sorted{$ret_data2_WG{$file_name_tmp}} = $file_name_tmp;
			$y{$file_name_tmp} = '1';
			$seed_input = $ret_data_WG{$file_name_tmp};
			
			#print $file_name_tmp." NEW_SEED\n";
			#print OUTPUT4 $file_name_tmp." NEW_SEED\n";
			
			delete $ret_data_WG{$file_name_tmp};
			delete $ret_data2_WG{$file_name_tmp};
			$found_tmp = "yes";
		}
		else
		{
			delete $reads_as_seeds{$file_name_tmp};
			delete $ret_data_WG{$file_name_tmp};
			delete $ret_data2_WG{$file_name_tmp};
		}
	}

	if ($seed_input eq "")
	{
		$last_seed = "yes";
		goto END1;
	}
}

print "...OK\n\n";
print OUTPUT4 "...OK\n\n";

FIRST_SEED:

my $low_coverage_check = '0';

foreach my $seed_input_tmp2 (sort {$a <=> $b} keys %seeds_list_sorted)
{
    my $seed_input_tmp = $seeds_list{$seeds_list_sorted{$seed_input_tmp2}};
    my $id_of_seed = $seeds_list_sorted{$seed_input_tmp2};
	if ($first_back_assembly{$seed_input_tmp2} ne "yes")
	{
		$seed_input_tmp =~ tr/actgn/ACTGN/;
		$original_seed_length{$id_of_seed} = length($seed_input_tmp);
	}
    if ($next_seed_print eq "yes")
    {
        push @seed_list_sorted, $seeds_list_sorted{$seed_input_tmp2};
    }
  
    if ($next_seed_print eq "yes" && $seed_batch eq "yes")
    {
        print "\nSeed ".$seed_input_tmp2.": ".$seeds_list_sorted{$seed_input_tmp2}."\n";
        print OUTPUT4 "\nSeed ".$seed_input_tmp2.": ".$seeds_list_sorted{$seed_input_tmp2}."\n";
        $next_seed_print = "";
        #push @seed_list_sorted, $seeds_list_sorted{$seed_input_tmp2};
    }
	my $fh;
	$filehandle{$id_of_seed} = $fh;
	$output_file5  = $output_path."log_extended_".$project."_".$id_of_seed.".txt";
	
	unless (-e $output_file5)
	{	
		open($filehandle{$id_of_seed}, ">".$output_file5) or die "Can't open file $output_file5, $!\n";
	}
	else
	{
		open($filehandle{$id_of_seed}, ">>".$output_file5) or die "Can't open file $output_file5, $!\n";
	}

	my $fh4;
	$filehandle4{$id_of_seed} = $fh4;
	$output_file13 = $output_path."quality_scores_".$project."_".$id_of_seed.".txt";

	unless (-e $output_file13)
	{	
		open($filehandle4{$id_of_seed}, ">".$output_file13) or die "Can't open file $output_file13, $!\n";
	}
	else
	{
		open($filehandle4{$id_of_seed}, ">>".$output_file13) or die "Can't open file $output_file13, $!\n";
	}

	$seed{$id_of_seed} = $seed_input_tmp;
	$position{$id_of_seed} = length($seed{$id_of_seed});
	$position = length($seed{$id_of_seed});
	if ($find_haps_in_seed eq "yes")
	{
		$find_haps_in_seed{$id_of_seed} = "yes";
	}
    
    if ($find_haps_in_seed eq "")
    {        
        print "\nExtend the given seed directly: ".$id_of_seed."\n";
        print OUTPUT4 "\nExtend the given seed directly: ".$id_of_seed."\n";
        print {$filehandle{$id_of_seed}} "\nExtend the given seed directly: ".$id_of_seed."\n";

        #delete $seeds_list_sorted{$seed_input_tmp2};
        #delete $seeds_list{$seeds_list_sorted{$seed_input_tmp2}};
        $next_seed_print = "yes";
    }	
}

#my $output_file18  = $output_path."SNP_POS_".$project.".txt";
#open(OUTPUT18, ">".$output_file18) or die "Can't open file $output_file18, $!\n";

#----------------------------------------------------------------------------------------------------------------------------
#Prepare the haplotypes------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------------

my %exclude_reads_NP;
undef %exclude_reads_NP;
my %exclude_reads_PB;
undef %exclude_reads_PB;
my %exclude_reads_NP_back;
undef %exclude_reads_NP_back;
my %exclude_reads_PB_back;
undef %exclude_reads_PB_back;

if ($find_haps_in_seed eq "" && $ploidy > 1)
{
    my $w = '0';
    my $input_file_seed_tmp = $TMP_directory."sequence_seed_".$project."_tmp.fasta";
    my $output_file_seed_tmp = $TMP_directory."mafft_seed_".$project.".txt";
    
    open(OUTPUT_LONG1, ">" .$input_file_seed_tmp) or die "\nCan't open file $input_file_seed_tmp, $!\n";
    
    foreach my $seed_input_tmp2 (sort {$a <=> $b} keys %seeds_list_sorted)
    {                                               
        print OUTPUT_LONG1 ">".$seed_input_tmp2."\n";
        print OUTPUT_LONG1 $seeds_list{$seeds_list_sorted{$seed_input_tmp2}}."\n";
        $hap_compare_pos{$seeds_list_sorted{$seed_input_tmp2}} = length($seeds_list{$seeds_list_sorted{$seed_input_tmp2}});
    }
    close OUTPUT_LONG1;
    chomp($input_file_seed_tmp);
        
    #my $command = "blastn -query ".$ref_seed_file." -subject ".$output_file_seed_tmp." -out blast_seed_tmp.txt -qcov_hsp_perc 60 -outfmt 4 -gapextend 1 -gapopen 2 &";
    my $cmd_seed = sprintf("mafft --thread 4 --op 0.4 --ep 1.06 --quiet --clustalout %s > ".$output_file_seed_tmp, $input_file_seed_tmp);
    system($cmd_seed);
    
    
    open(INPUT_BLAST_VAR, $output_file_seed_tmp) or print "\n\nCan't open seed mafft file $output_file_seed_tmp, $!\n";                                 
    
#merge mafft lines-------------------------------------------------------------------------------             
    my $g = '0';
    my $query_line = "";
    my %subject_list_seed;
	undef %subject_list_seed;
    my $consensus_total_seed;
    
                    
INPUT_BLAST_VAR:while (my $line2 = <INPUT_BLAST_VAR>)
    {                                                     
        chomp($line2);
        if ($g > 2)
        {
            my @blast_result_tmp = split /\s+/, $line2;
            
            if (exists($seed{$seeds_list_sorted{$blast_result_tmp[0]}}))
            {
                my $subject_tmp = $subject_list_seed{$blast_result_tmp[0]};
                $subject_list_seed{$blast_result_tmp[0]} = $subject_tmp.$blast_result_tmp[1];
                $query_line = "yes";
            }  
            elsif ($query_line eq "yes")
            {
                my $consensus = substr $line2, 16, 60;
                $consensus_total_seed .= $consensus;
            }
        }
        $g++
    }
    close INPUT_BLAST_VAR;
#------------------------------------------------------------------------------------------------------
    
    chomp($consensus_total_seed);
    $consensus_total_seed =~ s/\s+$//;
    my @consensus_seed = split //, $consensus_total_seed;
    my $c = '0';                  
                    
PREPARE_HAP: foreach my $cons (@consensus_seed)
    {
        if ($cons eq "." || $cons eq " ")
        {
            foreach my $subject_tmp (keys %subject_list_seed)
            {
                my $seq_tmp = $subject_list_seed{$subject_tmp};
                my $nuc_match = substr $seq_tmp, $c, 1;
                $nuc_match =~ tr/actgn/ACTGN/;
                if ($nuc_match eq "N")
                {
                    $c++;
                    next PREPARE_HAP;
                }
            }
            foreach my $subject_tmp (keys %subject_list_seed)
            {
                my $seq_tmp = $subject_list_seed{$subject_tmp};
                my $nuc_match = substr $seq_tmp, $c, 1;
                $nuc_match =~ tr/actgn/ACTGN/;
                my $d = $c-$overlap;
                my $overlap_tmp = $overlap;
                if ($d < 0)
                {
                   $overlap_tmp += $d;
                   $d = '0';                         
                }
                my $read_end_tmpi = substr $seq_tmp, $d, $overlap_tmp;
                $read_end_tmpi =~ tr/-//d;
                $read_end_tmpi =~ tr/actgn/ACTGN/;
                my $gaps_correct_seq = substr $subject_list_seed{$subject_tmp}, 0, $c;
                my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                my $pos = $c-$gaps_correct;
                if (exists($split_positions{$subject_tmp}{$pos}))
                {}
                else
                {
                    $split_positions{$seeds_list_sorted{$subject_tmp}}{$pos} = $read_end_tmpi.",".$nuc_match;
                    #print OUTPUT18 $seeds_list_sorted{$subject_tmp}."\t".$pos."\t".$read_end_tmpi.",".$nuc_match."\n";
                }      
            }
        }
        $c++;
    }      
}

foreach my $seed_id_tmp (keys %seed)
{
    my $fh3;
    $filehandle3{$seed_id_tmp} = $fh3;
    my $output_file6  = $output_path."contigs_tmp_".$seed_id_tmp."_".$project.".fasta";
    open($filehandle3{$seed_id_tmp}, ">".$output_file6) or die "Can't open file $output_file6, $!\n";
}

#----------------------------------------------------------------------------------------------------------------------------------------------------
#Start assembly--------------------------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------------------------------------

close INPUT3;

my $sc = '0';
my $best_extension = "";
my $last_iteration_check = '0';

foreach (keys %seed)
{
    $sc++;    
}
if ($sc eq '1')
{
    print "\n\nStart Assembly...\n\n";
    print OUTPUT4 "\n\nStart Assembly...\n\n";
}
my $e = "0";
while ($y < $iterations)
{
    $e++;
SEED:
    my $shortest_seed = "no";
    my $seed_id = "";
    foreach my $seed_id_tmp (keys %seed)
    {    
	    if (((length($seed{$seed_id_tmp}) - $hap_compare_pos{$seed_id_tmp} < $shortest_seed) || $shortest_seed eq "no") && $skip_hap ne $seed_id_tmp)
        {
            $seed_id = $seed_id_tmp;
            $shortest_seed = length($seed{$seed_id_tmp}) - $hap_compare_pos{$seed_id_tmp};
        }
    }
    
    if ($e eq "20")
    {
        foreach my $seed_id (keys %seed)
        {  
            my $output_file6  = $output_path."contigs_tmp_".$seed_id."_".$project.".fasta";
            open($filehandle3{$seed_id}, ">".$output_file6) or die "Can't open file $output_file6, $!\n";
            print {$filehandle3{$seed_id}} ">".$seed_id."\n";
            my $m = '0';
            while (length($seed{$seed_id}) > $m)
            {
                my $value_ref2b = substr $seed{$seed_id}, $m, 150;
                $m += 150;
                print {$filehandle3{$seed_id}} $value_ref2b."\n";
            }
            
        }
        $e = '0';
    }
FULL_RESET: 
    if ($seed_id eq "")
    {
        goto END1;
    }
	if (exists($filehandle{$seed_id}))
    {
        $seed_id2 = $seed_id;
    }
    else
    {
        print $seed_id." SEED_NO_MATCH\n"; 
        $seed_id2 = $seed_id;      
        delete $seed{$seed_id};
        goto SEED;
    }
   
    if (exists($filehandle{$seed_id2}))
    {
    }
    else
    {
        print $seed_id2." SEED_ERROR2\n";   
        delete $seed{$seed_id};
        goto SEED;
    }
    
    $best_extension = "";
	$y = $y{$seed_id};
    
    print {$filehandle{$seed_id2}} "\n".$y."\n\n";   
        
    if (exists($seed{$seed_id}))
    {     
        $read = $seed{$seed_id};
           
        print {$filehandle{$seed_id2}} "\n".$seed_id." SEED_exists\n\n";
        print {$filehandle{$seed_id2}} length($read)." READ_LENGTH\n";
        $id = $seed_id;
        
        if (exists($find_haps_in_seed{$id}))
        {
            $find_haps_in_seed = $find_haps_in_seed{$id};
        }
        else
        {
            $find_haps_in_seed = "";
        }
		$position = $position{$id};
		if ($position ne length($read))
		{
			print {$filehandle{$seed_id2}} $position." POS_ERROR\n";
		}
		
        if ($y eq '1' && $find_haps_in_seed eq "yes")
        {
            $position{$id} = '0';
            $position = '0';
            $position_back = '0';
            $position_back{$id} = '0';
        }
        
		$first_back_assembly = $first_back_assembly{$id};
        
        my $time_START0 = time;

#---------------------------------------------------------------------------------------------------------------------------------------------------------		
#Merge contigs--------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------
		if ($assembly_refine ne "")
		{
			if (length($read) > $original_seed_length{$id} + 16000 && ($last_merge_check_pos eq "" || length($read) > $last_merge_check_pos+8000))
			{
				my $LAST_5000 = substr $read, -5000, 5000;
				$last_merge_check_pos = length($read);
				my $query_file_DB = $output_path."query.fasta";
				open(INPUT_QUERY, ">" .$query_file_DB) or die "\nCan't open file $query_file_DB, $!\n";
				INPUT_QUERY->autoflush(1);
				print INPUT_QUERY $LAST_5000;        
				close INPUT_QUERY;
				
				my $query_accuracy = '98.5';
				my $query_coverage = '98.5';
				
				my $N_count = $LAST_5000 =~ tr/N/N/;
				$query_coverage -= (($N_count/5000)/100);
				$query_accuracy -= (($N_count/5000)/100);
				
				my $file_tmp = $output_path."blast_tmp_DB_".$id."_last5000_".$y.".txt";
				my $command_DB = "blastn -query ".$query_file_DB." -db ".$DB_direc_refine_tmp." -out ".$file_tmp." -outfmt 7 -perc_identity ".$query_accuracy." -qcov_hsp_perc ".$query_coverage." -num_threads 2";
				system($command_DB);
								
				sleep(0.8);
			
				my $file_complete = "";
				my %merge_matches;
				undef %merge_matches;
			
DB_MERGE: 
				open(BLAST_MERGE_DB, $file_tmp) or die "\nCan't open file $file_tmp, $!\n";
				my $count_lines_tmp = '1';
			   
BLAST_MERGE1:   while (my $line_tmp = <BLAST_MERGE_DB>)
				{
					chomp($line_tmp);
					if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
					{
						close BLAST_MERGE_DB;
						last;
					}
					elsif ($count_lines_tmp eq '5' && $line_tmp eq "# BLAST processed 1 queries")
					{
						print "ERROR1\n";
					}
					elsif ($count_lines_tmp > 5 && $line_tmp eq "# BLAST processed 1 queries" && $file_complete eq "")
					{
						$file_complete = "yes";
						close BLAST_MERGE_DB;
						goto DB_MERGE;
					}
					elsif ($count_lines_tmp > 5 && $file_complete eq "yes")
					{
						my @line_tmp = split /\t/, $line_tmp;
						my $id_blast_tmp = $line_tmp[1];
						my $accuracy_tmp = $line_tmp[2];
						my $alignment_length = $line_tmp[3];
						my $read_pos_start_tmp = $line_tmp[8];
						my $read_pos_end_tmp = $line_tmp[9];
						
						if (exists($contigs_ass{$id_blast_tmp}))
						{}
						elsif (exists($merged_ass{$id_blast_tmp}))
						{
							while (exists($merged_ass{$id_blast_tmp}))
							{
								my @line_tmp5 = split /_m_/, $merged_ass{$id_blast_tmp};
								foreach my $id_tmp8 (@line_tmp5)
								{
									if ($id_tmp8 eq $id)
									{
										next BLAST_MERGE1;
									}
								}
								my $id_tmp_tmp = $id_blast_tmp;
								$id_blast_tmp = $merged_ass{$id_tmp_tmp};
							}
						}
						else
						{
							next BLAST_MERGE1;
						}
						if ($accuracy_tmp > $query_accuracy && $id_blast_tmp ne $id)
						{
							my $reverse_tmp = "no";
							my $length_tmp = $read_pos_end_tmp;
							if ($read_pos_end_tmp < $read_pos_start_tmp) 
							{
								$reverse_tmp = "yes";
								$length_tmp = $lengths_ass{$id_blast_tmp}-$read_pos_end_tmp;
							}
							print {$filehandle{$seed_id2}} $query_accuracy." ACCURACY ".$length_tmp." LENGTH\n";
							if ($length_tmp > length($read) || $length_tmp > ($position-$original_seed_length{$id}+250000))
							{
								next BLAST_MERGE1;
							}

							#print $length_tmp." ".$lengths{$id_tmp}." ".$read_pos_end_tmp2."\n";
							my $merged_check = "";
							if (exists($merged_ass2{$id_blast_tmp}))
							{
								$merged_check = "yes";
							}

							if ($lengths_ass{$id_blast_tmp} > 0 && $length_tmp > 5000)
							{
								my $query_coverage2 = (($length_tmp/$lengths_ass{$id_blast_tmp})*0.98)*100;
								my $query_seq_tmp = "";
								my $query_seq_full = $contigs_ass{$id_blast_tmp};
								my $query_seq_full2 = $contigs_ass{$id_blast_tmp};
								if ($reverse_tmp eq "no")
								{
									$query_seq_tmp = substr $contigs_ass{$id_blast_tmp}, 0, $read_pos_end_tmp;
								}
								elsif ($reverse_tmp eq "yes")
								{
									my $query_seq_tmp2 = substr $contigs_ass{$id_blast_tmp}, $read_pos_end_tmp;
									$query_seq_full = reverse($query_seq_full2);
									$query_seq_full =~ tr/ACTGactg/TGACTGAC/;
									$query_seq_tmp = reverse($query_seq_tmp2);
									$query_seq_tmp =~ tr/ACTGactg/TGACTGAC/;
								}
								my $subject_seq_tmp = substr $read, -($length_tmp*1.15);
								my $query_file3 = $output_path."query3.fasta";
								my $subject_file3 = $output_path."subject2.fasta";
								my $N_count = $subject_seq_tmp =~ tr/N/N/;
								my $N_adjust = $N_count/length($subject_seq_tmp);
								my $accuracy_tmp2 = 99.5-$N_adjust;
								
								open(INPUT_QUERY3, ">" .$query_file3) or die "\nCan't open file $query_file3, $!\n";
								INPUT_QUERY3->autoflush(1);
								print INPUT_QUERY3 $query_seq_tmp;        
								close INPUT_QUERY3;
								open(INPUT_SUBJECT3, ">" .$subject_file3) or die "\nCan't open file $subject_file3, $!\n";
								INPUT_SUBJECT3->autoflush(1);
								print INPUT_SUBJECT3 $subject_seq_tmp;        
								close INPUT_SUBJECT3;
								
								my $file_tmp2 = $output_path."blast_tmp3_".$id."_".$id_blast_tmp."_".$length_tmp."_first2_".$y.".txt";
								my $command_DB = "blastn -query ".$query_file3." -subject ".$subject_file3." -out ".$file_tmp2." -outfmt 7 -perc_identity ".$accuracy_tmp2." -qcov_hsp_perc ".$query_coverage2;
								system($command_DB);
								sleep(0.4);
								
								my $file_complete2 = "";
DB_MERGE2:          
								open(BLAST_MERGE_DB2, $file_tmp2) or die "\nCan't open file $file_tmp2, $!\n";
								my $count_lines_tmp2 = '1';
							   
								while (my $line_tmp2 = <BLAST_MERGE_DB2>)
								{
									chomp($line_tmp2);
									
									if ($count_lines_tmp2 eq '4' && $line_tmp2 eq "# 0 hits found")
									{
										close BLAST_MERGE_DB2;
										last;
									}
									elsif ($count_lines_tmp2 eq '5' && $line_tmp2 eq "# BLAST processed 1 queries")
									{
										print {$filehandle{$seed_id2}} "ERROR2\n";
									}
									elsif ($count_lines_tmp2 > 5 && $line_tmp2 eq "# BLAST processed 1 queries" && $file_complete2 eq "")
									{
										$file_complete2 = "yes";
										close BLAST_MERGE_DB2;
										goto DB_MERGE2;
									}
									elsif ($count_lines_tmp2 > 5 && $file_complete2 eq "yes")
									{
										my @line_tmp2 = split /\t/, $line_tmp2;
										my $id_tmp2 = $line_tmp2[1];
										my $accuracy_tmp2 = $line_tmp2[2];
										my $alignment_length2 = $line_tmp2[3];
										my $query_start_tmp2 = $line_tmp2[6];
										my $query_end_tmp2 = $line_tmp2[7];
										my $subject_start_tmp2 = $line_tmp2[8];
										my $subject_end_tmp2 = $line_tmp2[9];
			print {$filehandle{$seed_id2}} $line_tmp2."\n";
			print {$filehandle{$seed_id2}} length($subject_seq_tmp)." LENGTH_SUBJECT\n";
			print {$filehandle{$seed_id2}} length($query_seq_tmp)." LENGTH_QUERY\n";
										if ($query_start_tmp2 < 20 && $query_end_tmp2 > $lengths_ass{$id_blast_tmp}-100)
										{
											print {$filehandle{$seed_id2}} $id_blast_tmp." ".$lengths_ass{$id_blast_tmp}." DELETE1\n";
										}
										elsif ($subject_start_tmp2 < 20 && $subject_end_tmp2 > $lengths_ass{$id}-100)
										{
											print {$filehandle{$seed_id2}} $id." ".$lengths_ass{$id}." DELETE2\n";
										}
										if ($subject_start_tmp2 < 100 && $query_end_tmp2 > length($query_seq_tmp)-100)
										{
											print {$filehandle{$seed_id2}} $id." ".$lengths_ass{$id}." MERGE_ASS1\n";
											print {$filehandle{$seed_id2}} $id_blast_tmp." ".$lengths_ass{$id_blast_tmp}." LENGTH1\n";
											#my $subject_seq = substr $contigs{$contig_id}, $subject_end_tmp2;
											#my $query_seq = substr $query_seq_tmp, 0, $query_end_tmp2;
											#my $merged_contig = $query_seq.$subject_seq;
											#my $id_new = $id_tmp."_m_".$contig_id;
											#$contigs{$id_new} = $merged_contig;
											#$lengths{$id_new} = length($merged_contig);
											#$merged{$id_tmp} = $id_new;
											#$merged{$contig_id} = $id_new;
											#$merged2{$id_new} = undef;
											#delete $lengths{$id_tmp};
											#delete $contigs{$id_tmp};
											#delete $lengths{$contig_id};
											#delete $contigs{$contig_id};
											#delete $contigs{$contig_id};
											#goto NEXT_CONTIG0;
										}
										if ($query_start_tmp2 < 100 && $subject_end_tmp2 > length($subject_seq_tmp)-100)
										{
											print {$filehandle{$seed_id2}} $id." ".$lengths_ass{$id}." MERGE_ASS2\n";
											print {$filehandle{$seed_id2}} $id_blast_tmp." ".$lengths_ass{$id_blast_tmp}." LENGTH2\n";

											$merge_matches{$id_blast_tmp}{$accuracy_tmp2} = $subject_end_tmp2."+".$length_tmp."+".$query_end_tmp2."+".$reverse_tmp."+".$read_pos_end_tmp;					
										}
										elsif ($subject_start_tmp2 eq "1")
										{
										   print {$filehandle{$seed_id2}} $id." ".$lengths_ass{$id}." LENGTH\n";
										   print {$filehandle{$seed_id2}} $id_blast_tmp." ".$lengths_ass{$id_blast_tmp}." LENGTH2\n";
										}
									}
									$count_lines_tmp2++;
								}
								close BLAST_MERGE_DB2;
							}
							else
							{
								print {$filehandle{$seed_id2}} $id_blast_tmp." ERROR\n";
								print {$filehandle{$seed_id2}} $lengths_ass{$id_blast_tmp}." LENGTH\n";
							}
						}
					}
					$count_lines_tmp++;
				}
				close BLAST_MERGE_DB;
				
				my %merge_matches_new;
				undef %merge_matches_new;

				my $highest = "";
				foreach my $id_blast_tmp2 (keys %merge_matches)
				{
					foreach my $acc_tmp (sort {$b <=> $a} keys %{$merge_matches{$id_blast_tmp2}})
					{
						if ($highest eq "")
						{
							$highest = $acc_tmp;
							$merge_matches_new{$id_blast_tmp2} = $merge_matches{$id_blast_tmp2}{$acc_tmp};
							next;
						}
						if ($highest > $acc_tmp+0.05)
						{}
						else
						{
							$merge_matches_new{$id_blast_tmp2} = $merge_matches{$id_blast_tmp2}{$acc_tmp}
						}
					}
				}
				my $count_matches2 = keys %merge_matches_new;
				if ($count_matches2 eq '1')
				{
					foreach my $id_blast_tmp2 (keys %merge_matches_new)
					{
						my @data_tmp = split /\+/, $merge_matches_new{$id_blast_tmp2};
						my $subject_end_tmp2 = $data_tmp[0];
						my $length_tmp = $data_tmp[1];
						my $query_end_tmp2 = $data_tmp[2];
						my $reverse_tmp = $data_tmp[3];
						my $read_pos_end_tmp = $data_tmp[4];
						
						my $subject_seq = substr $read, 0, $subject_end_tmp2+(length($read)-($length_tmp*1.05));
						my $query_seq = "";
						my $query_seq_tmp = "";
						my $query_seq_full = $contigs_ass{$id_blast_tmp2};
						my $query_seq_full2 = $contigs_ass{$id_blast_tmp2};
						if ($reverse_tmp eq "no")
						{
							$query_seq_tmp = substr $contigs_ass{$id_blast_tmp2}, 0, $read_pos_end_tmp;
						}
						elsif ($reverse_tmp eq "yes")
						{
							my $query_seq_tmp2 = substr $contigs_ass{$id_blast_tmp2}, $read_pos_end_tmp;
							$query_seq_full = reverse($query_seq_full2);
							$query_seq_full =~ tr/ACTGactg/TGACTGAC/;
							$query_seq_tmp = reverse($query_seq_tmp2);
							$query_seq_tmp =~ tr/ACTGactg/TGACTGAC/;
						}
								
						if ($reverse_tmp eq "yes")
						{
							$query_seq = substr $query_seq_full, $query_end_tmp2;
						}
						else
						{
							$query_seq = substr $query_seq_full, $query_end_tmp2;
						}
						my $merged_contig = $subject_seq.$query_seq;
						substr $merged_contig, -5000, 5000, "";
						$read = $merged_contig;
						$position = length($merged_contig);
						$seed{$id} = $read;
						$position{$id} = $position;
						$original_seed_length{$id} = $position;
						print OUTPUT4 "Merge contigs : ".$id." + ".$id_blast_tmp2."\n";
						print OUTPUT4 "Overlap length: ".$query_end_tmp2."\n";
						
						my $id_tmp8 = $id;
						if ($first_back_assembly ne "")
						{
							chop($id_tmp8);
						}
						delete $lengths_ass{$id_tmp8};
						delete $contigs_ass{$id_tmp8};
						$contigs_ass{$id_tmp8} = $merged_contig;
						$lengths_ass{$id_tmp8} = length($merged_contig);
						#$merged_ass{$id_blast_tmp} = $id_new;
						#$merged_ass{$id} = $id_new;
						#$merged_ass2{$id_new} = undef;
						delete $lengths_ass{$id_blast_tmp2};
						delete $contigs_ass{$id_blast_tmp2};		
					}
				}
			}
		}
        
#Check positions of excluded and confirmed reads--------------------------------------------

        if (($NP_reads ne "" || $input_reads_DB_folder_NP ne "") && $find_haps_in_seed eq "")
        {
			foreach my $confrim_id (keys %{$exclude_reads_NP{$id}})
			{
				if ($position >= $exclude_reads_NP{$id}{$confrim_id})
				{
					delete $exclude_reads_NP{$id}{$confrim_id};
				}
			}
			foreach my $confrim_id (keys %{$exclude_reads_NP_back{$id}})
			{
				if ($position >= $exclude_reads_NP_back{$id}{$confrim_id})
				{
					delete $exclude_reads_NP_back{$id}{$confrim_id};
				}
			}
        }
		
        if (($PB_reads ne " "|| $input_reads_DB_folder_PB ne "") && $find_haps_in_seed eq "")
        {
            foreach my $confrim_id (keys %{$exclude_reads_PB{$id}})
			{
				if ($position >= $exclude_reads_PB{$id}{$confrim_id})
				{
					delete $exclude_reads_PB{$id}{$confrim_id};
				}
			}
			foreach my $confrim_id (keys %{$exclude_reads_PB_back{$id}})
			{
				if ($position >= $exclude_reads_PB_back{$id}{$confrim_id})
				{
					delete $exclude_reads_PB_back{$id}{$confrim_id};
				}
			}
        }
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------       
#Check var between haps----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------         
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------       
        my $count_seeds = keys %seed;
        my $check_var_between_hap = '0';
        my $extra_seq = "no";
        my $var_length = '3000';
        my $mafft_extra_quality_haps = "";
		my $compare_haps_stop_final = "";
		if (exists($compare_haps_stop_final{$id}))
		{
			$compare_haps_stop_final = "yes";
		}
        
        if ($count_seeds > 1 && $ploidy > 1 && $compare_haps_stop_final eq "")
        {
            if ($PB_reads ne "" && $input_reads_DB_folder_PB ne "")
            {
                $var_length = '1000';
            }
            if ($compare_haps ne "")
            {
                my %var_length;
				undef %var_length;
                my $var_min = "";
                foreach my $id_tmp (keys %seed)
                {
                    my $var_length_tmp = length($seed{$id_tmp})-$hap_compare_pos{$id_tmp}-$hap_compare_mismatch_extend;
                    if ($var_length_tmp < $var_min || $var_min eq "")
                    {
                        $var_min = $var_length_tmp;
                    }
                }
                if ($var_min > 250)
                {
                    $var_length = $var_min;
                    print {$filehandle{$seed_id2}} $var_length." FORCED_HAP_COMPARE\n";
                }
                else
                {
                    $compare_haps = "";
                }
            }
            
            foreach my $id_tmp (keys %seed)
            {
                if (length($seed{$id_tmp}) > $hap_compare_pos{$id_tmp} + $var_length + $hap_compare_mismatch_extend)
                {
                    $check_var_between_hap++;
                    if (length($seed{$id_tmp})-($hap_compare_pos{$id_tmp} + $var_length + $hap_compare_mismatch_extend) < $extra_seq || $extra_seq eq "no")
                    {
                        $extra_seq = length($seed{$id_tmp})-($hap_compare_pos{$id_tmp} + $var_length + $hap_compare_mismatch_extend);
                    }
                }
            }
            if ($extra_seq < 0 || $extra_seq eq "no")
            {
                $extra_seq = 0;
            }
            
            if ($hap_compare_mismatch_extend > 5000)
            {
                $compare_haps = "";
                $check_var_between_hap = '0';
                $compare_haps_stop = "yes";
            }
#Find the lost haplotypes again-----------------------------------------------------------------------------------------------------------------

            if ($hap_compare_mismatch_extend > 5000 && (($position > $prev_position_hap_compare{$seed_id}+15000) || ($position > $prev_position_hap_compare{$seed_id}+5000 && ($PB_reads ne "" || $input_reads_DB_folder_PB ne ""))))
            {      
                print {$filehandle{$seed_id2}} $hap_compare_mismatch_extend." REALIGN HAPS\n";
				foreach my $id_tmp5 (keys %seed)
                {
                    my $last_1000 = substr $seed{$id_tmp5}, -1000;
					my $check_last_10000 = "";
					
                    my $ref_part = "";
                    foreach my $id_tmp2 (keys %seed)
                    {
                        if ($id_tmp2 ne $id_tmp5)
                        {
							$ref_part = substr $seed{$id_tmp2}, $hap_compare_pos{$id_tmp2};
                        }
                    }
CHECK_LAST_10000:                    
                    my $ref_file = $TMP_directory."hap_var_ref_tmp_".$project."_".$id_tmp5.".fasta";
        
                    open(OUTPUT_HAP_VAR_REF, ">" .$ref_file) or die "\nCan't open file $ref_file, $!\n";
                    print OUTPUT_HAP_VAR_REF ">ref\n";
                    print OUTPUT_HAP_VAR_REF $ref_part;        
                    close OUTPUT_HAP_VAR_REF;
                    
                    my $last_1000_file = $TMP_directory."hap_var_last_1000_tmp_".$project."_".$id_tmp5.".fasta";
        
                    open(OUTPUT_LAST1000, ">" .$last_1000_file) or die "\nCan't open file $last_1000_file, $!\n";
                    print OUTPUT_LAST1000 ">last1000\n";
                    print OUTPUT_LAST1000 $last_1000;        
                    close OUTPUT_LAST1000;
                
                    chomp($last_1000_file);
                    chomp($ref_file);
                    my $command = "blastn -query ".$last_1000_file." -subject ".$ref_file." -out ".$TMP_directory."blast_hap_var_tmp_".$id."_".$y."_".$id_tmp5.".txt -outfmt 7 -strand plus -qcov_hsp_perc 99 -word_size 60";
                    system($command);
                    $compare_haps = "";
                    $check_var_between_hap = '0';
                    $compare_haps_stop = "yes";
					my $N_count = $last_1000 =~ tr/N/N/;
					my $extra_tmp = ($N_count/length($last_1000))*100;
					
					my $input_BLAST_tmp = $TMP_directory."blast_hap_var_tmp_".$id."_".$y."_".$id_tmp5.".txt";
					
					if (-s $input_BLAST_tmp)
					{
						open(BLAST_VAR_COMP, $input_BLAST_tmp) or die "\nCan't open file $input_BLAST_tmp, $!\n";
						my $count_lines_tmp = '1';
						
						while (my $line_tmp = <BLAST_VAR_COMP>)
                        {
                            chomp($line_tmp);
							if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
                            {
                                last;
                            }
							elsif ($count_lines_tmp eq '5' && $line_tmp ne "# 1 hits found" && length($ref_part) < 35000)
                            {
                                last;
                            }
                            elsif ($count_lines_tmp > 5)
                            {
                                my @line_tmp = split /\t/, $line_tmp;
                                my $accuracy_tmp = $line_tmp[2];
								#my $alignment_length = $line_tmp[3];
                                my $ref_pos_start_tmp = $line_tmp[8];
                                my $ref_pos_end_tmp = $line_tmp[9];

                                if ($accuracy_tmp >= 99.2-$extra_tmp)
                                {						
									if ($check_last_10000 eq "")
									{
										$check_last_10000 = "yes";
										if (length($ref_part) < 35000)
										{
											$last_1000 = substr $seed{$id_tmp5}, -length($ref_part);
										}
										else
										{
											$last_1000 = substr $seed{$id_tmp5}, -35000;
										}
										print {$filehandle{$seed_id2}} $ref_pos_end_tmp." HAPS_REFOUND\n";
										unlink $input_BLAST_tmp;
										
										goto CHECK_LAST_10000;
									}
									else
									{
										print {$filehandle{$seed_id2}} $ref_pos_end_tmp." HAPS_REFOUND2\n";
										undef %prev_position_hap_compare;
										$hap_compare_mismatch_extend = '0';
										$compare_haps_stop = "";
										foreach my $id_tmp2 (keys %seed)
										{
											if ($id_tmp2 eq $id_tmp5)
											{
												$hap_compare_pos{$id_tmp2} = length($seed{$id_tmp2}) - 35000;
											}
											else
											{
												my $current_pos_tmp = $hap_compare_pos{$id_tmp2};
												$hap_compare_pos{$id_tmp2} = $current_pos_tmp+$ref_pos_end_tmp - 35000;
											}
										}	
									}
                                }  
                            }
                            $count_lines_tmp++;
                        }
                        close BLAST_VAR_COMP;
					}
					unlink $input_BLAST_tmp;
					unlink $ref_file;
					unlink $last_1000_file;
                }
				$prev_position_hap_compare{$seed_id} = $position
            }
            
            if (($check_var_between_hap > 1 || $compare_haps ne "") && $find_haps_in_seed eq "")
            {  
                my %haps;
				undef %haps;
                my $haps = "";
                my $l = '200';
                foreach my $id_tmp (keys %seed)
                {
                    if ($hap_compare_pos{$id_tmp} < 200)
                    {
                        $l = 0;
                    }
                    my $seq = substr $seed{$id_tmp}, $hap_compare_pos{$id_tmp}-$l, $var_length+300 + $hap_compare_mismatch_extend + $extra_seq;
                    my $h = '80';
                    my $last_80 = substr $seq, -$h, 80;
                    my $AT_rich_tmp = AT_rich_test ($last_80, '15');
					my $AT_rich_tmp2 = $last_80 =~ tr/AT/AT/;
                    
                    while (length($seq) > $h+50 && ($AT_rich_tmp eq "yes" || $AT_rich_tmp2 > 70 || $AT_rich_tmp2 < 20))
                    {
                        $h +=80;
                        $last_80 = substr $seq, -$h, 80;
                        $AT_rich_tmp = AT_rich_test ($last_80, '17');
						$AT_rich_tmp2 = $last_80 =~ tr/AT/AT/;
                    }
                    
                    if ($h > 80)
                    {
                        substr $seq, -$h-100, $h+100, "";
                        print {$filehandle{$seed_id2}} $h." HAPS_AT_REMOVE\n"; 
                    }

                    if (length($seq) < 400)
                    {
                        goto SKIP_HAP_COMPARE;
                    }
                    
                    $haps{$id_tmp} = $seq;
                    $haps .= ">".$id_tmp."\n";
                    $haps .= $seq."\n";
                }
                
                my $output_file1  = $TMP_directory."haps_".$project.".fasta";
                
                open(OUTPUT_LONG1, ">" .$output_file1) or die "\nCan't open file $output_file1, $!\n";
                print OUTPUT_LONG1 $haps;
                
                close OUTPUT_LONG1;
                
                chomp($output_file1);
                                
                #my $cmd = sprintf("blastn -query %s -subject %s -out blast_tmp3.txt -outfmt 4", $ref_file, $output_file1);
                #my $cmd = sprintf("blastn -query %s -subject %s -out blast_tmp3.txt -reward 1 -penalty -2 -gapopen 2 -gapextend 2 -outfmt 4", $ref_file, $output_file1);
                #my $cmd = sprintf("muscle -in %s -out blast_tmp3.txt -maxiters 1 -diags", $output_file1);
                my $cmd = "";
MAFFT_HAPS:                
                if ($mafft_extra_quality_haps eq "yes")
                {
                    $cmd = sprintf("mafft --thread 4 --op 0.1 --ep 0.1 --quiet --clustalout --maxiterate 100 --globalpair %s > ".$TMP_directory."hap_var_".$project."_".$y.".txt ", $output_file1);
                }
                else
                {
                    $cmd = sprintf("mafft --thread 4 --op 0.1 --ep 0.1 --quiet --clustalout %s > ".$TMP_directory."hap_var_".$project."_".$y.".txt ", $output_file1);
                }
                
                my $system_result = system($cmd);                         
                
                my $input_BLAST_var  = $TMP_directory."hap_var_".$project."_".$y.".txt";
                open(INPUT_BLAST_VAR, $input_BLAST_var) or print "\n\nCan't open blast haplotypes file $input_BLAST_var, $!\n";
                
#merge mafft lines-------------------------------------------------------------------------------             
                my $g = '0';
                my $query_line = "";
                my %subject_list;
				undef %subject_list;
                my $consensus_total = "";
                my %gaps_id;
				undef %gaps_id;
                my %length_id;
				undef %length_id;
                
INPUT_BLAST_VAR:while (my $line2 = <INPUT_BLAST_VAR>)
                {                                                     
                    chomp($line2);
                    if ($g > 2)
                    {
                        my @blast_result_tmp = split /\s+/, $line2;
                        
                        if (exists($seed{$blast_result_tmp[0]}))
                        {
                            my $subject_tmp = $subject_list{$blast_result_tmp[0]};
                            $subject_list{$blast_result_tmp[0]} = $subject_tmp.$blast_result_tmp[1];
                            $query_line = "yes";
                        }  
                        elsif ($query_line eq "yes")
                        {
                            my $consensus = substr $line2, 16, 60;
                            $consensus_total .= $consensus;
                        }
                    }
                    $g++
                }
                close INPUT_BLAST_VAR;
                foreach my $subject_id (keys %subject_list)
                {
                    my $gaps_tmp = $subject_list{$subject_id} =~ tr/-/-/;
                    $gaps_id{$subject_id} = $gaps_tmp;
                    $length_id{$subject_id} = length($subject_list{$subject_id});
                }
#------------------------------------------------------------------------------------------------------
                
                chomp($consensus_total);
                $consensus_total =~ s/\s+$//;
                my @consensus = split //, $consensus_total;
				unlink $input_BLAST_var;
                
                my $count_stars_total = $consensus_total =~ tr/*/*/;
                my $non_stars_total = length($consensus_total)-$count_stars_total;
				print {$filehandle{$seed_id2}} length($consensus_total)." CONS_LENGTH\n";
                print {$filehandle{$seed_id2}} $count_stars_total." STARS\n";
                my $mm_count = '60';
                if ($PB_reads eq "" && $input_reads_DB_folder_PB eq "")
                {
                    $mm_count += 0.05*length($consensus_total);
                }
                if ($non_stars_total > $mm_count && $mafft_extra_quality_haps eq "")
                {
                    $mafft_extra_quality_haps = "yes";
                    goto MAFFT_HAPS;
                }
                
                my $count_non_stars = '0';
                my $c = '0';
                my $skip_pos = '0';
                my $last_indel_pos = "";
                my $mismatch_detect = "";
                
                my $c2 = 100;
                my $last_100_cons = substr $consensus_total, -$c2, 100;
                my $count_stars_last100 = $last_100_cons =~ tr/*/*/;
                my $non_stars_last100 = length($last_100_cons)-$count_stars_last100;
                my $max_length_compare = 0;
 
                while ($non_stars_last100 > 15)
                { 
                    $c2 += 100;
                    $last_100_cons = substr $consensus_total, -$c2, 100;
                    $count_stars_last100 = $last_100_cons =~ tr/*/*/;
                    $non_stars_last100 = length($last_100_cons)-$count_stars_last100;
                    $max_length_compare += 100;     
                }
				
				my $c3 = 0;
                my $first_100_cons = substr $consensus_total, $c3, 100;
                my $count_stars_first100 = $first_100_cons =~ tr/*/*/;
                my $non_stars_first100 = length($first_100_cons)-$count_stars_first100;
                my $max_length_compare2 = 0;
 
                while ($non_stars_last100 > 15)
                { 
                    $c3 += 100;
                    $last_100_cons = substr $consensus_total, $c3, 100;
                    $count_stars_first100 = $first_100_cons =~ tr/*/*/;
                    $non_stars_first100 = length($first_100_cons)-$count_stars_first100;
                    $max_length_compare2 += 100;     
                }
				
                foreach my $length_id_tmp (keys %length_id)
                {
                    if ($length_id{$length_id_tmp}-$max_length_compare-$max_length_compare2 < 500)
                    {
                        if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
                        {
                            $hap_compare_mismatch_extend += '2000';
                        }
                        else
                        {
                            $hap_compare_mismatch_extend += '3000';
                        }
                        goto SKIP_HAP_COMPARE;
                    }
                }
                if ($max_length_compare > 0)
                {
                    $max_length_compare += 200;
                }
				if ($max_length_compare2 > 0)
                {
                    $max_length_compare2 += 200;
					$skip_pos = $max_length_compare2;
                }

CONSENSUS_HAP:  foreach my $cons (@consensus)
                {
					foreach my $gaps_id (keys %gaps_id)
                    {
                        if ($c > $length_id{$gaps_id}-$max_length_compare)
                        {       
							last CONSENSUS_HAP;
                        }
                    }
                    if ($skip_pos > 0)
                    {
                        $skip_pos--;
                        $c++;
                        next CONSENSUS_HAP;
                    }
                    
                    if ($cons ne "*")
                    {
                        $count_non_stars++;
                    }
                    
                    if ($count_non_stars > 10 && $cons ne "*" && $c > $last_indel_pos+50 && $compare_haps ne "yes2")
                    {
                        my $last_100 = substr $consensus_total, $c, 100;
                        my $count_star = $last_100 =~ tr/\*/\*/;
                        my $star_limit = '82';
                        if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
                        {
                            $star_limit = '90';
                        }
                        if ($count_star < $star_limit)
                        {
                            $mismatch_detect = "yes";
                            #goto END1;
                        }
                        else
                        {
                            $mismatch_detect = "";
                        }
                    }
#check SNR------------------------------                            
                    my $count_SNR = "";
                    foreach my $ext_line_tmp (sort {$a <=> $b} keys %subject_list)
                    {
                        my $next_10 = substr $subject_list{$ext_line_tmp}, $c+1, 10;
                        my $t_tmp = $next_10 =~ tr/t/t/;
                        my $a_tmp = $next_10 =~ tr/a/a/;
                        my $c_tmp = $next_10 =~ tr/c/c/;
                        my $g_tmp = $next_10 =~ tr/g/g/;
                        if ($t_tmp > 8 || $a_tmp > 8 || $c_tmp > 8 || $g_tmp > 8)
                        {
                            $count_SNR = "yes";
                            last;
                        }
                    }
#check SNR------------------------------  
                    my $indel_check0 = "";
                    foreach my $subject_tmp (keys %subject_list)
                    {
                        my $seq_tmp = $subject_list{$subject_tmp};
                        my $nuc_match = substr $seq_tmp, $c, 1;
                        if ($nuc_match eq "-")
                        {
                            $indel_check0 = "yes";
                        }
                    }
                    if ($cons eq " " && $indel_check0 eq "yes" && ($PB_reads ne "" || $input_reads_DB_folder_PB ne "") && $c > 4 && $count_SNR eq "")
                    {
                        my $c2 = $c;
                        while ($consensus[$c2] eq " ")
                        {
                            $c2++;
                        }
                        if ($c2-$c >= 30)
                        {
                            print {$filehandle{$seed_id2}} $c2-$c." C2-C\n";
                            foreach my $subject_tmp (sort keys %subject_list)
                            {
                                my $seq_tmp = $subject_list{$subject_tmp};
                                my $var_region = substr $seq_tmp, $c, $c2-$c;
                                my @var_region = split //, $var_region;
                                my $f = '0';
                                foreach my $var_nuc (@var_region)
                                {
                                    if ($var_nuc eq "-")
                                    {
                                        $f++;
                                    }
                                }
                                if ($f >= 10)
                                {     
                                    my $gaps_correct_seq = substr $subject_list{$subject_tmp}, 0, $c;
                                    my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                                    my $pos_tmp = $hap_compare_pos{$subject_tmp}-$l-$gaps_correct+$c;
                                    print OUTPUT12 $subject_tmp."\t".$pos_tmp."\tDEL\t".$f."\n";
                                    $skip_pos = $f;
                                    $c++;
                                    $last_indel_pos = $c+$skip_pos;
                                    next CONSENSUS_HAP;
                                }
                                elsif ($f > 0)
                                {
                                    print $f." TEST2\n";
                                    print $c2." C\n";
                                    goto END1;
                                }
                            }
                        }
#detect and store indels----------------------------------------------------------------------------------------
                        elsif ($c > 4)
                        {
                            my $f_highest = '0';
                            my %read_ends;
                            undef %read_ends;
                            my $shortest_read_end = "";
                            my $shortest_read_end_id = "";
                            foreach my $subject_tmp (sort keys %subject_list)
                            {
                                my $seq_tmp = $subject_list{$subject_tmp};
                                my $var_region = substr $seq_tmp, $c, $c2-$c;
                                my @var_region = split //, $var_region;
                                my $f = '0';
                                foreach my $var_nuc (@var_region)
                                {
                                    if ($var_nuc eq "-")
                                    {
                                        $f++;
                                    }
                                }
                                if ($f > $f_highest)
                                {
                                    $f_highest = $f;
                                }

                                my $read_end_tmpi = substr $seq_tmp, $c-3, $c2-$c+3+3;
                                $read_end_tmpi =~ tr/actgn/ACTGN/;
                                $read_end_tmpi =~ tr/-//d;
                                $read_ends{$subject_tmp} = $read_end_tmpi;
                                if (length($read_end_tmpi) < length($shortest_read_end) || $shortest_read_end eq "")
                                {
                                    $shortest_read_end = $read_end_tmpi;
                                    $shortest_read_end_id = $subject_tmp;
                                }
                            }
                            my $add_length_tmp = '0';
EXTEND_INDEL:
                            foreach my $subject_tmp (sort keys %read_ends)
                            {
                                if ($read_ends{$subject_tmp} ne $shortest_read_end)
                                {
                                    my $check_seq = substr $read_ends{$subject_tmp}, 0, length($shortest_read_end);
                                    if ($check_seq eq $shortest_read_end)
                                    {
                                        $add_length_tmp++;
                                        foreach my $subject_tmp (sort keys %subject_list)
                                        {
                                            my $read_end_tmpi = substr $subject_list{$subject_tmp}, $c-3, $c2-$c+3+3+$add_length_tmp;
                                            $read_end_tmpi =~ tr/actgn/ACTGN/;
                                            $read_end_tmpi =~ tr/-//d;
                                            $read_ends{$subject_tmp} = $read_end_tmpi;
                                            if ($subject_tmp eq $shortest_read_end_id)
                                            {
                                                $shortest_read_end = $read_end_tmpi;
                                            }
                                        }
                                        goto EXTEND_INDEL;
                                    }
                                    else
                                    {
                                        foreach my $subject_tmp (sort keys %subject_list)
                                        {
                                            my $read_end_tmpi = substr $subject_list{$subject_tmp}, $c-3, $c2-$c+3+3+$add_length_tmp+2;
                                            $read_end_tmpi =~ tr/actgn/ACTGN/;
                                            $read_end_tmpi =~ tr/-//d;
                                            $read_ends{$subject_tmp} = $read_end_tmpi;
                                            if ($subject_tmp eq $shortest_read_end_id)
                                            {
                                                $shortest_read_end = $read_end_tmpi;
                                            }
                                        }
                                    }
                                }
                            }
                            my $N_check = "";
                            foreach my $subject_tmp (sort keys %read_ends)
                            {
                                my $N_tmp = $read_ends{$subject_tmp} =~ tr/N/N/;
                                if ($N_tmp > 0)
                                {
                                    $N_check = "yes";
                                }
                            }
                            foreach my $subject_tmp (sort keys %read_ends)
                            {
                                my $gaps_correct_seq = substr $subject_list{$subject_tmp}, 0, $c;
                                my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                                my $pos_tmp = $hap_compare_pos{$subject_tmp}-$l-$gaps_correct+$c;
                                my $read_end_tmpi = $read_ends{$subject_tmp};
                                
                                if (exists($split_positions{$subject_tmp}{$pos_tmp}))
                                {}
                                elsif ($N_check eq "")
                                {
                                    $split_positions{$subject_tmp}{$pos_tmp} = $read_end_tmpi.","."INDEL";
                                    print {$filehandle{$seed_id2}} $subject_tmp."\t".$pos_tmp."\t".$read_end_tmpi.",INDEL\n";
                                    my $seq_check = substr $subject_list{$subject_tmp}, 0, $c;
                                    #print OUTPUT18 $seq_check." CHECK\n";
                                    #print OUTPUT18 $subject_tmp."\t".$pos_tmp."\t".$read_end_tmpi.","."INDEL\n";
                                }
                                else
                                {
                                    #print OUTPUT18 $subject_tmp."\t".$pos_tmp."\t".$read_end_tmpi.","."INDEL N!\n";
                                }
                            }
                            
                            $skip_pos = $f_highest;
                            $last_indel_pos = $c+$skip_pos;
                            $c++;
                            next CONSENSUS_HAP;
                        }
                    }
#Check SNPs-------------------------------------------------------------------------------------------------------------------------------------------
                    elsif (($cons eq "." || $cons eq " ") && $mismatch_detect eq "" && $c > 4 && (($consensus[$c-1] ne " " && $consensus[$c-2] ne " " && $consensus[$c-3] ne " " && $consensus[$c-4] ne " "
                        && $consensus[$c+1] ne " " && $consensus[$c+2] ne " ") || (($PB_reads ne "" || $input_reads_DB_folder_PB ne "") && $consensus[$c-1] ne " ")))
                    {
                        my %pos_haps;
						undef %pos_haps;

                        foreach my $subject_tmp (keys %subject_list)
                        {
                            my $seq_tmp = $subject_list{$subject_tmp};
                            my $nuc_match = substr $seq_tmp, $c, 1;
                            my $d = $c-$overlap;
                            my $overlap_tmp = $overlap;
                            if ($d < 0)
                            {
                               $overlap_tmp -= $d;
                               $d = '0';                         
                            }
                            my $read_end_tmpi = substr $seq_tmp, $d, $overlap_tmp;
                            my $check_del = $read_end_tmpi =~ tr/-/-/;

                            if ($nuc_match eq "n" || $nuc_match eq '-' || $check_del > '0')
                            {
                                #if ($check_del > '0' && $nuc_match ne "n")
                                #{
                                    #my $gaps_correct_seq = substr $subject_list{$subject_tmp}, 0, $c;
                                   # my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                                   # my $pos = $hap_compare_pos{$subject_tmp}-200-$gaps_correct+$c;
                                    #print OUTPUT18 $subject_tmp."\t".$pos."\t".$read_end_tmpi.",".$nuc_match."\n";
                                #}
                                goto SKIP_CONSENSUS_HAP;
                            }
                            my $gaps_correct_seq = substr $subject_list{$subject_tmp}, 0, $c;
                            my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                            my $pos = $hap_compare_pos{$subject_tmp}-$l-$gaps_correct+$c+1;
                            $pos_haps{$subject_tmp} = $pos;
                            my $one = $pos-1;
                            my $two = $pos+1;

                            if (exists($quality_scores{$subject_tmp}{$pos}) && $PB_reads eq "" && $input_reads_DB_folder_PB eq "")
                            {                          
                                my @q_score_gap_tmp = split / /, $quality_scores_gap{$subject_tmp}{$pos}; 
								if (exists($quality_scores_gap{$subject_tmp}{$pos}) && $q_score_gap_tmp[0] < 0.7 && $compare_haps ne "yes2")
                                {
                                    print {$filehandle{$seed_id2}} $pos."\t".$quality_scores_gap{$subject_tmp}{$pos}." 1\n";
                                    goto SKIP_CONSENSUS_HAP;
                                }
								my @q_score_gap1_tmp = split / /, $quality_scores_gap{$subject_tmp}{$one}; 
                                if (exists($quality_scores_gap{$subject_tmp}{$one}) && $q_score_gap1_tmp[0] < 0.7)
                                {
                                    print {$filehandle{$seed_id2}} $pos."\t".$quality_scores_gap{$subject_tmp}{$one}." 2\n";
                                    goto SKIP_CONSENSUS_HAP;
                                }
								my @q_score_gap2_tmp = split / /, $quality_scores_gap{$subject_tmp}{$two}; 
                                if (exists($quality_scores_gap{$subject_tmp}{$two}) && $q_score_gap2_tmp[0] < 0.7)
                                {
                                    print {$filehandle{$seed_id2}} $pos."\t".$quality_scores_gap{$subject_tmp}{$two}." 3\n";
                                    goto SKIP_CONSENSUS_HAP;
                                }
								my @q_score_tmp = split / /, $quality_scores{$subject_tmp}{$pos}; 
                                if ($q_score_tmp[0] > 0.75 || $compare_haps eq "yes2")
                                {}
                                else
                                {                            
                                    goto SKIP_CONSENSUS_HAP;
                                }
                            }
                            elsif ($PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $compare_haps ne "yes2")
                            {
                                print {$filehandle{$seed_id2}} $subject_tmp." ".$pos." 4\n";
                                goto SKIP_CONSENSUS_HAP;
                            }
							if ($PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $compare_haps ne "yes2")
							{
								my $t_tmp = $read_end_tmpi =~ tr/TtnN/TtnN/;
                                my $a_tmp = $read_end_tmpi =~ tr/AanN/AanN/;
                                my $c_tmp = $read_end_tmpi =~ tr/CcnN/CcnN/;
                                my $g_tmp = $read_end_tmpi =~ tr/GgnN/GgnN/;
                                if ($t_tmp >= length($read_end_tmpi)-1 || $a_tmp >= length($read_end_tmpi)-1 || $c_tmp >= length($read_end_tmpi)-1 || $g_tmp >= length($read_end_tmpi)-1)
                                {
                                    goto SKIP_CONSENSUS_HAP;
                                }
							}
                        }
                        foreach my $subject_tmp (keys %subject_list)
                        {
                            my $seq_tmp = $subject_list{$subject_tmp};
                            my $nuc_match = substr $seq_tmp, $c, 1;
                            $nuc_match =~ tr/actgn/ACTGN/;
                            my $d = $c-$overlap;
                            my $overlap_tmp = $overlap;
                            if ($d < 0)
                            {
                               $overlap_tmp -= $d;
                               $d = '0';                         
                            }
                            my $read_end_tmpi = substr $seq_tmp, $d, $overlap_tmp;
                            $read_end_tmpi =~ tr/-//d;
                            $read_end_tmpi =~ tr/actgn/ACTGN/;
                            my $pos = $pos_haps{$subject_tmp};
                            
                            print {$filehandle{$seed_id2}} $pos." QUAL_POS\n";
                            my $one = $pos-1;
                            my $two = $pos+1;
                            my $three = $pos-2;
                            my $four = $pos+2;
                            print {$filehandle{$seed_id2}} $quality_scores{$subject_tmp}{$three}." QUAL-2\n";
                            print {$filehandle{$seed_id2}} $quality_scores{$subject_tmp}{$one}." QUAL-1\n";
                            print {$filehandle{$seed_id2}} $quality_scores{$subject_tmp}{$pos}." QUAL0\n";
                            print {$filehandle{$seed_id2}} $quality_scores{$subject_tmp}{$two}." QUAL+1\n";
                            print {$filehandle{$seed_id2}} $quality_scores{$subject_tmp}{$four}." QUAL+2\n";
     
                            if (exists($split_positions{$subject_tmp}{$pos}))
                            {}
                            else
                            {
                                $split_positions{$subject_tmp}{$pos} = $read_end_tmpi.",".$nuc_match;
                                print {$filehandle{$seed_id2}} $subject_tmp."\t".$pos."\t".$read_end_tmpi.",".$nuc_match."\n";
                                my $seq_check = substr $subject_list{$subject_tmp}, 0, $c;
                                #print OUTPUT18 $seq_check." CHECK\n";
                                #print OUTPUT18 $subject_tmp."\t".$pos."\t".$read_end_tmpi.",".$nuc_match."\n";
                            }           
                        }
                    }
SKIP_CONSENSUS_HAP:
                    if ($cons eq " " && $PB_reads eq "ddg")
                    {
                        my $n = "";
                        my $no_n = "";
                        my $new_nuc = "";
                        foreach my $subject_tmp (keys %subject_list)
                        {
                            my $seq_tmp = $subject_list{$subject_tmp};
                            my $nuc_match = substr $seq_tmp, $c, 1;
                            
                            if ($nuc_match eq "n")
                            {
                                $n = $subject_tmp;
                            }
                            if ($nuc_match eq "a" || $nuc_match eq "c" || $nuc_match eq "t" ||$nuc_match eq "g")
                            {
                                $no_n = $subject_tmp;
                                $new_nuc = $nuc_match;
                            }
                        }
                        if ($n ne "" && $no_n ne "")
                        {
                            my $gaps_correct_seq = substr $subject_list{$n}, 0, $c;
                            my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                            my $pos = $hap_compare_pos{$n}-$l-$gaps_correct+$c;
                            my $seq_tmp = $seed{$n};
                            $new_nuc =~ tr/actg/ACTG/;         
                            substr $seq_tmp, $pos, 1, $new_nuc;
                            $seed{$n} = $seq_tmp;
                            if ($n eq $id)
                            {
                                $read = $seq_tmp;
                            }  
                        }
                    }
                    $c++;
                }

                $hap_compare_mismatch_extend = '0';
                foreach my $subject_list_tmp (keys %subject_list)
                {
                    my $pos_tmp = $hap_compare_pos{$subject_list_tmp};
                    my $gaps_correct_seq = substr $subject_list{$subject_list_tmp}, 0, $c;
                    my $gaps_correct = $gaps_correct_seq =~ tr/-/-/;
                    $hap_compare_pos{$subject_list_tmp} = $pos_tmp + $c - $gaps_correct;
                }  
            }
        }
        
#Check for repetitive region------------------------------------------------------  
			my $vl = '50000';
REP_TEST_NP0:		
		    my $end_repetitive = substr $read, -$vl;
            my $end_repetitiveb = substr $end_repetitive, -5000;
			
            $repetitive_detect2 = "";
            $repetitive_detect1 = "";
            my $u = '12';
REP_TEST_NP: while ($u < 250)
            { 
                my $repetitive_test2 = substr $end_repetitive, -$u, 12;
                my $repetitive_test2c = substr $end_repetitive, -$u-80, 92;
                my $SNR_checkA = $repetitive_test2 =~ tr/A/A/;
                my $SNR_checkC = $repetitive_test2 =~ tr/C/C/;
                my $SNR_checkT = $repetitive_test2 =~ tr/T/T/;
                my $SNR_checkG = $repetitive_test2 =~ tr/G/G/;
                my $SNR_checkN = $repetitive_test2 =~ tr/N/N/;
                if ($SNR_checkA > 8 || $SNR_checkC > 8 || $SNR_checkG > 8 || $SNR_checkT > 8 || $SNR_checkN > 0)
                {
                    $u += 50;
                    goto REP_TEST_NP;
                }
                else
                {
                    my $check_repetitive2 = $end_repetitiveb =~ s/$repetitive_test2/$repetitive_test2/g;
                    my $check_repetitive2c = $end_repetitive =~ s/$repetitive_test2c/$repetitive_test2c/g;
                    
                    if ($check_repetitive2 > 2)
                    {
                        $repetitive_detect1 = "yes";
                        print {$filehandle{$seed_id2}} $check_repetitive2." REP_DETECT1\n";
                    }

                    if ($check_repetitive2c > 1)
                    {
                        my @rep_split = split /$repetitive_test2c/, $end_repetitive;
                        if ($repetitive_detect2 eq "" || length($rep_split[0]) > $vl-$repetitive_detect2)
                        {
                            $repetitive_detect2 = $vl-length($rep_split[0]);
                        }
                        print {$filehandle{$seed_id2}} $repetitive_detect2." REP_DETECT3\n";
                    }

                    if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "")
                    {
                        $u += 50;
                    }
                    elsif ($repetitive_detect2 ne "" && $u < 1000)
                    {
                        if ($check_repetitive2c > 1 && length($end_repetitive) < 200000 && length($read) > 200000)
						{
							$vl = '200000';
							goto REP_TEST_NP0;
						}
						elsif ($check_repetitive2c > 10 && length($end_repetitive) > 190000 && $repetitive_detect2 > 125000)
						{
							print {$filehandle{$seed_id2}} $repetitive_detect2." END_STUCK_IN_REP\n";
							$unresolvable_NP = "yes";
							$unresolvable_PB = "yes";
							goto AFTER_EXT;
						}
						last REP_TEST_NP;
                    }
                    else
                    {
                        last REP_TEST_NP;
                    }
                }
            }        
    
SKIP_HAP_COMPARE:                 
          
#Check if all databeses are created--------------------------------------------------------------------------------------------------------------------------------------------------------------      
                    
            if ($y0 eq '1')
            {
CHECK_DBs_NP:              
                my $time_before_check = time;
                if ($input_reads_DB_folder_NP eq "")
                {
                    my $count_DB_checked = '0';
                    foreach my $pid_tmp (keys %ret_data2_NP)
                    {
                        if (-e $ret_data2_NP{$pid_tmp})
                        {                 
                            open(DB_CHECK_NP, $ret_data2_NP{$pid_tmp}) or die "\nCan't open file $ret_data2_NP{$pid_tmp}, $!\n";

                            while (my $line = <DB_CHECK_NP>)
                            {
                                my $check_end = substr $line, 0, 34;
                                if ($check_end eq "Adding sequences from FASTA; added")
                                {
                                    $count_DB_checked++;
                                }                
                            }
                            close DB_CHECK_NP;
                        }      
                    }
                    if (time > $time_before_check+3600)
                    {
                        print "ERROR: Can't find all the databese output files\n";
                        goto END1;
                    }
                    elsif ($count_DB_checked < keys %ret_data2_NP)
                    {
                        goto CHECK_DBs_NP;
                    }
                }
                
CHECK_DBs_PB:              
                my $time_before_check2 = time;
                if ($input_reads_DB_folder_PB eq "")
                {
                    my $count_DB_checked = '0';
                    foreach my $pid_tmp (keys %ret_data2_PB)
                    {
                        if (-e $ret_data2_PB{$pid_tmp})
                        {                 
                            open(DB_CHECK_PB, $ret_data2_PB{$pid_tmp}) or die "\nCan't open file $ret_data2_PB{$pid_tmp}, $!\n";

                            while (my $line = <DB_CHECK_PB>)
                            {
                                my $check_end = substr $line, 0, 34;
                                if ($check_end eq "Adding sequences from FASTA; added")
                                {
                                    $count_DB_checked++;
                                }                
                            }
                            close DB_CHECK_PB;
                        }      
                    }
                    if (time > $time_before_check+3600)
                    {
                        print "ERROR: Can't find all the databese output files\n";
                        goto END1;
                    }
                    elsif ($count_DB_checked < keys %ret_data2_PB)
                    {
                        goto CHECK_DBs_PB;
                    }
                }
                
                foreach my $del_file_tmp (keys %delete_input_files)
                {
                    unlink  $del_file_tmp;
                }
				
				foreach my $hash_tmp (@QUALITY_HASH)
				{
					unlink $hash_tmp;
				}
            }
			
			my $time_START = time;
            my $time0b = $time_START - $time_START0;
            print {$filehandle{$seed_id2}} $time0b." TIME0\n";
PB_READS:
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Check PB reads----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			if (($PB_reads ne "" || $input_reads_DB_folder_PB ne "") && length($read) > $min_seed_length_PB)
            { 
                my $first_length_back = '900';
                $reduce_last_600_PB = '900';
				my $flexible_seed = "";
				my $query_coverage = 90;
				my $query_accuracy = 96;
                
                if ($first_length_back > length($read))
                {
                    $first_length_back = length($read)-50;
					if ($y eq '1')
					{
						$first_length_back = length($read);
					}
                }
                if ($find_haps_in_seed eq "yes")
                {
                    $first_length_back = length($read);
					if ($assembly_length_max eq "WG" && $first_length_back > 2100 && $first_back_assembly eq "")
					{
						$read = substr $read, 100, 2000;
						$seed{$id} = $read;
						$first_length_back = 2000;
					}
                }
REDUCE_LAST_600_PB:
                if ($reduce_last_600_PB < 900)
                {
                    $first_length_back = $reduce_last_600_PB;
                    print {$filehandle{$seed_id2}} $first_length_back." REDUCE_LAST_600\n";
                }

                my $last_hap_pos = "";
				my $last_hap_pos_DUP = "";
                my %hash_PB_reads_tmp;
				undef %hash_PB_reads_tmp;
				my %hash_PB_reads_tmp_back;
				undef %hash_PB_reads_tmp_back;
SKIP_CONFIRMED_PB:

                my %id_matches;
				undef %id_matches;
                my %double_matches;
				undef %double_matches;
                my %reverse_list;
				undef %reverse_list;
				my $only_saved_reads = "";
				my $new_contig_check = "";
				
				if ($y eq "1")
				{
					foreach my $id_read (keys %{$split_contigs_reads2{$id}})
					{
						$id_matches{$id_read} = undef;
						if ($split_contigs_reads2{$id}{$id_read} eq "yes")
						{
							$reverse_list{$id_read} = "yes";
						}
						$new_contig_check = "yes";
					}
				}
				if (keys %PB_split_ids > 3)
				{
					foreach my $id_read_tmp (keys %PB_split_ids)
					{
						$id_matches{$id_read_tmp} = undef;
						if ($PB_split_ids{$id_read_tmp} eq "yes")
						{
							$reverse_list{$id_read_tmp} = "yes";
						}
					}
					$new_contig_check = "yes";
					undef %PB_split_ids;
				}

#Find matches in hash against last 600 bp--------------------------------------------------------------                           		
					
LONGER_LAST_600_PB:

				my $last_600 = substr $read, -$first_length_back;
				my $N_count_last_600 = $last_600 =~ tr/N/N/;
				my $extra_N_tmp = ($N_count_last_600/length($last_600))*100;
				my %first_pos_read;
				undef %first_pos_read;
                my $time_PB_find_matches = time;
				
				my %output_files_DB;
				undef %output_files_DB;
                my %output_files_DB2;
				undef %output_files_DB2;
				
				if ($new_contig_check eq "yes")
				{
					goto SKIP_TO_CONFIRMED_PB;
				}

				my $query_file_DB = $TMP_directory."query_PB_".$project.".fasta";
                open(INPUT_QUERY_PB, ">" .$query_file_DB) or die "\nCan't open file $query_file_DB, $!\n";
                #print INPUT_QUERY_NP ">ref\n";
                print INPUT_QUERY_PB $last_600;        
                close INPUT_QUERY_PB;
                
                foreach my $pid_tmp (keys %ret_data_PB)
                {
                    my $file_tmp = $TMP_directory."blast_tmp_DB_PB_".$id."_".$y."_".$pid_tmp.".txt";
                    my $command_DB = "blastn -query ".$query_file_DB." -db ".$ret_data_PB{$pid_tmp}." -out ".$file_tmp." -outfmt 7 -qcov_hsp_perc ".$query_coverage." -num_threads 2 &";
                    syscmd($command_DB);             
                    $output_files_DB{$file_tmp} = undef;
                    $output_files_DB2{$file_tmp} = undef;
                }
				
#Add saved reads--------------------------------------------------------------                           						

SKIP_TO_CONFIRMED_PB:

				my %extensions;
				undef %extensions;
                my %extensions2;
				undef %extensions2;
                my %extensions2b;
				undef %extensions2b;
                my %extensions_nomatch;
				undef %extensions_nomatch;
                my %extensions_unknown;
				undef %extensions_unknown;
                my %extensions_nomatch2;
				undef %extensions_nomatch2;
                my %extensions_nomatch2b;
				undef %extensions_nomatch2b;
                my $extensions_nomatch2b_count = '0';
                my $extensions_nomatch2b_count_saved = '0';
                my %extensions_unknown2;
				undef %extensions_unknown2;
                my %store_mismatches_PB;
				undef %store_mismatches_PB;
				my %store_mismatches_N_PB;
				undef %store_mismatches_N_PB;

                my $total_matches_extra = '0';
                my $position_prev = "";
                my %alignment_length_saved;
				undef %alignment_length_saved;
                my %score_match_saved;
				undef %score_match_saved;
                my %score_no_match_saved;
				undef %score_no_match_saved;
                my %score_match_DUP_saved;
				undef %score_match_DUP_saved;
                my %score_no_match_DUP_saved;
				undef %score_no_match_DUP_saved;
                my %accuracy_saved;
				undef %accuracy_saved;
                my %read_start_pos_rej;
				undef %read_start_pos_rej;
                my %read_start_pos_rej_saved;
				undef %read_start_pos_rej_saved;
                my %extensions_nomatch2b_saved;
				undef %extensions_nomatch2b_saved;
				my %extensions_scores_saved;
				undef %extensions_scores_saved;
                
                foreach my $seed_id_tmp0 (keys %save_alignment_data_PB)
                {
                    if ($seed_id_tmp0 eq $seed_id)
                    {
                        foreach my $id_tmp7 (keys %{$save_alignment_data_PB{$seed_id_tmp0}})
                        {
                            my @alignment_data = split /_/, $save_alignment_data_PB{$seed_id_tmp0}{$id_tmp7};

                            if ($alignment_data[0] eq "yes" || $alignment_data[11] eq "")
                            { 
                                $alignment_length_saved{$id_tmp7} = $alignment_data[4];
                                $first_pos_read{$id_tmp7} = $alignment_data[2];
                                $position_prev = $alignment_data[3];
                                $score_match_saved{$id_tmp7} = $alignment_data[5];
                                $score_no_match_saved{$id_tmp7} = $alignment_data[6];
                                $score_match_DUP_saved{$id_tmp7} = $alignment_data[7];
                                $score_no_match_DUP_saved{$id_tmp7} = $alignment_data[8];
                                $accuracy_saved{$id_tmp7} = $alignment_data[9];
                            }
					
                           if (($alignment_data[6] > $alignment_data[5]*0.2 || $alignment_data[8] > $alignment_data[7]*0.25 || exists($exclude_reads_PB{$id}{$id_tmp7})))
                            {
                                $extensions_nomatch2b_saved{$id_tmp7}{$alignment_data[6]}{$alignment_data[5]}{$alignment_data[4]}{$alignment_data[3]} = $alignment_data[10];
                                $extensions_nomatch2b_count_saved++;
								if ($alignment_data[1] eq "yes")
                                {
                                    $reverse_list{$id_tmp7} = undef;
                                }
                            }
							elsif ($alignment_data[0] ne "yes" && $alignment_data[11] ne "")
                            {
                                $read_start_pos_rej{$id_tmp7} = $alignment_data[11]+$position-$alignment_data[3];
                                $read_start_pos_rej_saved{$id_tmp7} = undef;
                                if ($alignment_data[1] eq "yes")
                                {
                                    $reverse_list{$id_tmp7} = undef;
                                }
                            }
                            else
                            {
								$id_matches{$id_tmp7} = undef;
                                $total_matches_extra++;
                                if ($alignment_data[1] eq "yes")
                                {
                                    $reverse_list{$id_tmp7} = undef;
                                }
								if ($alignment_data[12] ne "")
								{
									$hash_PB_reads_tmp{$id_tmp7} = $alignment_data[12];
								}
                            }				
                        }
                    }
                }                                          
                print {$filehandle{$seed_id2}} $total_matches_extra." LAST_1000_matches_EXTRA\n\n";
				
                
DB_RESULTS_PB:  foreach my $blast_db_results_tmp (keys %output_files_DB)
                {
                    if (-s $blast_db_results_tmp)
                    {
						my $file_complete = "";
DB_RESULTS_PB1:                       
						open(BLAST_RESULTS_DB_PB, $blast_db_results_tmp) or die "\nCan't open file $blast_db_results_tmp, $!\n";
                        my $count_lines_tmp = '1';
						
                        while (my $line_tmp = <BLAST_RESULTS_DB_PB>)
                        {
                            chomp($line_tmp);
							if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
                            {
                                delete $output_files_DB{$blast_db_results_tmp};
								close BLAST_RESULTS_DB_PB;
                                next DB_RESULTS_PB;
                            }
							elsif ($count_lines_tmp eq '5' && $line_tmp eq "# BLAST processed 1 queries")
                            {
                                delete $output_files_DB{$blast_db_results_tmp};
								close BLAST_RESULTS_DB_PB;
                                next DB_RESULTS_PB;
                            }
                            elsif ($count_lines_tmp > 5 && $line_tmp eq "# BLAST processed 1 queries" && $file_complete eq "")
                            {
								$file_complete = "yes";
								delete $output_files_DB{$blast_db_results_tmp};
								close BLAST_RESULTS_DB_PB;
								goto DB_RESULTS_PB1;
                            }
                            elsif ($count_lines_tmp > 5 && $file_complete eq "yes")
                            {
                                my @line_tmp = split /\t/, $line_tmp;
                                my $id_tmp = $line_tmp[1];
                                my $accuracy_tmp = $line_tmp[2];
								my $alignment_length = $line_tmp[3];
                                my $read_pos_start_tmp = $line_tmp[8];
                                my $read_pos_end_tmp = $line_tmp[9];

                                if ($alignment_length < 0.8*$first_length_back && $first_length_back < 800)
                                {
									next;
                                }
								if (exists($exclude_reads_PB{$id}{$id_tmp}))
                                {
								    next;
                                }
								if (exists($rejected_alignment_data_PB{$seed_id}{$id_tmp}))
                                {
									next;
                                }
                                if (exists($save_alignment_data_PB{$seed_id}{$id_tmp}))
                                {
									next;
                                }
                                if ($accuracy_tmp > $query_accuracy-$extra_N_tmp)
                                {
									if (exists($id_matches{$id_tmp}))
                                    {
                                        if ($read_pos_end_tmp < $read_pos_start_tmp) 
                                        {
                                            if (exists($reverse_list{$id_tmp}))
											{}
											else
											{
												$reverse_list{$id_tmp} = undef;
												$double_matches{$id_tmp} = undef;
												delete $first_pos_read{$id_tmp};
											}	
                                        }
										elsif (exists($reverse_list{$id_tmp}))
										{
											$double_matches{$id_tmp} = undef;
											delete $first_pos_read{$id_tmp};	
										}	
                                    }
                                    else
                                    {
                                        $id_matches{$id_tmp} = undef;
										
										if ($assembly_length_max eq "WG")
										{
											$reads_as_seeds{$id_tmp} = undef;
											print OUTPUT19 $id_tmp."\n";
										}
						
                                        if ($read_pos_end_tmp < $read_pos_start_tmp) 
                                        {
                                            $reverse_list{$id_tmp} = undef;
                                            $first_pos_read{$id_tmp} = $read_pos_start_tmp;
                                        }
                                        else
                                        {
                                            $first_pos_read{$id_tmp} = $read_pos_end_tmp;
                                        }
                                    }        
                                }
                            }
                            $count_lines_tmp++;
                        }
                        close BLAST_RESULTS_DB_PB;
                    }
                }
                if (keys %output_files_DB > 0)
                {
                    goto DB_RESULTS_PB;
                }
                my $time_kmers = time;
                my $time1 = $time_kmers - $time_START;
                print {$filehandle{$seed_id2}} $time1." TIME1\n";
				
				my $total_matches = keys %id_matches;
				print {$filehandle{$seed_id2}} "\n".$total_matches." LAST_1000_matches\n";
				
				if ($assembly_length_max eq "WG" && $y eq "1" && ($total_matches > $sequencing_depth_PB*1.6 || ($total_matches < 10 && $total_matches < $sequencing_depth_PB*0.7)) && ($first_back_assembly eq "" || length($read) < 5000))
				{
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
						delete $output_files_DB2{$blast_db_results_tmp};
					}
					unlink $output_file5;
					unlink $output_file13;
					foreach my $seed_id_tmp (keys %seed)
					{
						my $contig_tmp_file = $output_path."contigs_tmp_".$seed_id_tmp."_".$project.".fasta";
						unlink $contig_tmp_file;
					}
					print $total_matches." GOTO_NEXT_SEED1\n";
					$first_back_assembly = "yes";
					goto END1;
				}
				
				if ($total_matches < 5 && $y eq "1" && $flexible_seed eq "" && $new_contig_check eq "")
                {
					$query_coverage = '80';
					$query_accuracy = '80';
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_PB_reads_tmp;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
					$flexible_seed = "yes";
					print {$filehandle{$seed_id2}} $total_matches." FLEX_SEED\n";
                    goto REDUCE_LAST_600_PB;
                }
				
				if ($total_matches < 5 && $reduce_last_600_PB > 400 && $new_contig_check eq "")
                {
                    if ($reduce_last_600_PB < 700)
                    {
                        $reduce_last_600_PB = '400';
                    }
                    else
                    {
                        $reduce_last_600_PB = '600';
                    }
					$query_coverage = '80';
					$query_accuracy = '89';
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_PB_reads_tmp;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
                    goto REDUCE_LAST_600_PB;
                }

				if ($total_matches > 1000 && $first_length_back < 2000)
				{
					$query_accuracy = '98';
					$query_coverage = '95';
					$first_length_back += 800;

					if ($total_matches > 1000)
					{
						$first_length_back += 800;
						$query_accuracy = '99';
					}
					if ($total_matches > 2000)
					{
						$first_length_back += 3000;
					}
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_PB_reads_tmp;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
					goto LONGER_LAST_600_PB;
				}
				
				if ($repetitive_detect2 ne "" && $repetitive_detect2 > $first_length_back && $total_matches > 1000 && $total_matches_extra > 9 && $only_saved_reads eq "")
				{
					$only_saved_reads = "yes";
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_PB_reads_tmp;
					undef %first_pos_read;
					undef %output_files_DB;
					undef %output_files_DB2;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
					goto SKIP_TO_CONFIRMED_PB;
				}

#--------------------------------------------------------------------------------------------------------------------------------------------------               
#Sort matches by alignment length------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------------------------------------

                my $strict_accuracy = "";
LOWER_ACCURACY:
				my $count_matches_with_high_scores = '0';
				my $longest_read = '0';              
                my %check_prev_splits;
				undef %check_prev_splits;
                my %accuracy;
				undef %accuracy;
                my $count_limit1 = '0';         
               
                my %ref_part;
				undef %ref_part;
                my %var_matches;
				undef %var_matches;
                my %var_matches_DUP;
				undef %var_matches_DUP;
                my %alignment_length_save;
				undef %alignment_length_save;
                my %long_read_end_pos_save;
				undef %long_read_end_pos_save;
				my %rejected_reads_save;
				undef %rejected_reads_save;
                my %multi_match;
				undef %multi_match;
                my %multi_match_pos;
				undef %multi_match_pos;

                my %length_ext_all;
				undef %length_ext_all;

                my $count_limit2 = '0';
                my $count_attempts = '0';
                
                my $ref_end_rejection = '0';
                my $read_start_pos_rejection = '0';
                my $no_hit_rejection = '0';
                my $almost_no_hit_rejection = '0';
                my $ext_too_short = '0';
                my $match_too_short = '0';
                my $overlap_too_short = '0';
                my $accuracy_rejection = '0';
				my $accuracy_threshold = "0.".$query_accuracy;
                my $multi_match_rejection = '0';
                my $ref_end_rejection_threshold = '100';

                my %score_matches_save;
				undef %score_matches_save;
                my $add_rejected_reads = "";
				my $add_rejected_reads_pos = "";
                my $add_no_match_reads = "";
				my $add_no_match_reads_pos = "";
				my $add_no_match_reads_stop = "";
                my %save_reads_for_next;
				undef %save_reads_for_next;
				my %SNP_matches;
				undef %SNP_matches;
				my %SNP_no_matches;
				undef %SNP_no_matches;
ADD_REJ_POS_PB:				
				my %id_by_length;
				undef %id_by_length;
                my %printed_refs;
				undef %printed_refs;
                my %printed_refs2;
				undef %printed_refs2;
                my %printed_blast;
				undef %printed_blast;
                my %add_rej_reads_extra;
				undef %add_rej_reads_extra;
				my %input_files_blast;
				undef %input_files_blast;
				my $count_total_matches = '0';
				my %input_length_done;
				undef %input_length_done;
				my %input_BLAST_done;
				undef %input_BLAST_done;
				my %double_match_check;
				undef %double_match_check;
				my %double_match_reject;
				undef %double_match_reject;
               
				foreach my $id_tmp (keys %id_matches)
                {        
					my $length_tmp = "";
					if (exists($first_pos_read{$id_tmp}))
					{
						$length_tmp = $first_pos_read{$id_tmp};
						if (exists($alignment_length_saved{$id_tmp}))
						{
							$length_tmp = $alignment_length_saved{$id_tmp}+$position-$position_prev;
						}
						elsif (exists($reverse_list{$id_tmp}) && exists($hash_PB_reads_tmp{$id_tmp}))
						{
							$length_tmp = length($hash_PB_reads_tmp{$id_tmp})-$first_pos_read{$id_tmp};
						}
					}
					elsif (exists($hash_PB_reads_tmp{$id_tmp}))
					{
						$length_tmp = length($hash_PB_reads_tmp{$id_tmp});
					}
					else
					{
						$length_tmp = 1;
					}
										
					if (exists($id_by_length{$length_tmp}))
					{
						while (exists($id_by_length{$length_tmp}))
						{
							$length_tmp += 1;
						}
						$id_by_length{$length_tmp} = $id_tmp;
					}
					else
					{
						$id_by_length{$length_tmp} = $id_tmp;
					}
					$count_total_matches++;
                }
				
#BLAST--------------------------------------------------------------------------------------------------------------------------
			
                foreach my $length_tmp (sort {$b <=> $a} keys %id_by_length)
                {                
                    if (exists($input_length_done{$length_tmp}))
					{
						next;
					}
					
					my $id_tmp2 = $id_by_length{$length_tmp};
					my $length_tmp2 = $length_tmp;
					
					if (exists($hash_PB_reads_tmp{$id_tmp2}))
					{}
					else
					{
						my @split_tmp = split /a/, $id_tmp2;
						my $output_file_PB1  = $tmp_sequences_directory_PB.$output_path_test.$split_tmp[0]."a".$output_path_test.$split_tmp[2].$output_path_test."sequence_tmp_PB_".$id_tmp2.".fasta";
						open(OUTPUT_LONG_PB4, $output_file_PB1) or die "\nCan't open file $output_file_PB1, $!\n";
						my $firstLine = <OUTPUT_LONG_PB4>;
						close OUTPUT_LONG_PB4;
						$hash_PB_reads_tmp{$id_tmp2} = $firstLine;
						$length_tmp2 = length($firstLine);
					}
					
					
                    my $double_match_tmp = "";                   
DOUBLE_MATCH_PB1:                   
                    my $reverse_check = "";
                    my @split_tmp = split /a/, $id_tmp2;
                    my $output_file1  = $tmp_sequences_directory_PB.$output_path_test.$split_tmp[0]."a".$output_path_test.$split_tmp[2].$output_path_test."sequence_tmp_PB_".$id_tmp2.".fasta";
                    
                    if (exists($reverse_list{$id_tmp2}) && $double_match_tmp eq "")
                    {
                        $output_file1  = $tmp_sequences_directory_PB.$output_path_test.$split_tmp[0]."a".$output_path_test.$split_tmp[2].$output_path_test."sequence_tmp_PB_".$id_tmp2."_rev.fasta";
                        $reverse_check = "_rev";
                    }

                    if (exists($printed_reads_PB{$id_tmp2.$reverse_check}))
                    {
                    }
                    elsif (exists($reverse_list{$id_tmp2}) && $double_match_tmp eq "")
                    {                      
                        my $long_read_tmp = reverse($hash_PB_reads_tmp{$id_tmp2});
                        $long_read_tmp =~ tr/ACTG/TGAC/;
                        open(OUTPUT_LONG1, ">" .$output_file1) or die "\nCan't open file $output_file1, $!\n";
						OUTPUT_LONG1->autoflush(1);
                        #print OUTPUT_LONG1 ">".$id_tmp2."\n";
                        print OUTPUT_LONG1 $long_read_tmp;
                        close OUTPUT_LONG1;
                        $printed_reads_NP{$id_tmp2.$reverse_check} = undef;
                    }                               
                    
                    my $ref_part = "";
                    my $ref_file = "";                  
                    my $length_tmp_final = $length_tmp2+50;
                    if ($length_tmp_final > length($read))
                    {
                        $length_tmp_final = length($read);
                    }
                    if (exists($printed_refs{$length_tmp_final}))
                    {
                        $ref_file = $printed_refs{$length_tmp_final};
                    }                
                    else
                    {
                        my $ref_part_found = "";
                        
                        if ($add_rejected_reads eq "")
                        {
                            foreach my $length_tmp3 (sort {$a <=> $b} keys %printed_refs)
                            {
                                if ($length_tmp3 >= $length_tmp_final-50 && $length_tmp3 < $length_tmp_final+1000)
                                {
                                    $ref_file = $printed_refs{$length_tmp3};
                                    $ref_part_found = "yes";
                                    $length_tmp_final = $length_tmp3;
                                    last;
                                }
                            }
                        }
                        
                        if ($ref_part_found eq "")
                        {
                            $ref_part = substr $read, -$length_tmp_final;
                            $ref_file = $TMP_directory."ref_tmp_".$id_tmp2."_".$y.".fasta";
                            $printed_refs{$length_tmp_final} = $ref_file;
                            $printed_refs2{$id_tmp2} = undef;
                            open(OUTPUT_LONG2, ">" .$ref_file) or die "\nCan't open file $ref_file, $!\n";
							OUTPUT_LONG2->autoflush(1);
                            #print OUTPUT_LONG2 ">ref\n";
                            print OUTPUT_LONG2 $ref_part;							
                            close OUTPUT_LONG2;
                        }
                    }

                    $ref_part{$id_tmp2} = $length_tmp_final;
                    $printed_blast{$id_tmp2} = $ref_file; 
                
                    chomp($output_file1);
                    chomp($ref_file);

                    $input_files_blast{$length_tmp}{$output_file1}{$ref_file}{$length_tmp_final} = $double_match_tmp;
					$input_length_done{$length_tmp} = undef;
					
					if (-s $output_file1)
					{
					}
					else
					{
						print "the file ".$output_file1." does not exist!\n";
					}
					if (-s $ref_file)
					{
					}
					else
					{
						print "the file ".$ref_file." does not exist!\n";
					}

					my $command = "blastn -query ".$ref_file." -subject ".$output_file1." -out ".$TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp2.".txt -outfmt 5 -strand plus -culling_limit 1 &";

					if ($find_haps_in_seed ne "")
					{
						$command = "blastn -query ".$ref_file." -subject ".$output_file1." -out ".$TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp2.".txt -outfmt 5 -strand plus -reward 2 -penalty -3 -evalue 1e-50 -culling_limit 1 &";
					}
           
					syscmd($command);
					
					if ($save_reads eq "yes")
					{
						if (exists($assembled_reads{$id_tmp2}))
						{}
						else
						{
							$assembled_reads{$id_tmp2} = undef;
							if ($save_reads eq "yes")
							{
								print OUTPUT10 ">".$id_tmp2."_".$id."\n";
								print OUTPUT10 $hash_PB_reads_tmp{$id_tmp2}."\n";
							}  
						}
					}
					$input_BLAST_done{$length_tmp} = undef;
                    
                    if (exists($double_matches{$id_tmp2}) && $double_match_tmp eq "")
                    {
                        $double_match_tmp = "yes";
                        goto DOUBLE_MATCH_PB1;
                    }
                }
				
				my $time_id_by_length = time;
                my $time_sort_matches = $time_id_by_length - $time_kmers;
                print {$filehandle{$seed_id2}} $time_sort_matches." TIME_SORT_MATCHES_PB\n";
				
				my $double_matches_running = '0';
                my $count_BLAST_runnng = keys %input_BLAST_done;
				
#Read BLAST--------------------------------------------------------------------------------------------------------------------------

                foreach my $blast_db_results_tmp (keys %output_files_DB2)
                {
                    unlink $blast_db_results_tmp;
					delete $output_files_DB2{$blast_db_results_tmp};
                }
BLAST_RUN_PB:
BLAST1_PB:      foreach my $length_tmp (sort {$a <=> $b} keys %input_files_blast)
                {    
                    my $id_tmp3 = $id_by_length{$length_tmp};
					
					foreach my $read_file_tmp (keys %{$input_files_blast{$length_tmp}})
                    {
						foreach my $ref_file_tmp (keys %{$input_files_blast{$length_tmp}{$read_file_tmp}})
						{
							foreach my $length_final_tmp (keys %{$input_files_blast{$length_tmp}{$read_file_tmp}{$ref_file_tmp}})
							{	
								my $double_match_tmp = $input_files_blast{$length_tmp}{$read_file_tmp}{$ref_file_tmp}{$length_final_tmp};              
								my $input_BLAST  =  $TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp3.".txt";

								if (-s $input_BLAST)
								{
									my $prev_line = "";
									my $prev_line2 = "";
									open(INPUT_BLAST, $input_BLAST);
									while (my $line_tmp = <INPUT_BLAST>)
									{              
										$prev_line2 = $prev_line;
										$prev_line = $line_tmp;
									}
									close INPUT_BLAST;
									chomp($prev_line2);
									if ($prev_line2 eq "</BlastOutput>")
									{
										open(INPUT_BLAST, $input_BLAST);
									}
									else
									{
										next BLAST1_PB;
									}
								}
								else
								{
									next BLAST1_PB;
								}

								my $length_long_read_tmp = length($hash_PB_reads_tmp{$id_tmp3});
								#my $ref_part = substr $read, -$ref_part{$id_tmp3};
								#my $N_count_ref = $ref_part =~ tr/N/N/;
								if ($ref_part{$id_tmp3} eq '0' || $ref_part{$id_tmp3} eq "")
								{
									print {$filehandle{$seed_id2}} $length_tmp." 0ERROR\n";
									print {$filehandle{$seed_id2}} $id_tmp3." 0ERRORbbb\n";
									#goto END1;
								}
								#my $N_correction = ($N_count_ref/$ref_part{$id_tmp3})*100;
								if (exists($double_matches{$id_tmp3}))
								{
									if (exists($double_match_check{$id_tmp3}))
									{
										$double_match_check{$id_tmp3} = "yes2";
									}
									else
									{
										$double_match_check{$id_tmp3} = "yes";
									}
								}			
                    
#BLAST1&2---------------------------------------------------------------------------------------------------------------------------------------------
								
								my $j = '0';
								my $ref_pos = '0';
								my $score_match = '0';
								my $score_no_match = '0';
								my $score_match_DUP = '0';
								my $score_no_match_DUP = '0';
								my $bit_score_start = "";
								my $assembly_start_pos_start = "";
								my $assembly_end_pos_start = "";
								my $read_start_pos_start = "";
								my $read_end_pos_start = "";
								my $query_start = "";
								my $subject_start = "";
								my $mismatch_start = "";
								my $alignment_length2_start = "";
								my $pos_matches_start = "";
								my $query = "";
								my $subject = "";
								my $mismatch = "";
								my %query;
								undef %query;
								my %subject;
								undef %subject;
								my %mismatch;
								undef %mismatch;
								my $bit_score = "";
			   
								my $alignment_length = "";
								my $alignment_length2 = '0';
								my $pos_matches = '0';
								my $long_read_start_pos = "";
								my $long_read_end_pos = "";
								my $assembly_end_pos = "";
								my $assembly_start_pos = "";
								my %long_read_start_pos;
								undef %long_read_start_pos;
								my %long_read_end_pos;
								undef %long_read_end_pos;
								my %assembly_end_pos;
								undef %assembly_end_pos;
								my %assembly_start_pos;
								undef %assembly_start_pos;
								
								my $read_pass = "";
								my $accuracy = "";
				  
								my $largest_prev_split = "";
								my $largest_prev_split_ext = "";
								my $skip_id = "";
								
								my $assembly_start_pos_low = "1";
								my $long_read_start_pos_high = "1";
								my $assembly_end_pos_high = "1";
								my $long_read_end_pos_high = "1";
								my $match_confirmed = "";
                    
INPUT_BLAST_PB:     			while (my $line2 = <INPUT_BLAST>)
								{                                                     
									chomp($line2);
									
									if ($j > 26)
									{
										my @blast_result_tmp;
										undef @blast_result_tmp;
										if ($j < $assembly_start_pos_start || $assembly_start_pos_start eq "")
										{
											@blast_result_tmp = split /\s+/, $line2;
										}
                            
										if ($j eq '27' && $blast_result_tmp[0] ne "<Hit>")
										{
											$no_hit_rejection++;
											$skip_id = "no_hit_rejection";
											goto SKIP_BLAST1_PB;
										}
										elsif ($j eq '27')
										{
											#print {$filehandle{$seed_id2}} "\n".$id_tmp3." ID\n";
										}
                             
										if ($blast_result_tmp[0] eq "</BlastOutput>")
										{
											print {$filehandle{$seed_id2}} $assembly_start_pos." REF_START_POS  ".$long_read_start_pos." READ_START_POS  ".$long_read_end_pos." READ_END_POS\n";
											
											#if ($ref_pos < length($check_prev_splits2{$check_prev_splits_id}))
											#{
												#$read_pos += (length($check_prev_splits2{$check_prev_splits_id}) - $ref_pos);
											   # print {$filehandle{$seed_id2}} length($check_prev_splits2{$check_prev_splits_id}) - $ref_pos." READ_POS_CORRECTION\n";
										   # }
											last INPUT_BLAST_PB;
										}
										elsif ($bit_score_start ne "" && $bit_score_start eq $j)
										{
										}
										elsif ($assembly_start_pos_start ne "" && $assembly_start_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$assembly_start_pos = substr $blast_result_tmp2[1], 15;
										}
										elsif ($assembly_end_pos_start ne "" && $assembly_end_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$assembly_end_pos = substr $blast_result_tmp2[1], 13;
										}
										elsif ($read_start_pos_start ne "" && $read_start_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$long_read_start_pos = substr $blast_result_tmp2[1], 13;
										}
										elsif ($read_end_pos_start ne "" && $read_end_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$long_read_end_pos = substr $blast_result_tmp2[1], 11;
										}
										elsif ($pos_matches_start ne "" && $pos_matches_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$pos_matches = substr $blast_result_tmp2[1], 13;
										}
										elsif ($alignment_length2_start ne "" && $alignment_length2_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$alignment_length2 = substr $blast_result_tmp2[1], 14;
											
											if ($accuracy eq "")
											{
												$accuracy = $pos_matches/$alignment_length2;
											}
											else
											{
												my $accuracy_tmp = $pos_matches/$alignment_length2;
												my $accuracy_tmp2 = $accuracy;
												$accuracy = ($accuracy_tmp+$accuracy_tmp2)/2   
											}

											$alignment_length = $assembly_end_pos - $assembly_start_pos + 1;
											my $accuracy_threshold = 0.985;
											if ($alignment_length > 5000)
											{
												$accuracy_threshold = 0.965;
											}
											if ($alignment_length < 350 && length($read) > 600)
											{
												#print {$filehandle{$seed_id2}} $alignment_length." OVERLAP_TOO_SHORT\n";
												$overlap_too_short++;
												$skip_id = "match_too_short";
												goto SKIP_BLAST1_PB;
											}
											elsif ($assembly_end_pos < $ref_part{$id_tmp3}-70)
											{
												#print {$filehandle{$seed_id2}} $assembly_end_pos." REF_END_REJECTION\n";
												$ref_end_rejection++;
												delete $save_alignment_data_PB{$seed_id}{$id_tmp3};
												$skip_id = "ref_end_rejection";
												goto SKIP_BLAST1_PB;
											}
											elsif ($long_read_start_pos > 70 && $assembly_start_pos > 70)
											{
												#print {$filehandle{$seed_id2}} $assembly_start_pos." REF ".$long_read_start_pos." READ_START_POS_REJECTION\n";
												$read_start_pos_rejection++;
												my $alignment_length_tmp = $assembly_end_pos - $assembly_start_pos + 1; 
												$read_start_pos_rej{$id_tmp3} = $alignment_length_tmp;
												$long_read_end_pos_save{$id_tmp3} = $long_read_end_pos;
												$skip_id = "read_start_pos_rejection";
												goto SKIP_BLAST1_PB;
											}			
											elsif ($long_read_end_pos > $length_long_read_tmp-300)
											{
												#print {$filehandle{$seed_id2}} $long_read_end_pos." EXT_TOO_SHORT\n";
												$ext_too_short++;
												$skip_id = "ext_too_short";
												delete $save_alignment_data_PB{$seed_id}{$id_tmp3};
												goto SKIP_BLAST1_PB;
											}
											elsif ($accuracy < $accuracy_threshold || ($accuracy < $accuracy_threshold && $total_matches > $sequencing_depth_PB*2 && $strict_accuracy eq ""))
											{
												#print {$filehandle{$seed_id2}} $accuracy." ACCURACY_REJECTION\n";
												$accuracy_rejection++;
												$skip_id = "accuracy_rejection";
												goto SKIP_BLAST1_PB;
											}
											elsif (exists($alignment_length_save{$id_tmp3}) && $alignment_length < $alignment_length_save{$id_tmp3}
												   && (exists($extensions2{$id_tmp3}) || exists($extensions_unknown2{$id_tmp3}) || $alignment_length < $alignment_length_save{$id_tmp3}*0.5))
											{
												print {$filehandle{$seed_id2}} $id_tmp3." ".$alignment_length." REMOVE_DUPLICATE2\n";
												$skip_id = "remove_duplicate";
												goto SKIP_BLAST1_PB;
											}
											else
											{
												if (exists($alignment_length_save{$id_tmp3}))
												{
													print {$filehandle{$seed_id2}} $id_tmp3." ".$alignment_length." REMOVE_DUPLICATE1\n";
													foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions{$id}})
													{
														delete $SNP_matches{$prev_splits}{$id_tmp3};
														delete $SNP_no_matches{$prev_splits}{$id_tmp3};
													}
													foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions_DUP{$id}})
													{
														delete $SNP_matches{$prev_splits}{$id_tmp3};
														delete $SNP_no_matches{$prev_splits}{$id_tmp3};
													}
													delete $store_mismatches_PB{$id_tmp3};
													$double_match_reject{$id_tmp3} = undef;
													$count_matches_with_high_scores--;
													delete $extensions2{$id_tmp3};
													delete $extensions2b{$id_tmp3};				
													delete $var_matches{$id_tmp3};
													delete $var_matches_DUP{$id_tmp3};
													delete $extensions_nomatch2{$id_tmp3};
													delete $extensions_nomatch2b{$id_tmp3};
													delete $extensions_unknown2{$id_tmp3};
													delete $exclude_reads_PB{$id}{$id_tmp3};
												}
												$alignment_length_save{$id_tmp3} = $alignment_length;
												$count_matches_with_high_scores++;   
												$long_read_end_pos_save{$id_tmp3} = $long_read_end_pos;
												$match_confirmed = "yes";
												
												my $pos_tmp = $assembly_start_pos-50;
												if ($pos_tmp < 0)
												{
													$pos_tmp = '0';
												}
												my $long_read_tmp = "";
				
												if (exists($reverse_list{$id_tmp3}) && $double_match_tmp eq "")
												{
													$long_read_tmp = reverse($hash_PB_reads_tmp{$id_tmp3});
													$long_read_tmp =~ tr/ACTG/TGAC/;
												}
												else
												{
													$long_read_tmp = $hash_PB_reads_tmp{$id_tmp3};
												}
												$check_prev_splits{$id_tmp3} = $long_read_tmp;        
												$accuracy{$id_tmp3} = $accuracy;
											}
										}
										elsif ($query_start ne "" && $query_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$query = substr $blast_result_tmp2[1], 9;
											#print {$filehandle{$seed_id2}} $query." QUERY\n";
										}
										elsif ($subject_start ne "" && $subject_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$subject = substr $blast_result_tmp2[1], 9;
											#print {$filehandle{$seed_id2}} $subject." SUBJECT\n";
										}
										elsif ($mismatch_start ne "" && $mismatch_start eq $j && $find_haps_in_seed eq "")
										{
											my @blast_result_tmp2 = split /</, $line2;
											$mismatch = substr $blast_result_tmp2[1], 12;
											#print {$filehandle{$seed_id2}} $mismatch." MISMATCH\n";
											my @blast_result_tmp3 = split /\s/, $mismatch;
											
											my $track_length = '-1';
                                
											if ($find_haps_in_seed eq "")
											{
												foreach my $id_split (keys %split_positions)
												{
													if ($id_split eq $id)
													{
SPLIT_PB:                                   			foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions{$id_split}})
														{
															if ($last_hap_pos eq "")
															{
																$last_hap_pos = $position - $prev_splits;
															}
															$track_length = '-1';
															if ($alignment_length > $position-$prev_splits)
															{
																$largest_prev_split = $ref_part{$id_tmp3}-$assembly_start_pos - ($position - $prev_splits)+1; 
																$largest_prev_split_ext = $split_positions{$id_split}{$prev_splits};
			
																my $b = '0';
																my $last12 = "";
																my $last12_match = "";
														
																while ($b < length($query))
																{
																	my $nuc_query = substr $query, $b, 1;
																	if ($nuc_query ne "-")
																	{
																		$track_length += 1;
																		if ($track_length > $largest_prev_split-15 && $track_length < $largest_prev_split+5)
																		{
																			$last12 .= $nuc_query;
																			if (length($last12) > 12)
																			{
																				substr $last12, 0, 1, "";
																			}
																			if (length($last12) > 11)
																			{
																				my @largest_prev_split_ext = split /,/, $largest_prev_split_ext;
																				
																				if ($last12 eq $largest_prev_split_ext[0])
																				{
																					$last12_match = "yes";
																					$b++;
																					next;
																				}
																				if ($last12_match eq "yes")
																				{
																					$last12_match = "";
																					my $nuc_subject = substr $subject, $b, 1;
																					my $nuc_mismatch_prev = substr $mismatch, $b-1, 1;
																					my $nuc_mismatch_post = substr $mismatch, $b+1, 1;
			
																					if ($nuc_query ne $largest_prev_split_ext[1])
																					{
																						
																					}
																					if ($nuc_mismatch_prev ne "|" && $nuc_mismatch_post ne "|")
																					{
																						print {$filehandle{$seed_id2}} $prev_splits." SPLIT_POS\n";
																		print {$filehandle{$seed_id2}} $largest_prev_split." SPLIT_POS2\n";
																		print {$filehandle{$seed_id2}} $largest_prev_split_ext." SPLIT_POS_ECT\n";
																		print {$filehandle{$seed_id2}} $assembly_start_pos." START_POS\n";
																		print {$filehandle{$seed_id2}} $ref_part{$id_tmp3}." REF_PART\n";
																		#print {$filehandle{$seed_id2}} $query." QUERY\n";
																						print {$filehandle{$seed_id2}} $nuc_query." NUC_QUERY\n";
																						print {$filehandle{$seed_id2}} $nuc_subject." NUC_SUBJECT\n\n";
																						my $test_seq = substr $query, $b-15, 30;
																						print {$filehandle{$seed_id2}} $test_seq." TEST_SEQ\n";
																					}
																					elsif ($nuc_query eq $nuc_subject)
																					{
																						$score_match++;
																						$SNP_matches{$prev_splits}{$id_tmp3} = undef;
																					}
																					elsif ($nuc_subject ne "-" && $nuc_query ne "N")
																					{
																						$score_no_match++;
																						$SNP_no_matches{$prev_splits}{$id_tmp3} = undef;
																					}
																					next SPLIT_PB;
																				}
																			}
																		}
																	}
																	$b++;
																}
															}
														}
													}
												}

#Store mismatches of the aligned reads to split reads---------------------------------------------------------------------                              
												$track_length = '-1';
												my $track_query = $ref_part{$id_tmp3}-$assembly_start_pos+1;
												my $track_query_full = $assembly_start_pos+$position-$ref_part{$id_tmp3};
												my @blast_result_tmp3 = split /\s+/, $mismatch;

												foreach my $blast_tmp (@blast_result_tmp3)
												{
													$track_length += length($blast_tmp);
													$track_query -= length($blast_tmp);
													$track_query_full += length($blast_tmp);
										
													my $track_length_adjust = '0';
													my $nuc_query = substr $query, $track_length+1, 1;
													my $nuc_query_prev = substr $query, $track_length, 1;
													my $nuc_query_post = substr $query, $track_length+2, 1;
													my $nuc_subject = substr $subject, $track_length+1, 1;
													while ($nuc_query ne $nuc_subject)
													{
														$track_length_adjust++;                                       
														if ($track_length < length($query)-1)
														{
															if ($nuc_query ne "N" && $nuc_query ne "n" && $nuc_query_prev ne "N" && $nuc_query_post ne "N")
															{
																my $track_length_tmp = $track_length+$track_length_adjust;
																my $seq_tmp = substr $read, -$track_query-30, 31;
																my $five_before = substr $seq_tmp, -4, 4;
																my $five_after = substr $read, -$track_query, 4;
																
																if (($five_before ne "AAAA" && $five_before ne "CCCC" && $five_before ne "TTTT" && $five_before ne "GGGG"
																	&& $five_after ne "AAAA" && $five_after ne "CCCC" && $five_after ne "TTTT" && $five_after ne "GGGG")
																	|| ($five_before ne "AAA" && $five_before ne "CCC" && $five_before ne "TTT" && $five_before ne "GGG"
																	&& $five_after ne "AAA" && $five_after ne "CCC" && $five_after ne "TTT" && $five_after ne "GGG" && ($nuc_query eq "-" || $nuc_subject eq "-")))
																{			
																	if (exists($store_mismatches_PB{$id_tmp3}))
																	{   
																		$store_mismatches_PB{$id_tmp3}{$track_query_full} = $nuc_query.",".$nuc_subject.",".$seq_tmp;                 
																	}
																	else
																	{
																		$store_mismatches_PB{$id_tmp3}{$track_query_full} = $nuc_query.",".$nuc_subject.",".$seq_tmp;
																	}
																}
															}
SKIP_STORE_MISMATCH_PB:                                                    
															my $track_length_tmp = $track_length+$track_length_adjust;
															my $seq_tmp = substr $read, -$track_query-30, 31;
															if ($nuc_query eq "N" || $nuc_query eq "n")
															{
																$store_mismatches_N_PB{$id_tmp3}{$track_query_full} = $nuc_query.",".$nuc_subject.",".$seq_tmp;
															}
															if ($nuc_query ne "-")
															{
																$track_query--;
																$track_query_full++;
															}
															#print {$filehandle{$seed_id2}} $track_query." TRACK_QUERY\n";
															#print {$filehandle{$seed_id2}} $track_length_adjust." NUC_SUBJECT\n";
														}
														
														$nuc_query = substr $query, $track_length+$track_length_adjust+1, 1;
														$nuc_subject = substr $subject, $track_length+$track_length_adjust+1, 1;
													}                                                    
													$track_length += $track_length_adjust;  
												}

#Check split positions derived from duplicated regions--------------------------------------------------------------------------------------------------------------------------
												foreach my $id_split (keys %split_positions_DUP)
												{
													if ($id_split eq $id)
													{
SPLIT_PB_DUP:                               			foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions_DUP{$id_split}})
														{
															if ($last_hap_pos_DUP eq "")
															{
																$last_hap_pos_DUP = $position - $prev_splits;
															}
															$track_length = '-1';

															if ($alignment_length > $position - $prev_splits)
															{
																$largest_prev_split = $ref_part{$id_tmp3}-$assembly_start_pos - ($position - $prev_splits)+1; 
																my $read_end_tmp = $split_positions_DUP{$id_split}{$prev_splits};
																my $nuc_DUP_tmp = $split_positions_DUP2{$id_split}{$prev_splits};
			
																my $b = '0';
																my $last12 = "";
																my $last12_match = "";
														
																while ($b < length($query))
																{
																	my $nuc_query = substr $query, $b, 1;
																	if ($nuc_query ne "-")
																	{
																		$track_length += 1;
																		if ($track_length > $largest_prev_split-15 && $track_length < $largest_prev_split+5)
																		{
																			$last12 .= $nuc_query;
																			if (length($last12) > 12)
																			{
																				substr $last12, 0, 1, "";
																			}
																			if (length($last12) > 11)
																			{
																				if ($last12 eq $read_end_tmp)
																				{
																					$last12_match = "yes";
																					$b++;
																					next;
																				}
																				if ($last12_match eq "yes")
																				{
																					$last12_match = "";
																					my $nuc_subject = substr $subject, $b, 1;
																					my $nuc_mismatch_prev = substr $mismatch, $b-1, 1;
																					my $nuc_mismatch_post = substr $mismatch, $b+1, 1;
			
																					if ($nuc_subject ne $nuc_DUP_tmp && $nuc_query ne $nuc_subject && $nuc_subject ne "-")
																					{
																						if ($nuc_query eq "N")
																						{
																							delete $split_positions_DUP{$id_split}{$prev_splits};
																							delete $split_positions_DUP2{$id_split}{$prev_splits};
																						}	
																					}
																					if ($nuc_mismatch_prev ne "|" && $nuc_mismatch_post ne "|")
																					{
																						if ($nuc_mismatch_prev eq "ffege")
																						{
																						print {$filehandle{$seed_id2}} $prev_splits." SPLIT_POS_DUP\n";
																		print {$filehandle{$seed_id2}} $largest_prev_split." SPLIT_POS2_DUP\n";
																		print {$filehandle{$seed_id2}} $read_end_tmp." SPLIT_POS_ECT_DUP\n";
																		print {$filehandle{$seed_id2}} $assembly_start_pos." START_POS_DUP\n";
																		print {$filehandle{$seed_id2}} $ref_part{$id_tmp3}." REF_PART_DUP\n";
																		#print {$filehandle{$seed_id2}} $query{$count_mismatch_tmp}." QUERY_DUP\n";
																						print {$filehandle{$seed_id2}} $nuc_query." NUC_QUERY_DUP\n";
																						print {$filehandle{$seed_id2}} $nuc_subject." NUC_SUBJECT_DUP\n\n";
																						my $test_seq = substr $query, $b-15, 30;
																						my $test_seq2 = substr $subject, $b-15, 30;
																						my $test_seq3 = substr $mismatch, $b-15, 30;
																						print {$filehandle{$seed_id2}} $test_seq." TEST_SEQ_DUP\n";
																						print {$filehandle{$seed_id2}} $test_seq2." TEST_SEQ_DUP2\n";
																						print {$filehandle{$seed_id2}} $test_seq3." TEST_SEQ_DUP3\n";
																						print {$filehandle{$seed_id2}} $nuc_mismatch_prev." MISMATCH_PREV\n";
																						print {$filehandle{$seed_id2}} $nuc_mismatch_post." MISMATCH_POST\n\n";
																						}
																					}
																					elsif ($nuc_query eq $nuc_subject)
																					{
																						$score_match_DUP++;
																						$SNP_matches{$prev_splits}{$id_tmp3} = undef;
																					}
																					elsif ($nuc_subject ne "" && $nuc_query ne "N")
																					{
																						$score_no_match_DUP++;
																						$SNP_no_matches{$prev_splits}{$id_tmp3} = undef;
																					}
																					next SPLIT_PB_DUP;
																				}
																			}
																		}
																	}
																	$b++;
																}
															}
														}
													}
												}
											}
											if ($match_confirmed eq "yes")
											{
												goto SKIP_BLAST1_PB;
											}
										}                            
										elsif ($blast_result_tmp[1] eq "<Hsp>")
										{ 
											$j++;
											$bit_score_start = $j+1;
											$assembly_start_pos_start = $j+4;
											$assembly_end_pos_start = $j+5;
											$read_start_pos_start = $j+6;
											$read_end_pos_start = $j+7;
											$pos_matches_start = $j+11;
											$alignment_length2_start = $j+13;
											$query_start = $j+14;
											$subject_start = $j+15;
											$mismatch_start = $j+16;
											next INPUT_BLAST_PB;
										}
										else
										{
											$j++;
											next INPUT_BLAST_PB;
										}
									}
									$j++
								}
SKIP_BLAST1_PB:                    
								delete $input_files_blast{$length_tmp}{$read_file_tmp};
								if (keys %{$input_files_blast{$length_tmp}} < 1)
								{
									delete $input_files_blast{$length_tmp};
								}
								delete $input_BLAST_done{$length_tmp};
								if (exists($double_matches{$id_tmp3}) && $double_match_tmp eq "")
								{
									$double_matches_running--;
								}
								close INPUT_BLAST;
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
								if ($add_rejected_reads ne "" && exists($read_start_pos_rej_saved{$id_tmp3}))
								{
									$add_rej_reads_extra{$id_tmp3} = undef;
									delete $save_reads_for_next{$id_tmp3};
								}
#-----------------------------------------------------------------------------------------------------------------
								if ($skip_id ne "")
								{
									$rejected_reads_save{$id_tmp3} = undef;
									if (exists($double_match_check{$id_tmp3}))
									{
										if ($double_match_check{$id_tmp3} eq "yes")
										{
											
										}
										elsif ($double_match_check{$id_tmp3} eq "yes2")
										{
											unless (exists($double_match_reject{$id_tmp3}))
											{
												delete $read_start_pos_rej{$id_tmp3};
												delete $rejected_reads_save{$id_tmp3};
												delete $add_rej_reads_extra{$id_tmp3};
												if ($double_match_tmp eq "")
												{
													delete $reverse_list{$id_tmp3};
												}
											}										
										}
										$double_match_reject{$id_tmp3} = undef;
									}
									
#Exclude reads------------------------
									if ($skip_id eq "ref_end_rejection")
									{
										my $exclude_pos = $long_read_end_pos;
										if (length($read) < $long_read_end_pos)
										{
											$exclude_pos = length($read);
										}
										if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "")
										{
											$exclude_reads_PB{$id}{$id_tmp3} = $position+$exclude_pos;
											#print {$filehandle{$seed_id2}} $id_tmp." EXCLUDE1\n";
										}
									}
#Exclude reads------------------------        
									next BLAST1_PB;  
								}
								else
								{
									if (exists($double_match_reject{$id_tmp3}))
									{
										delete $read_start_pos_rej{$id_tmp3};
										delete $add_rej_reads_extra{$id_tmp3};
										delete $rejected_reads_save{$id_tmp3};
										delete $exclude_reads_PB{$id}{$id_tmp3};
										if ($double_match_tmp eq "yes")
										{
											delete $reverse_list{$id_tmp3};
										}
									}
									elsif ($double_match_check{$id_tmp3} eq "yes2")
									{
										print {$filehandle{$seed_id2}} $id_tmp3." DOUBLE_MATCH_ERROR\n";
									}
								}
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
								if ($add_no_match_reads ne "" && exists($extensions_nomatch2b_saved{$id_tmp3}))
								{
									$add_rej_reads_extra{$id_tmp3} = undef;
									delete $save_reads_for_next{$id_tmp3};
								}
#-----------------------------------------------------------------------------------------------------------------
        
#---------------------------------------------------------------------------------------------------------------------------------------------------------         
#Check for previous variations of the assembly in the long reads------------------------------------------------------------------------------------------                   
#---------------------------------------------------------------------------------------------------------------------------------------------------------
								print {$filehandle{$seed_id2}} "\n".$id_tmp3." ID\n";
								if ($score_match > 0)
								{
									print {$filehandle{$seed_id2}} $score_match." EXT_MATCH\n";
								}
								if ($score_no_match > 0)
								{
									print {$filehandle{$seed_id2}} $score_no_match." EXT_NO_MATCH\n";
								}
								if ($score_match_DUP > 0)
								{
									print {$filehandle{$seed_id2}} $score_match_DUP." EXT_MATCH_DUP\n";
								}
								if ($score_no_match_DUP > 0)
								{
									print {$filehandle{$seed_id2}} $score_no_match_DUP." EXT_NO_MATCH_DUP\n";
								}
								my $length_read = length($check_prev_splits{$id_tmp3});
								print {$filehandle{$seed_id2}} $alignment_length." LENGTH_MATCH\n";
								$score_matches_save{$id_tmp3} = $score_match."_".$score_no_match."_".$score_match_DUP."_".$score_no_match_DUP;
								$extensions_scores_saved{$id_tmp3} = $score_match+$score_match_DUP-$score_no_match-$score_no_match_DUP;
                    
								if ($score_no_match > $score_match*0.1 || ($score_no_match_DUP > $score_match_DUP*0.15 && ($score_no_match_DUP > 1 || $score_match eq '0' || $score_no_match+$score_no_match_DUP > $score_match+$score_match_DUP)))
								{
									my $ext = substr $check_prev_splits{$id_tmp3}, $long_read_end_pos-90;
									$length_ext_all{$id_tmp3} = length($ext);
									
									if (length($ext) > 200)
									{
										$extensions_nomatch{$ext} = $id_tmp3;
										$extensions_nomatch2{$id_tmp3} = $ext;
										$extensions_nomatch2b{$id_tmp3}{$ext}{$score_no_match} = $score_match;
										$extensions_nomatch2b_count++;
									}
#Exclude reads------------------------                        
									my $exclude_pos = $long_read_end_pos;
									if (length($read) < $long_read_end_pos)
									{
										$exclude_pos = length($read);
									}
									if ($score_no_match > 3)
									{
										$exclude_reads_PB{$id}{$id_tmp3} = $position+$exclude_pos;
										print {$filehandle{$seed_id2}} $id_tmp3." EXCLUDE1\n";
									}
#Exclude reads------------------------                                               
								}
								elsif ($score_match > $score_no_match*3 && $score_match > 0 && $score_match_DUP >= $score_no_match_DUP)
								{
									if (exists($add_rej_reads_extra{$id_tmp3}))
									{
										delete $add_rej_reads_extra{$id_tmp3};
										delete $id_matches{$id_tmp3};
										delete $save_alignment_data_NP{$seed_id}{$id_tmp3};

										if ($add_no_match_reads ne "")
										{
											delete $exclude_reads_PB{$id};
											delete $save_alignment_data_PB{$id};
											delete $rejected_alignment_data_PB{$id};
											$full_reset_PB = "A";
											print {$filehandle{$seed_id2}} $best_extension." FULL_RESET_PB_NO_MATCH\n";
											$best_extension = "";
											$seed_id = $id;
											$y++;
											$y{$id} = $y;
											goto FULL_RESET;
										}
									}
									else
									{
										my $ext = substr $check_prev_splits{$id_tmp3}, $long_read_end_pos-90;
										$length_ext_all{$id_tmp3} = length($ext);
										
										if (length($ext) > 200)
										{
											$extensions{$ext} = $id_tmp3;
											$extensions2{$id_tmp3} = $ext;
											$extensions2b{$id_tmp3}{$ext}{$score_match} = $score_no_match;
				
											$var_matches{$id_tmp3} = ($score_match)-($score_no_match*1.7);
											$var_matches_DUP{$id_tmp3} = $score_match_DUP-($score_no_match_DUP*1.5);
										}
										else
										{
											print {$filehandle{$seed_id2}} length($ext)." LENGTH TOO SHORT\n";
										}
									}
								}
								else
								{
									my $ext = substr $check_prev_splits{$id_tmp3}, $long_read_end_pos-90;
									$length_ext_all{$id_tmp3} = length($ext);
									
									if ($find_haps_in_seed eq "yes")
									{
										$ext = substr $check_prev_splits{$id_tmp3}, $long_read_start_pos, $long_read_end_pos-$long_read_start_pos;
									}
									
									if ($add_no_match_reads ne "" && $score_no_match eq '0' && $score_no_match_DUP eq '0')
									{
										delete $exclude_reads_PB{$id};
										delete $save_alignment_data_PB{$id};
										delete $rejected_alignment_data_PB{$id};
										$full_reset_PB = "A";
										print {$filehandle{$seed_id2}} $best_extension." FULL_RESET_PB_NO_MATCH\n";
										$best_extension = "";
										$seed_id = $id;
										$y++;
										$y{$id} = $y;
										goto FULL_RESET;
									}
									
									if (length($ext) > 200)
									{                         
										$extensions_unknown{$ext} = $id_tmp3;
										$extensions_unknown2{$id_tmp3} = $ext;
										
										$var_matches{$id_tmp3} = ($score_match)-($score_no_match*1.7);
										$var_matches_DUP{$id_tmp3} = $score_match_DUP-($score_no_match_DUP*1.5);
									}
								}
								my $input_files_blast_tmp = keys %input_files_blast;
								if ($count_BLAST_runnng < $input_files_blast_tmp)
								{
									goto BLAST_RUN_PB;
								}
							}
						}
					}
				}
				my $count_remaining_ids = '0';
				foreach my $length_tmp (keys %input_files_blast)
				{
					my $count_remaining_ids2 = keys %{$input_files_blast{$length_tmp}};
					if ($count_remaining_ids2 > 0)
					{
						$count_remaining_ids++;
					}
					else
					{
						delete $input_files_blast{$length_tmp};
						delete $id_by_length{$length_tmp};
					}
				}

                my $limi = '1150';
                if ($count_remaining_ids > 0 && $count_limit1 < $limi)
                {
                    $count_limit1++;
					if ($count_limit1 > 1000)
					{
						sleep(1);
					}
                    goto BLAST_RUN_PB;
                }
                else
                {
                    foreach my $length_tmp (keys %input_files_blast)
					{
                        my $id_tmp3 = $id_by_length{$length_tmp};
						print {$filehandle{$seed_id2}} $id_tmp3." SKIPPED_IDs\n";
                    }
                }
                
                print {$filehandle{$seed_id2}} "\n".$ref_end_rejection." REF_END_REJECTION\n";
                print {$filehandle{$seed_id2}} $read_start_pos_rejection." READ_START_POS_REJECTION\n";
                print {$filehandle{$seed_id2}} $no_hit_rejection." NO_HIT_REJECTION\n";
                print {$filehandle{$seed_id2}} $accuracy_rejection." ACCURACY_REJECTION\n";
                print {$filehandle{$seed_id2}} $ext_too_short." EXT_TOO_SHORT\n";
                print {$filehandle{$seed_id2}} $overlap_too_short." OVERLAP_TOO_SHORT\n";
                
                print {$filehandle{$seed_id2}} "\n".$longest_read." LONGEST_READ\n";
                print {$filehandle{$seed_id2}} $count_matches_with_high_scores." HIGH_SCORE_matches\n\n";                
						
				if ($assembly_length_max eq "WG" && $y eq "1" && ($count_matches_with_high_scores > $sequencing_depth_PB*2 || ($total_matches < 10 && $total_matches < $sequencing_depth_PB*0.7)) && ($first_back_assembly eq "" || length($read) < 5000))
				{
					print "GOTO_NEXT_SEED2\n";
					foreach my $id_tmp (keys %printed_refs2)
					{
						unlink $TMP_directory."ref_tmp_".$id_tmp."_".$y.".fasta";
					}
					foreach my $id_tmp (keys %printed_blast)
					{
						unlink $TMP_directory."blast_tmp_".$id."_".$y."__".$id_tmp.".txt";
						
						if (exists($double_matches{$id_tmp}))
						{
							unlink $TMP_directory."blast_tmp_".$id."_".$y."_yes_".$id_tmp.".txt";
						}
					}
					$first_back_assembly = "yes";
					goto END1;
				}  

                if ($count_remaining_ids > 0)
                {
                    foreach my $length_tmp (sort {$a <=> $b} keys %input_files_blast)
					{                
						my $id_tmp3 = $id_by_length{$length_tmp};
                        print {$filehandle{$seed_id2}} $id_tmp3." SKIPPED_IDs2\n";
                    }
                }

                foreach my $id_tmp (keys %printed_refs2)
                {
                    unlink $TMP_directory."ref_tmp_".$id_tmp."_".$y.".fasta";
                }
                foreach my $id_tmp (keys %printed_blast)
                {
                    unlink $TMP_directory."blast_tmp_".$id."_".$y."__".$id_tmp.".txt";
                    
                    if (exists($double_matches{$id_tmp}))
                    {
                        unlink $TMP_directory."blast_tmp_".$id."_".$y."_yes_".$id_tmp.".txt";
                    }
                }
				
				if ($assembly_length_max eq "WG" && $y eq "1" && $read_start_pos_rejection > $count_matches_with_high_scores && ($first_back_assembly eq "" || length($read) < 5000))
				{
					print "GOTO_NEXT_SEED3\n";
					$first_back_assembly = "yes";
					goto END1;
				}

#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
                if ($add_rejected_reads ne "" || $add_no_match_reads ne "")
                {
                    goto SELECT_LENGTH_PB2a;
                }

                my $time_BLAST2 = time;
                my $time8 = $time_BLAST2 - $time_kmers;
                print {$filehandle{$seed_id2}} $time8." TIME_BLAST2\n\n";
                
                if ($count_matches_with_high_scores < 3  && $full_reset_PB eq "")
				{
					delete $exclude_reads_PB{$id};
					delete $save_alignment_data_PB{$id};
					delete $rejected_alignment_data_PB{$id};
					$full_reset_PB = "A";
					print {$filehandle{$seed_id2}} $best_extension." FULL_RESET_PB\n";
					$best_extension = "";
					$seed_id = $id;
					$y++;
					$y{$id} = $y;
					goto FULL_RESET;
				}
				
				if ($count_matches_with_high_scores < 10 && $strict_accuracy eq "" && $accuracy_rejection > 0)
                {
                    $strict_accuracy = "no";
                    goto LOWER_ACCURACY;
                }
				if ($count_matches_with_high_scores < 4 && $reduce_last_600_PB > 400)
                {
                    if ($reduce_last_600_PB < 700)
                    {
                        $reduce_last_600_PB = '400';
                    }
                    else
                    {
                        $reduce_last_600_PB = '600';
                    }            
                    goto REDUCE_LAST_600_PB;
                }
				if ($count_matches_with_high_scores < 4 && $count_matches_with_high_scores < $sequencing_depth_PB/2 && ($retry_PB eq "" || $retry_PB < $position-20000) && $position > 20000 && $new_contig_check eq "")
                {
                    $retry_PB = $position;
					delete $exclude_reads_PB{$id};
					delete $save_alignment_data_PB{$id};
					delete $rejected_alignment_data_PB{$id};
					$best_extension = "";
					$seed_id = $id;
					substr $read, -15000, 15000, "";
					$seed{$seed_id} = $read;
					$y++;
					$y{$id} = $y;
					$position -= 15000;
					$position{$id} = $position;
					print {$filehandle{$seed_id2}} "RETRY_PB\n";
					goto FULL_RESET;
                }			
                
				if ($count_matches_with_high_scores < $sequencing_depth_PB*1.5 && $position > 2000)
                {
                    $last_non_complex_region{$seed_id} = $position-2000;
                }
				            
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
#Make consensus of extensions long reads PB-----------------------------------------------------------------------------------------------------------------------------------------                               
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                my $mismatch_retry = '0';
                my $high_quality = "";
                my %split_positions_DUP_tmp;
				undef %split_positions_DUP_tmp;
				my %split_positions_DUP_tmp2;
				undef %split_positions_DUP_tmp2;
                my $remove_reads_check = "";
				my %assemble_split_reads;
				undef %assemble_split_reads;
                
MISMATCH_RETRY_PB:
                my $merged_ext = "";
                my %extensions2_tmp = %extensions2;
                my $ext2_count = keys %extensions2_tmp;
                print {$filehandle{$seed_id2}} $ext2_count." EXT_COUNT\n";
                 
                if (keys %extensions eq 0)
                {
                    if (exists($no_hap_track{$id})) #CHECKKKKKKKKKKKKKKKKKKKKKKKKKK----
                    {}
                    else
                    {
                        $no_hap_track{$id} = $position;
                    }  
                }
                else
                {
                    delete $no_hap_track{$id};
                }
                
                if ((($ext2_count < 3 || $ext2_count < $sequencing_depth_PB/2 || ($ext2_count < $sequencing_depth_PB && $count_matches_with_high_scores > $sequencing_depth_PB*3) || ($ext2_count < $sequencing_depth_PB/1.5 && $ext2_count < 7))
                    && (keys %extensions_unknown > 0 || keys %extensions_nomatch2 > 0)) || ($last_hap_pos > 10000 && $ext2_count < $sequencing_depth_PB/2))
                {
                    %extensions = (%extensions, %extensions_unknown);
                    %extensions2_tmp = (%extensions2, %extensions_unknown2);
                    $merged_ext = "1";
                    print {$filehandle{$seed_id2}} " MERGE1\n";
                    if (keys %extensions < 3)
                    {
                        %extensions = (%extensions, %extensions_nomatch);
                        %extensions2_tmp = (%extensions2, %extensions_nomatch2);
                        $merged_ext = "2";
                        print {$filehandle{$seed_id2}} " MERGE2\n";
                    }
                }
				
                my $longer_extension_for_repeat = "";
                my $length_extension = '1200';
				my $count_hap_matches = keys %extensions2_tmp;         
                
#Reduce extensions----------------------------------------------------------------------------------------------                                         

                my %scores;
				undef %scores;
                my %scores2;
				undef %scores2;
                
                my $acc_max = '0';
                my $acc_min = '100';
				foreach my $accuracy_id_tmp (sort {$a <=> $b} keys %accuracy)
                {
                    if (exists($extensions2_tmp{$accuracy_id_tmp}))
                    {
                        my $accuracy_tmp = $accuracy{$accuracy_id_tmp};
                        if ($accuracy_tmp > $acc_max)
                        {
                            $acc_max = $accuracy_tmp;
                        }
                        if ($accuracy_tmp < $acc_min)
                        {
                            $acc_min = $accuracy_tmp;
                        }
                    }
                }
                foreach my $accuracy_id_tmp (sort {$a <=> $b} keys %accuracy)
                {
                    if ((exists($extensions2_tmp{$accuracy_id_tmp})) && $acc_max-$acc_min > 0)
                    {
                        my $accuracy_tmp = $accuracy{$accuracy_id_tmp};
                        $scores{$accuracy_id_tmp} = ($accuracy_tmp-$acc_min)/($acc_max-$acc_min)*0.75;
                    }
                }
                
                my $overlap_max = '0';
                my $overlap_min = '0';
                foreach my $overlap_id_tmp (keys %alignment_length_save)
                {          
                    if (exists($extensions2_tmp{$overlap_id_tmp}))
                    {
                        my $overlap_tmp = $alignment_length_save{$overlap_id_tmp};
                        if ($overlap_tmp > $overlap_max)
                        {
                            $overlap_max = $overlap_tmp;
                        }
                    }
                }
                foreach my $overlap_id_tmp (keys %alignment_length_save)
                {
                    if (exists($extensions2_tmp{$overlap_id_tmp}))
                    {
                        my $overlap_tmp = $alignment_length_save{$overlap_id_tmp};
                        my $overlap_score_tmp = '0';
                        if (($overlap_max-$overlap_min) ne '0')
                        {
                            $overlap_score_tmp = ($overlap_tmp-$overlap_min)/($overlap_max-$overlap_min)*0.85;
                        }
                        my $score_tmp = $scores{$overlap_id_tmp};
                        $scores{$overlap_id_tmp} = $overlap_score_tmp+$score_tmp;
                    }
                }
                
                my $var_max = '0';
                my $var_min = '100000000000000';
                
                foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches)
                {     
                    my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
                    if (exists($extensions2_tmp{$var_matches_id_tmp}))
                    {
                        if ($var_matches_tmp > $var_max)
                        {
                            $var_max = $var_matches_tmp;
                        }
                        if ($var_matches_tmp < $var_min)
                        {
                            $var_min = $var_matches_tmp;
                        }
                    }
                }
                foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches)
                {     
                    my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
                    if (exists($extensions2_tmp{$var_matches_id_tmp}))
                    {
                        my $var_score_tmp = '0';
                        if ($var_max-$var_min > 0)
                        {
                            $var_score_tmp = ($var_matches_tmp-$var_min)/($var_max-$var_min);
                        }
                        my $score_tmp = $scores{$var_matches_id_tmp};
                        $scores{$var_matches_id_tmp} = $score_tmp+$var_score_tmp;
                    }
                }
                
                my $var_max_DUP = '0';
                my $var_min_DUP = '100000000000000';
                
                foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches_DUP)
                {     
                    my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
                    if (exists($extensions2_tmp{$var_matches_id_tmp}))
                    {
                        if ($var_matches_tmp > $var_max_DUP)
                        {
                            $var_max_DUP = $var_matches_tmp;
                        }
                        if ($var_matches_tmp < $var_min_DUP)
                        {
                            $var_min_DUP = $var_matches_tmp;
                        }
                    }
                }
                foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches_DUP)
                {     
                    my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
                    if (exists($extensions2_tmp{$var_matches_id_tmp}))
                    {
                        my $var_score_tmp = '0';
                        if ($var_max_DUP-$var_min_DUP > 0)
                        {
                            $var_score_tmp = ($var_matches_tmp-$var_min_DUP)/($var_max_DUP-$var_min_DUP);
                        }
                        my $score_tmp = $scores{$var_matches_id_tmp};
                        $scores{$var_matches_id_tmp} = $score_tmp+$var_score_tmp;
                    }
                }
                
                foreach my $score_id (keys %scores)
                {
                    if (exists($scores2{$scores{$score_id}}))
                    {
                        $scores2{$scores{$score_id}} .= ",$score_id"; 
                    }
                    else
                    {
                        $scores2{$scores{$score_id}} = $score_id;
                    }
                }

                my $c = '1';
                my $c2 = '0';
                my $limit2 = $sequencing_depth_PB;
                #if ($find_haps_in_seed ne "")
                #{
                    my $limit = 25;
                #}
                my $shortest_ext = '100000000000000';
                my $max_score = "";
                my $max_score_count = '0';
                my %length_ext0;
				undef %length_ext0;
				my %length_ext_10;
				undef %length_ext_10;
                                    
                foreach my $score_tmp (sort {$b <=> $a} keys %scores2)
                {
                    print {$filehandle{$seed_id2}} $scores2{$score_tmp}." ".$score_tmp." SCORE\n";             
                    my @ids_tmp = split /,/, $scores2{$score_tmp};
                    foreach my $ids_tmp (@ids_tmp)
                    {
						if (exists($extensions2_tmp{$ids_tmp}))
                        {
                            $max_score_count++;
                            if ($max_score eq "")
                            {
                                $max_score = $score_tmp;
                            }
                            
                            if ($max_score_count < 3)
                            {
                                $c2++;
                                $length_ext0{length($extensions2_tmp{$ids_tmp})} = $ids_tmp;
                            }
                            elsif (($c2 > $limit || $c2 > $limit2*1.8) && $c2 > 15 && $c2 > 2 && $find_haps_in_seed eq "")
                            {
                                delete $extensions2_tmp{$ids_tmp};
                            }
							elsif ($c2 > $limit2*0.8 && $c2 > 5 && $find_haps_in_seed eq "" && $score_tmp < $max_score/3 && $score_tmp < 0.5)
                            {
                                delete $extensions2_tmp{$ids_tmp};
                            }
                            elsif ($c >= 5 && length($extensions2_tmp{$ids_tmp}) < ($shortest_ext*0.7) && length($extensions2_tmp{$ids_tmp}) < 1000 && $c2 > 2 && $find_haps_in_seed eq "")
                            {   
                                print {$filehandle{$seed_id2}} $ids_tmp." DEL\n";
                                print {$filehandle{$seed_id2}} length($extensions2_tmp{$ids_tmp})." LENGTH\n";
                                delete $extensions2_tmp{$ids_tmp};
                            }
                            elsif ($c < $limit2 || $score_tmp > 0.5*$max_score || $score_tmp > 0.7 || $c2 < 5 || ($count_matches_with_high_scores > $limit2*2 && $c2 < $sequencing_depth_PB*1.5))
                            {
                                $c2++;
                                $length_ext0{length($extensions2_tmp{$ids_tmp})} = $ids_tmp;
                            }
                            else
                            {
                                delete $extensions2_tmp{$ids_tmp};
                            }
                            
                            if ($c < 5 && length($extensions2_tmp{$ids_tmp}) < $shortest_ext && length($extensions2_tmp{$ids_tmp}) ne "")
                            {
                                $shortest_ext = length($extensions2_tmp{$ids_tmp});
                                print {$filehandle{$seed_id2}} $ids_tmp." ID\n";
                                print {$filehandle{$seed_id2}} $shortest_ext." SHORTEST_EXT\n";
                            }
							
							if ($c <= 10)
							{
								$length_ext_10{length($extensions2_tmp{$ids_tmp})} = $ids_tmp;
							}
                            $c++; 
                        }
                    } 
                }                         

#Increase consensus length----------------------------------------------------------------------------------------------------------            

SELECT_LENGTH_PB:
 
                if (exists($cut_repeat_seq{$seed_id}))
                {
                    $length_extension = '3000';
                }
                if ($longer_extension_for_repeat eq "" && $shortest_ext ne '100000000000000')
                {
                    $length_extension = $shortest_ext;
                }

                if ($length_extension < 500)
                {
                    $length_extension = '500';
                }		

                if ($find_haps_in_seed eq "yes")
                {
                    $length_extension = length($read);
                }
				
				my %length_tmp;
				undef %length_tmp;
                my $total_tmp = keys %extensions2_tmp;
                foreach my $ids_tmp (keys %extensions2_tmp)
                {
                    $length_tmp{length($extensions2_tmp{$ids_tmp})} = undef;
                }
                my $count_tmp = '1';
                foreach my $length_ext_tmp (sort {$b <=> $a} keys %length_tmp)
                {
                    if (($count_tmp > 0.75*$total_tmp || $count_tmp > 25) && $count_tmp > 3)
                    {
                        if ($length_ext_tmp > $length_extension && $find_haps_in_seed eq "" && $length_ext_tmp < 10000)
                        {
                            $length_extension = $length_ext_tmp;
                        }
                        last;
                    }
                    $count_tmp++;
                }
				my $count_tmp2 = '1';
				foreach my $length_ext_tmp (sort {$b <=> $a} keys %length_ext_10)
                {
                    if ($count_tmp2 > 6)
                    {
                        if ($length_ext_tmp > $length_extension && $find_haps_in_seed eq "" && $length_ext_tmp < 10000)
                        {
                            $length_extension = $length_ext_tmp;
                        }
                        last;
                    }
                    $count_tmp2++;
                }
				
				if ($length_extension > 6000)
                {
                    $length_extension = '6000';
                }
				
                $length_extension += 550;
				
				if ($count_matches_with_high_scores < 18 && $length_extension > 3800)
				{
					$length_extension = 3500;
				}
				if ($count_matches_with_high_scores < 10 && $length_extension > 2200)
				{
					$length_extension = 2000;
				}
                    
                if ($longer_extension_for_repeat ne "")
                {
                    my $count_tmp3 = '1';
                    foreach my $length_ext_tmp (sort {$b <=> $a} keys %length_tmp)
                    {
                        print {$filehandle{$seed_id2}} $length_ext_tmp." LENGTH_EXTENSION_TMP\n";
						if (($count_tmp3 > 0.25*$total_tmp && $count_tmp3 > 2) || $length_ext_tmp > $longer_extension_for_repeat+10000)
                        {
                            $length_extension = $length_ext_tmp;
                            last;
                        }
                        $count_tmp3++;
                    }
                    if ($length_extension > $longer_extension_for_repeat)
                    {
						$length_extension = $longer_extension_for_repeat
                    } 
                }
				

                print {$filehandle{$seed_id2}} $length_extension." LENGTH_EXTENSION\n";
                
SELECT_LENGTH_PB2a:
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
                if (($add_rejected_reads ne "" || $add_no_match_reads ne "") && $remove_reads_check eq "")
                {
					foreach my $id_tmp1 (keys %add_rej_reads_extra)
                    {
                        if (exists($extensions2_tmp{$id_tmp1}))
						{}
						elsif (exists($long_read_end_pos_save{$id_tmp1}))
						{
							my $long_read_tmp = "";
							if (exists($reverse_list{$id_tmp1}))
							{
								$long_read_tmp = reverse($hash_PB_reads_tmp{$id_tmp1});
								$long_read_tmp =~ tr/ACTG/TGAC/;
							}
							else
							{
								$long_read_tmp = $hash_PB_reads_tmp{$id_tmp1};
							}
							
							my $long_read_end_pos_tmp = $long_read_end_pos_save{$id_tmp1};
							print {$filehandle{$seed_id2}} $id_tmp1." IDD_ADD_REJ\n";
							print {$filehandle{$seed_id2}} $long_read_end_pos_tmp." LONG_READ_END\n";
							my $ext = substr $long_read_tmp, $long_read_end_pos_tmp-90, $length_extension;
							if (exists($scores2{'0'}))
							{
								$scores2{'0'} .= ",$id_tmp1"; 
							}
							else
							{
								$scores2{'0'} = $id_tmp1;
							}
							$extensions2_tmp{$id_tmp1} = $ext;
						}
						else
						{
							print {$filehandle{$seed_id2}} $id_tmp1." DELETE_REJ_ID\n";
							delete $add_rej_reads_extra{$id_tmp1};
							delete $id_matches{$id_tmp1};
							delete $save_alignment_data_PB{$seed_id}{$id_tmp1};
							if ($add_no_match_reads ne "")
							{
								delete $extensions_nomatch2b_saved{$id_tmp1};
							}
						}
                    }
                }        
#------------------------------------------------------------------------------------------------------------------------------
SELECT_LENGTH_PB2:                
                my $extension_part_length = '700';
				my $devide_extension_count = int(($length_extension/$extension_part_length)+0.5);
				#if ($devide_extension_count > $maxProcs)
				#{
					#$devide_extension_count = $maxProcs;
				#}
				if ($devide_extension_count < 1)
				{
					$devide_extension_count = '1';
				}
				my $length_extension_part = int($length_extension/$devide_extension_count);
				my $length_extension_part_extra = '50';
				
				print {$filehandle{$seed_id2}} $length_extension_part." LENGTH_EXTENSION_PART\n";
				
				my $v = '1';
                my %length_ext;
				undef %length_ext;
                my %rank_to_id;
				undef %rank_to_id;
                my %id_to_rank;
				undef %id_to_rank;
                
                foreach my $score_tmp (sort {$b <=> $a} keys %scores2)
                {
                    my @ids_tmp = split /,/, $scores2{$score_tmp};
                    foreach my $ids_tmp (@ids_tmp)
                    {
                        if (exists($extensions2_tmp{$ids_tmp}))
                        {                     
                            my $ext_tmp2 = substr $extensions2_tmp{$ids_tmp}, 0, $length_extension;
							$rank_to_id{$v} = $ids_tmp;
                            $length_ext{$v} = length($ext_tmp2);                        
							$save_reads_for_next{$ids_tmp} = undef;   
                            $id_to_rank{$ids_tmp} = $v;
                            print {$filehandle{$seed_id2}} $v." V ".$ids_tmp." ID ".length($ext_tmp2)." LENGTH\n";
                            $v++;
                        }
                    }
                }
				my $total_nuc_count_original = $v-1;
			
				my $clipped_ext = "";
				my $N = '0';
				my $N_resolved = '0';
				my $mafft_count = "1";
				my $cp_original = "";
				my %track_length_ext_total;
				undef %track_length_ext_total;
				my %SNP_patterns_prev;
				undef %SNP_patterns_prev;
				my %pos_pattern_list;
				undef %pos_pattern_list;
                my %read_patterns2;
				undef %read_patterns2;
                my %read_patterns_final;
				undef %read_patterns_final;
				my $first_split_pos = "";
                my %track_mismatch_ext;
				undef %track_mismatch_ext;
                my $track_mismatch_count = '0';
				my $post_pattern_match = "";
				my $post_pattern_match_count = '1';
				my $post_pattern_match_save = "";
				my $nuc_match = "";
                my $nuc_prev = "";
				my $total_count_prev_patterns = '0';
				my %total_count_prev_patterns;
				undef %total_count_prev_patterns;
				my %quality_scores_tmp;
				undef %quality_scores_tmp;
				
				my %mismatches_tmp;
				undef %mismatches_tmp;
				my %reads_mismatch;
				undef %reads_mismatch;
				my %reads_mismatchb;
				undef %reads_mismatchb;
				my %reads_mismatch2;
				undef %reads_mismatch2;
				my %reads_mismatch2b;
				undef %reads_mismatch2b;
				my %reads_mismatch2_tmp;
				undef %reads_mismatch2_tmp;
				my %reads_mismatch2b_tmp;
				undef %reads_mismatch2b_tmp;
                my $mismatches_tmp_check = "";                     
                my $pos_pattern_list_check = "";
				my $rank_count_check = "";
				my $time_BLAST3b = time;
				my %extensions_seed;
				undef %extensions_seed;
				my %haps_list;
				undef %haps_list;
                my $hap_position = "";
				my %clipped_ext_pos;
				undef %clipped_ext_pos;

MAFFT_PB:               
                my $other_seq = "";
				foreach my $rank_tmp7 (sort {$a <=> $b} keys %rank_to_id)
				{
					if (exists($extensions2_tmp{$rank_to_id{$rank_tmp7}}))
					{                     
						my $start_pos_tmp = 0;
						if ($mafft_count > 1)
						{
							$start_pos_tmp = $track_length_ext_total{$rank_tmp7};
						}
						if ($length_ext{$rank_tmp7} > $start_pos_tmp+350 || $mafft_count eq '1')
						{
							my $ext_tmp2 = substr $extensions2_tmp{$rank_to_id{$rank_tmp7}}, $start_pos_tmp, $length_extension_part+$length_extension_part_extra;
							$other_seq .= ">".$rank_tmp7."\n";
							$other_seq .= $ext_tmp2."\n";
						}
					}
				}
				my $time_mafft1 = time;
					
				my $output_file6  = $TMP_directory."sequence_tmp_".$project."_".$mismatch_retry."_".$mafft_count.".fasta";
			
				open(OUTPUT_LONG1, ">" .$output_file6) or die "\nCan't open file $output_file6, $!\n";
				print OUTPUT_LONG1 $other_seq;
				
				close OUTPUT_LONG1;
				
				chomp($output_file6);
				
				$print_sep = $y."_".$id;

				my $cmd = "";
				
				if ($high_quality eq "yes")
				{
					$high_quality = "yes2";
					print {$filehandle{$seed_id2}} "HIGH_QUALITY_MAFFT\n";
					$cmd = sprintf("mafft --lop 0.0 --lexp 0.1  --thread 4 --quiet --clustalout --maxiterate 100 --globalpair %s > ".$TMP_directory."mafft_tmp_PB_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt", $output_file6);
				}
				elsif (keys %extensions > 2)
				{
					$cmd = sprintf("mafft --op 1 --ep 1.8 --thread 4 --quiet --clustalout --globalpair %s > ".$TMP_directory."mafft_tmp_PB_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt", $output_file6);
				}
				else
				{
					$cmd = sprintf("mafft --op 1.01 --ep 1.2 --thread 4 --quiet --clustalout %s > ".$TMP_directory."mafft_tmp_PB_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt", $output_file6);
				}
				
				my $system_result = syscmd($cmd);                         
				
				my $mafft_output_tmp = $TMP_directory."mafft_tmp_PB_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt";
				#$mafft_output{$mafft_count} = $output_tmp;	
				$mafft_count++;
				
				my $time_maff3 = time;
                my $time_mafft = $time_maff3 - $time_mafft1;
                print {$filehandle{$seed_id2}} $time_mafft." TIME_MAFFT\n\n";
				unlink $output_file6;
 
#merge mafft lines-------------------------------------------------------------------------------             
                
				my $e = '0';
                my $query_line = "";
                my %subject_list;
				undef %subject_list;
                my %subject_list_original;
				undef %subject_list_original;
                my %gaps_id;
				undef %gaps_id;
                my %length_id;
				undef %length_id;
                my $cp = '20';
				my $m_c = '0';
OPEN_MAFFT:				
				if (-s $mafft_output_tmp)
				{
					open(INPUT_BLAST3, $mafft_output_tmp) or print "\n\nCan't open blast file $mafft_output_tmp, $!\n";
	
					while (my $line2 = <INPUT_BLAST3>)
					{                                                     
						chomp($line2);
						if ($e > 2)
						{
							my @blast_result_tmp = split /\s+/, $line2;
							
							my $read_id_tmp = $blast_result_tmp[0];
							
							if (exists($subject_list{$read_id_tmp}))
							{
								my $subject_tmp = $subject_list{$read_id_tmp};
								$subject_list{$read_id_tmp} = $subject_tmp.$blast_result_tmp[1];
							}
							elsif ($read_id_tmp =~ m/\d+/)
							{                                   
								$subject_list{$read_id_tmp} = $blast_result_tmp[1];
							}
							if ($query_line eq "yes")
							{
							}
							elsif ($read_id_tmp eq $total_nuc_count_original)
							{
								$query_line = "yes";
							} 
						}
						$e++
					}
					close INPUT_BLAST3;
				}
				elsif ($m_c < 10)
				{
					$m_c++;
					print {$filehandle{$seed_id2}} time." MAFFT_SLEEP\n\n";
					sleep(0.5);
					goto OPEN_MAFFT;
				}
				else
				{
					print {$filehandle{$seed_id2}} $mafft_output_tmp." MAFFT_ERROR\n\n";
				}

                my %gaps_align;
				undef %gaps_align;
                foreach my $subject_id (keys %subject_list)
                {
                    my $read_tmp = $subject_list{$subject_id};
                    my $o = '0';
                    my $first_nuc = substr $read_tmp, $o, 1;
                    while ($first_nuc eq "-" && $o < 120+($total_nuc_count_original*2))
                    {
                        $o++;
                        $first_nuc = substr $read_tmp, $o, 1;
                    }
                    if (exists($gaps_align{$o}))
                    {
                        my $count_tmp = $gaps_align{$o};
                        $gaps_align{$o} = $count_tmp+1;
                    }
                    else
                    {
                        $gaps_align{$o} = '1';
                    } 
                }
                my $count_align = keys %subject_list;
                my $oo = '1';
                my $cut_gap = '1';
                foreach my $gap_length (sort {$a <=> $b} keys %gaps_align)
                {
                    $oo += $gaps_align{$gap_length};
                    if ($oo > 0.45*$count_align)
                    {
                        $cut_gap = $gap_length;
                        last;
                    }                 
                }
                if ($cut_gap > $cp)
                {
                    $cp = $cut_gap;
                }
				if ($mafft_count > 2)
				{
					$cp = '0';
				}
				else
				{
					$cp_original = $cp;
				}
                print {$filehandle{$seed_id2}} $cp." SKIP_LENGTH\n";
                
                my $too_much_gaps = '0';
                foreach my $subject_id (keys %subject_list)
                {
                    my $read_tmp = $subject_list{$subject_id};
                    my $last_20 = substr $read_tmp, -20;
                    my $gaps_20 = $last_20 =~ tr/-/-/;
                    while ($gaps_20 > 15)
                    {
                        substr $read_tmp, -20, 20, "";
                        $last_20 = substr $read_tmp, -20;
                        $gaps_20 = $last_20 =~ tr/-/-/;
                    }
                    
                    my $last_nuc = substr $read_tmp, -1;
                    while ($last_nuc eq "-")
                    {
                        chop($read_tmp);
                        $last_nuc = substr $read_tmp, -1;
                    }
                    $subject_list{$subject_id} = $read_tmp;

                    my $gaps_tmp = $read_tmp =~ tr/-/-/;
                    $gaps_id{$subject_id} = $gaps_tmp;
                    $length_id{$subject_id} = length($read_tmp);
                    
                    #if ($gaps_tmp > 0.10*length($read_tmp))
                    #{
                        #$too_much_gaps++;
                    #}
                    #if ($too_much_gaps > 0.2*$matches_count && $mafft_extra_quality eq "")
                    #{
                        #$mafft_extra_quality = "yes";
                        #print {$filehandle{$seed_id2}} "TOO_MANY_GAPS_MAFFT_EXTRA_QUALITY\n";
                        #goto MAFFT_PB;
                    #}
                }
				unlink $mafft_output_tmp;
#--------------------------------------------------------------------------------------------------                                
                foreach my $subject_rank (keys %subject_list)
                {
                    $subject_list_original{$subject_rank} = $subject_list{$subject_rank};
                }
                my %ignore_reads;
				undef %ignore_reads;
IGNORE_REMOVED_READS_PB:

                my $ignored_reads_count = keys %ignore_reads;
				
				if (keys %ignore_reads > 0)
                {
                    undef %subject_list;
                    print {$filehandle{$seed_id2}} $ignored_reads_count." IGNORE_COUNT\n";
                    foreach my $subject_rank (keys %subject_list_original)
                    {
                        if (exists($ignore_reads{$subject_rank}))
                        {
                            print {$filehandle{$seed_id2}} $subject_rank." REMOVE_READ\n";
                            delete $subject_list_original{$subject_rank};
                        }
                        else
                        {
                            $subject_list{$subject_rank} = $subject_list_original{$subject_rank};
                        }
                    }
                    $cp = $cp_original;
					if ($mafft_count > 2)
					{
						$cp = '0';
					}
                }
                
				if ($mafft_count < 3)
				{
					$clipped_ext = "";
					$N = '0';
				}

                my $best_extension_part = "";
                my %nucs;
				undef %nucs;
                my %nucs_rej;
				undef %nucs_rej;

                my $total_nuc_count = '0';
                my $total_nuc_count_rej = '0';
				my $local_pattern_matches2 = '0';
				
                my $nuc1 = "";
				$unresolvable_PB = "";
				$split_contigs_PB = "";
				my %split_contigs_num;
				undef %split_contigs_num;

                my $only_2_reads = "";
                if (keys %extensions2_tmp eq '2' && keys %subject_list eq '2')
                {
                    $only_2_reads = "yes";
                    print {$filehandle{$seed_id2}} "ONLY_2_READS\n";
                }
				if (keys %extensions2_tmp < 4 && $full_reset_PB eq "")
				{
					delete $exclude_reads_PB{$id};
					delete $save_alignment_data_PB{$id};
					delete $rejected_alignment_data_PB{$id};
					$full_reset_PB = "A";
					print {$filehandle{$seed_id2}} $best_extension." FULL_RESET\n";
					$best_extension = "";
					$seed_id = $id;
					$y++;
					$y{$id} = $y;
					goto FULL_RESET;
				}
                my %track_length_ext;
				undef %track_length_ext;
				my $end_this_mafft_part = "";
					
				if ($mafft_count < 3)
				{
					foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
					{				
						my $seq_rank1c = substr $subject_list{$subject_rank}, 0, $cp;
						$seq_rank1c =~ tr/-//d;
						$track_length_ext{$subject_rank} = length($seq_rank1c);
					}
				}
                
                my $time_BLAST3 = time;
                my $time9 = $time_BLAST3 - $time_maff3;
                print {$filehandle{$seed_id2}} $time9." TIME_pre_CONS\n\n";
				my $loop_check = "";
				my $switch_ONT_SNP = "";

            
INPUT_MAFFT3_PB: while ((keys %subject_list > 2 || $only_2_reads eq "yes") && ((keys %subject_list > 0.75*($total_nuc_count_original-$ignored_reads_count) && keys %subject_list > 5)
                        || keys %subject_list > ($total_nuc_count_original-1-$ignored_reads_count) || $clipped_ext ne "yes"
                        || (keys %subject_list > 0.3*($total_nuc_count_original-$ignored_reads_count) && $longer_extension_for_repeat ne "" && keys %subject_list > 2))
                         && ($end_this_mafft_part eq "" || length($best_extension_part) < $length_extension_part-50))
                { 
                    my $time_CONS_LOOP_START = time;
					$loop_check = "yes";
#clip_extension-------------------------------------------------------------------------------------------                                
                    #my $ext_remove = "";
					if ($clipped_ext eq "")
					{
						$clipped_ext_pos{length($best_extension)} = $cp;
					}
                    if (length($best_extension) > 10 && $clipped_ext eq "" && $find_haps_in_seed ne "yes")
                    {
                        my $check_start_assembly = substr $read, -length($best_extension), length($best_extension);
                        my $check_start_assembly2 = substr $read, -150;
                        my $check_start_assembly3 = $check_start_assembly2 =~ m/$check_start_assembly/;
                        if ($check_start_assembly3 > 1)
                        {
                            print {$filehandle{$seed_id2}} $check_start_assembly3." CLIP_ALERT\n";
                            goto SWITCH_CLIP_PB;
                        }
                        if ($check_start_assembly eq $best_extension)
                        {
                            $clipped_ext = "yes";
                        }
                        else
                        {
                            my $best_extension_tmp = $best_extension;
                            my $check_N = $best_extension_tmp =~ tr/N|\./\./;
                            my $check_N2 = $check_start_assembly =~ tr/N|\./\./;
                            if (($check_N > 0 || $check_N2 > 0) && $check_N < length($best_extension_tmp)*0.4 && $check_N2 < length($check_start_assembly)*0.4)
                            {
                                my $check_again = $check_start_assembly =~ s/$best_extension_tmp//;
                                my $check_again2 = $best_extension_tmp =~ s/$check_start_assembly//;
                                if ($check_again > 0 || $check_again2 > 0)
                                {
                                    $best_extension = "";
                                    $clipped_ext = "yes";
                                }
                            }
                        }
                        if ($clipped_ext eq "yes")
                        {
                            $best_extension = "";
                            $N = '0';
                            undef %SNP_patterns_prev;
                            undef %extensions_seed;
                            undef %quality_scores_tmp;
                            undef %extensions_seed;
							undef %total_count_prev_patterns;
                            $total_count_prev_patterns = '0';
                        }
                    }
                    
                    if (length($best_extension) > 110 && $clipped_ext eq "" && $find_haps_in_seed ne "yes")
                    {
                        my $m = '15';
						my $best_extension_tmp_length = length($best_extension);
                        while ($m < length($best_extension)-10 && $clipped_ext eq "")
                        {
                            my $check_start_assembly = substr $read, -$m, 15;
                            $check_start_assembly =~ tr/N|\./\./;
                            my $best_extension_tmp = $best_extension;
                            my $check_15 = $best_extension_tmp =~ s/$check_start_assembly//;
                            if ($check_15 eq 1)
                            {
                                print {$filehandle{$seed_id2}} $best_extension." BEST_EXT\n";
                                if ($best_extension =~ m/(.*$check_start_assembly)(.*)/)
                                {
                                    $best_extension = $2;
                                    my $best_extension_tmp = substr $best_extension, 0, $m-15+3;
                                    my $best_extension_tmp2 = substr $best_extension, $m-15+3;
                                    my $m2 = '14';
                                    my $matched = "";
                                    while ($m2 > 5 && $matched eq "" && $m > 15)
                                    {
                                        my $check_start_assembly2 = substr $read, -$m2, $m2;
                                        if ($best_extension_tmp =~ m/(.*$check_start_assembly2)(.*)/)
                                        {
                                            $best_extension = $2;
                                            $best_extension .= $best_extension_tmp2;
                                            $matched = "yes";
                                            last
                                        }
                                        $m2--;
                                    }
                                    if ($matched ne "yes" && $m > 15)
                                    {
                                        substr $best_extension, 0, $m-15, "";
                                    }
                                }

                                print {$filehandle{$seed_id2}} $m." M\n";
                                print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_CHOPPED\n";
                                my $diff_tmp = $best_extension_tmp_length-length($best_extension);
                                $clipped_ext = "yes";
								$cp = $clipped_ext_pos{$diff_tmp};
								foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
								{				
									my $seq_rank1c = substr $subject_list{$subject_rank}, 0, $cp;
									$seq_rank1c =~ tr/-//d;
									$track_length_ext{$subject_rank} = length($seq_rank1c);
								}
                            }
                            $m++;
                        }
                        if ($clipped_ext eq "yes")
                        {
							$best_extension = "";
                            $N = '0';
                            undef %SNP_patterns_prev;
                            undef %extensions_seed;
                            undef %quality_scores_tmp;
                            undef %extensions_seed;
							undef %total_count_prev_patterns;
                            $total_count_prev_patterns = '0';
							
							if ($find_haps_in_seed ne "")
							{
								$extensions_seed{'HAP1'} = $best_extension;
								$extensions_seed{'HAP2'} = $best_extension;
							}
                        }
                    }
#-------------------------------------------------------------------------------------------------------
SWITCH_CLIP_PB:                   
                    undef %nucs;
                    undef %nucs_rej;
                    $total_nuc_count = '0';
                    $total_nuc_count_rej = '0';
                    $nuc1 = "";
                    my %track_mismatch_ext0;
					undef %track_mismatch_ext0;
                    $track_mismatch_count++;
					$nucs{'a'} = '0';
					$nucs{'c'} = '0';
					$nucs{'t'} = '0';
					$nucs{'g'} = '0';
					$nucs{"-"} = '0';
					my $nuc_top10 = "";
					my %nucs_by_rank;
					undef %nucs_by_rank;
					my %split_patterns_final_score;
					undef %split_patterns_final_score;
					my $lowest_longest_match = "";
                    
					foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
                    {
                        my $nuc = substr $subject_list{$subject_rank}, $cp, 1;
						$nucs_by_rank{$subject_rank} = $nuc;
                        
                        if (($add_rejected_reads ne "" && $subject_rank > $add_rejected_reads) || ($add_no_match_reads ne "" && $subject_rank > $add_no_match_reads))
                        {
                            $nucs_rej{$nuc} += 1;
                            $total_nuc_count_rej++;

							if (exists($track_mismatch_ext0{$nuc}))
							{
								$track_mismatch_ext0{$nuc} .= ",".$subject_rank;
							}
							else
							{
								$track_mismatch_ext0{$nuc} = $subject_rank;
							}
                        }
                        else
                        {
                            $nucs{$nuc} += 1;
                            $total_nuc_count++;
							if ($nuc_top10 eq "")
							{
								$nuc_top10 = $nuc;
							}
							elsif ($subject_rank < 11 && $nuc_top10 ne $nuc)
							{
								$nuc_top10 = "no";
							}
                        }
                        
                        if ($nuc ne "-")
                        {
                            $track_length_ext{$subject_rank} += 1;
                        }
						
						my $first_rank_tmp2 = "1";
						foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
						{
							$first_rank_tmp2 = $rank_tmp;
							last;
						}
                        
                        if ($subject_rank eq $first_rank_tmp2)
                        {
							$nuc1 = $nuc;
                            my $length_rank1_tmp = $track_length_ext_total{$subject_rank}+$track_length_ext{$subject_rank};
                            my $posiie = length($best_extension)+$position;
                            if (exists($split_positions_DUP_tmp{$length_rank1_tmp}))
                            {
                                print {$filehandle{$seed_id2}} $seed_id."\t".$posiie."\t".$length_rank1_tmp."\t".$split_positions_DUP_tmp{$length_rank1_tmp}." DUP_POS_TMP\n";
                                $split_positions_DUP{$seed_id}{$posiie} = $split_positions_DUP_tmp{$length_rank1_tmp};
								$split_positions_DUP2{$seed_id}{$posiie} = $split_positions_DUP_tmp2{$length_rank1_tmp};
								my $read_end_tmpi = substr $best_extension, -$overlap;
								my $selected_nuc_tmp = $split_positions_DUP_tmp2{$length_rank1_tmp};
								$selected_nuc_tmp =~ tr/actgn/ACTGN/;
								$split_positions_DUP{$seed_id}{$posiie} = $read_end_tmpi;
								$split_positions_DUP2{$seed_id}{$posiie} = $selected_nuc_tmp;
                            }
                        }                      
                    }
                    if ($total_nuc_count < $rank_count_check && $mismatches_tmp_check ne "")
					{
						$mismatches_tmp_check = "";                     
						$pos_pattern_list_check = "";
					}
#Remove rejected reads that don't align well----------------------------------------------------------------------------------------                    
                    if (($add_rejected_reads ne "" || $add_no_match_reads ne "") && length($best_extension) > 350)
                    #if ($add_rejected_reads eq "sghsh")
                    {
                        my $removed_reads = '0';
                        foreach my $nuc_5 (sort {$a <=> $b} keys %track_mismatch_ext0)
                        {
                            if ($nucs{$nuc_5} < $total_nuc_count*0.1)
                            {
                                my @track_mismatch_ext0 = split /,/, $track_mismatch_ext0{$nuc_5};
                                foreach my $rank_5 (@track_mismatch_ext0)
                                {
                                    #$track_mismatch_ext{$rank_5}{$track_mismatch_count} += 1;
                                    push @{ $track_mismatch_ext{$rank_5} }, $track_mismatch_count;
                                    my @rank_array = @{ $track_mismatch_ext{$rank_5} };
                                    my $array_count_tmp = @rank_array;
                                    my $threshold_tmp = 0.35*350;
                                    my $threshold_tmp_round = sprintf "%.0f", $threshold_tmp;
                                    
                                    if ($array_count_tmp > $threshold_tmp_round && $rank_array[$array_count_tmp-$threshold_tmp_round] > $track_mismatch_count-350)
                                    {
                                        foreach my $rank_6 (keys %track_mismatch_ext)
                                        {
                                            my @rank_array2 = @{ $track_mismatch_ext{$rank_6} };
                                            my $array_count_tmp2 = @rank_array2;
                                            my $threshold_tmp2 = 0.35*320;
                                            my $threshold_tmp_round2 = sprintf "%.0f", $threshold_tmp2;
                                            
                                            if ($array_count_tmp2 > $threshold_tmp_round2 && $rank_array2[$array_count_tmp2-$threshold_tmp_round2] > $track_mismatch_count-320)
                                            {
                                                $removed_reads++;
                                                $ignore_reads{$rank_6} = undef;
                                                my $id_tmp0 = $rank_to_id{$rank_6};
                                                delete $extensions2_tmp{$id_tmp0};
                                                delete $extensions{$extensions2{$id_tmp0}};
                                                delete $extensions2{$id_tmp0};
                                                delete $extensions_nomatch{$extensions2{$id_tmp0}};
                                                delete $extensions_nomatch2{$id_tmp0};
                                                delete $extensions_unknown{$extensions2{$id_tmp0}};
                                                delete $extensions_unknown2{$id_tmp0};
                                                delete $save_reads_for_next{$id_tmp0};
                                                delete $add_rej_reads_extra{$id_tmp0};
                                                delete $read_start_pos_rej{$id_tmp0};
												delete $rejected_reads_save{$id_tmp0};
                                                $ext2_count = keys %extensions2_tmp;                          
                                            }
                                        }
                                    }
                                }
                            }                           
                        }
                        if ($removed_reads > 0)
                        {  						
							$best_extension = "";
							$best_extension_part = "";
                            $mismatch_retry++;
                            undef %quality_scores_tmp;
                            my $ignore_count_tmp = keys %ignore_reads;
                            
                            foreach my $rank_7 (keys %ignore_reads)
                            {
                                my $id_tmp0 = $rank_to_id{$rank_7};
                                delete $extensions2_tmp{$id_tmp0};
                                delete $extensions{$extensions2{$id_tmp0}};
                                delete $extensions2{$id_tmp0};
                                delete $extensions_nomatch{$extensions2{$id_tmp0}};
                                delete $extensions_nomatch2{$id_tmp0};
                                delete $extensions_unknown{$extensions2{$id_tmp0}};
                                delete $extensions_unknown2{$id_tmp0};
                                delete $save_reads_for_next{$id_tmp0};
                                delete $add_rej_reads_extra{$id_tmp0};
                                delete $read_start_pos_rej{$id_tmp0};
								delete $rejected_reads_save{$id_tmp0};
                                $ext2_count = keys %extensions2_tmp;
                            }
                            if ($removed_reads eq '1000000000000000000000000000000' && $ignore_count_tmp eq '1')
                            {
                                print {$filehandle{$seed_id2}} "REMOVE_BAD_ALIGNMENTS_REJ\n";                     
                                goto IGNORE_REMOVED_READS_PB;
                            }
                            print {$filehandle{$seed_id2}} $removed_reads." REMOVE_BAD_ALIGNMENTS_REJ2\n";
                            goto MISMATCH_RETRY_PB;
                        }
                    }
#Check SNR ahead-------------------------------------------------------------------------------------------------------                   
                    $SNR_read_ahead = "";
					if ($nucs{"-"} < $total_nuc_count*0.86 && $nucs{"a"} < $total_nuc_count*0.86 && $nucs{"c"} < $total_nuc_count*0.86 && $nucs{"t"} < $total_nuc_count*0.86 && $nucs{"g"} < $total_nuc_count*0.86)
                    {
                        my $count_SNR = '0';
						my $count_SNR2 = '0';
                        foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
                        {
                            my $p = '1';
                            my $p2 = '0';
							my %nucs_SNR;
							undef %nucs_SNR;
                            while ($p2 < 6 && $p < 30)
                            {
                                my $nuc2 = substr $subject_list{$subject_rank}, $cp+$p, 1;
                                if ($nuc2 ne "-")
                                {
                                    $nucs_SNR{$nuc2} += 1;
									$p2++;
                                }
                                $p++;
                            }
							foreach my $nuc_SNR_tmp (keys %nucs_SNR)
							{
								if ($nucs_SNR{$nuc_SNR_tmp} > 4)
								{
									$count_SNR++;
								}
							}
							if ($subject_rank < 4)
							{
								my $next_15 = substr $subject_list{$subject_rank}, $cp+1, 15;
								my $AT_rich_tmp = AT_rich_test ($next_15, '3');
								if ($AT_rich_tmp eq "yes")
								{
									$count_SNR2++;
								}
							}
                        }
                        if ($count_SNR > $total_nuc_count*0.7 || $count_SNR2 > 1)
                        {
                            $SNR_read_ahead = "yes";
                        }
						elsif (length($best_extension) > 25)
						{
							my $prev_25 = substr $best_extension, -25, 25;
							my $AT_rich_tmp = AT_rich_test ($prev_25, '5');
							if ($AT_rich_tmp eq "yes")
							{
								$SNR_read_ahead = "yes";
							}
						}
                    }

                    if ($nucs{"a"} > $total_nuc_count*0.85 || ($nucs{"a"} > $total_nuc_count*0.49 && $only_2_reads eq "yes" && ($nuc1 eq 'a' || $nuc1 eq "-")) || ($nucs{"a"} > $total_nuc_count*0.7
					   && (($nucs{"c"} < 3  && $nucs{"g"} < 3  && $nucs{"t"} < 3  && $nucs{"-"} < 3 && $total_nuc_count > 10) || ($nucs{"c"} < 2  && $nucs{"g"} < 2  && $nucs{"t"} < 2  && $nucs{"-"} < 2 && $total_nuc_count > 4))))
                    {
                        $best_extension .= "A";
						$best_extension_part .= "A";
						$quality_scores_tmp{length($best_extension)} = $nucs{"a"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        $nuc_match = "A";
                        goto SKIP_INPUT_BLAST3_PB;
                    }
                    elsif ($nucs{"c"} > $total_nuc_count*0.85 || ($nucs{"c"} > $total_nuc_count*0.49 && $only_2_reads eq "yes" && ($nuc1 eq 'c' || $nuc1 eq "-")) || ($nucs{"c"} > $total_nuc_count*0.7
					   && (($nucs{"a"} < 3  && $nucs{"g"} < 3  && $nucs{"t"} < 3  && $nucs{"-"} < 3 && $total_nuc_count > 10) || ($nucs{"a"} < 2  && $nucs{"g"} < 2  && $nucs{"t"} < 2  && $nucs{"-"} < 2 && $total_nuc_count > 4))))
                    {
                        $best_extension .= "C";
						$best_extension_part .= "C";
                        $quality_scores_tmp{length($best_extension)} = $nucs{"c"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        $nuc_match = "C";
                        goto SKIP_INPUT_BLAST3_PB;
                    }
                    elsif ($nucs{"t"} > $total_nuc_count*0.85 || ($nucs{"t"} > $total_nuc_count*0.49 && $only_2_reads eq "yes" && ($nuc1 eq 't' || $nuc1 eq "-")) || ($nucs{"t"} > $total_nuc_count*0.7
					    && (($nucs{"c"} < 3  && $nucs{"g"} < 3  && $nucs{"a"} < 3  && $nucs{"-"} < 3 && $total_nuc_count > 10) || ($nucs{"c"} < 2  && $nucs{"g"} < 2  && $nucs{"a"} < 2  && $nucs{"-"} < 2 && $total_nuc_count > 4))))
                    {
                        $best_extension .= "T";
						$best_extension_part .= "T";
                        $quality_scores_tmp{length($best_extension)} = $nucs{"t"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        $nuc_match = "T";
                        goto SKIP_INPUT_BLAST3_PB;
                    }
                    elsif ($nucs{"g"} > $total_nuc_count*0.85 || ($nucs{"g"} > $total_nuc_count*0.49 && $only_2_reads eq "yes" && ($nuc1 eq 'g' || $nuc1 eq "-")) || ($nucs{"g"} > $total_nuc_count*0.7
					    && (($nucs{"c"} < 3  && $nucs{"a"} < 3  && $nucs{"t"} < 3  && $nucs{"-"} < 3 && $total_nuc_count > 10) || ($nucs{"c"} < 2  && $nucs{"a"} < 2  && $nucs{"t"} < 2  && $nucs{"-"} < 2 && $total_nuc_count > 4))))
                    {
                        $best_extension .= "G";
						$best_extension_part .= "G";
                        $quality_scores_tmp{length($best_extension)} = $nucs{"g"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        $nuc_match = "G";
                        goto SKIP_INPUT_BLAST3_PB;
                    }
                    elsif ($nucs{"-"} > $total_nuc_count*0.85 || ($nucs{"-"} > $total_nuc_count*0.7 && $nucs{"c"}+$nucs{"g"}+$nucs{"t"}+$nucs{"a"} < 2) || ($nucs{"-"} > $total_nuc_count*0.7
					    && (($nucs{"c"} < 3  && $nucs{"g"} < 3  && $nucs{"t"} < 3  && $nucs{"a"} < 3 && $total_nuc_count > 10) || ($nucs{"c"} < 2  && $nucs{"g"} < 2  && $nucs{"t"} < 2  && $nucs{"a"} < 2 && $total_nuc_count > 4))))
                    {
                         $nuc_match = "";
                         goto SKIP_INPUT_BLAST3_PB;
                    }
#Find haps in seed sequence--------------------------------------------------------------------------------------------------------------------                                                            
                    if ($find_haps_in_seed ne "" && ($nucs{"-"} < 0.05*$total_nuc_count_original || $SNR_read_ahead eq ""))
                    {
                        my $count_split = '0';     
                        foreach my $nuci (keys %nucs)
                        {                        
                            if ($nucs{$nuci} > 0.33*$total_nuc_count)
                            {
                                $count_split++;
                            }
                        }
                        if ($count_split > 1)
                        {
                            my %nucs_tmp;
							undef %nucs_tmp;
                            my $total_nuc_count_tmp = '0';
                            foreach my $ext_line_tmp2 (sort {$a <=> $b} keys %subject_list)
                            {                         
                                my $nuc_tmp = substr $subject_list{$ext_line_tmp2}, $cp+1, 1;
                                $nucs_tmp{$nuc_tmp} += 1;
                                $total_nuc_count_tmp++;
                            }
                            my $q_check = "";
                            foreach my $nuci (keys %nucs_tmp)
                            {
                                if ($nucs_tmp{$nuci} > 0.93*$total_nuc_count_tmp)
                                {
                                    $q_check = "yes";
                                }
                            }
                            if ($q_check eq "yes")
                            {
                                print {$filehandle{$seed_id2}} $nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
#Split into haplotype groups----------------------------------------------------------------------                                                                                 

                                my %separate_haps_PB;
								undef %separate_haps_PB;
                                
                                foreach my $ext_line_tmp (sort {$a <=> $b} keys %subject_list)
                                {
                                    if (exists($rank_to_id{$ext_line_tmp}))
                                    {
                                        my $nuc_tmp = substr $subject_list{$ext_line_tmp}, $cp, 1;
                                        if (exists($separate_haps_PB{$nuc_tmp}))
                                        {                  
                                            $separate_haps_PB{$nuc_tmp} .= ",".$ext_line_tmp;
                                        }
                                        else
                                        {
                                            $separate_haps_PB{$nuc_tmp} = $ext_line_tmp;
                                        }
                                    }
                                }
                                my %nuc_haps;
                                undef %nuc_haps;
                                my $count_haps = '0';
                                
                                foreach my $nuc_tmp (keys %separate_haps_PB)
                                {
                                    my @list_ranks = split /,/, $separate_haps_PB{$nuc_tmp};
                                    if (@list_ranks > 0.26*($total_nuc_count_original) && @list_ranks > 1)
                                    {
                                        print {$filehandle{$seed_id2}} $nuc_tmp." NUCIE\n";
                                        print {$filehandle{$seed_id2}} $separate_haps_PB{$nuc_tmp}." READ_IDS\n";
                                        #$nuc_tmp =~ tr/actgn/ACTGN/;
                                        $nuc_haps{$nuc_tmp} = $separate_haps_PB{$nuc_tmp};
                                        $count_haps++;
                                    }
                                }
                                if ($count_haps eq '2')
                                {
                                    $found_haps_in_seed = "yes";
                                    my $hh = '0';
                                    my $second_var = "";
                                    foreach my $nucie_tmp (keys %nuc_haps)
                                    {
                                        my $nucie_tmp2 = $nucie_tmp;
                                        $nucie_tmp2 =~ tr/actgn/ACTGN/;
                                        $nucie_tmp2 =~ tr/-//d;
                                        my $bb = keys %haps_list;

                                        if ($bb > 0 && ($hh eq '0' || $second_var eq "yes"))
                                        {
                                            print {$filehandle{$seed_id2}} $bb." HPAS_LIST\n";
                                            $second_var = "yes";
                                            
                                            my @list_ranks = split /,/, $nuc_haps{$nucie_tmp};
                                            my $HAP1_count = '0';
                                            my $HAP2_count = '0';
                                            foreach my $list_tmp (@list_ranks)
                                            {
                                                if ($haps_list{$list_tmp} eq "HAP1")
                                                {
                                                    $HAP1_count++;
                                                }
                                                elsif ($haps_list{$list_tmp} eq "HAP2")
                                                {
                                                    $HAP2_count++;
                                                }
                                            }
                                            if ($HAP1_count > $HAP2_count)
                                            {
                                                #my $read_end_tmpi = substr $extensions_seed{"HAP1"}, -$overlap, $overlap;  
                                                #$split_positions{$id."_HAP1"}{$position+length($best_extension)} = $read_end_tmpi.",".$nucie_tmp;
                                                #print OUTPUT18 $id."_HAP1\t".$position+length($best_extension)."\t".$read_end_tmpi.",".$nucie_tmp."\n";
                                                $extensions_seed{"HAP1"} .= $nucie_tmp2;
                                            }
                                            elsif ($HAP2_count > $HAP1_count)
                                            {  
                                                #my $read_end_tmpi = substr $extensions_seed{"HAP2"}, -$overlap, $overlap;
                                                #$split_positions{$id."_HAP2"}{$position+length($best_extension)} = $read_end_tmpi.",".$nucie_tmp;
                                                #print OUTPUT18 $id."_HAP2\t".$position+length($best_extension)."\t".$read_end_tmpi.",".$nucie_tmp."\n";
                                                $extensions_seed{"HAP2"} .= $nucie_tmp2;
                                            }
                                        }
                                        elsif ($hh eq '0')
                                        {
                                            $extensions_seed{"HAP1"} .= $nucie_tmp2;
                                            my @list_ranks = split /,/, $nuc_haps{$nucie_tmp};
                                            foreach my $list_tmp (@list_ranks)
                                            {
                                                $haps_list{$list_tmp} = "HAP1";
                                            }
                                            my $read_end_tmpi = substr $best_extension, -$overlap, $overlap;
                                            print {$filehandle{$seed_id2}} $read_end_tmpi." READ_END\n";
                                            #my $pos_tmp = $position+length($best_extension);
                                            #$split_positions{$id."_HAP1"}{$pos_tmp} = $read_end_tmpi.",".$nucie_tmp;
                                            #print OUTPUT18 $id."_HAP1"."\t".$pos_tmp."\t".$read_end_tmpi.",".$nucie_tmp."\n";
                                        }
                                        else
                                        {
                                            $extensions_seed{"HAP2"} .= $nucie_tmp2;
                                            my @list_ranks = split /,/, $nuc_haps{$nucie_tmp};
                                            foreach my $list_tmp (@list_ranks)
                                            {
                                                $haps_list{$list_tmp} = "HAP2";
                                            }
                                            #my $read_end_tmpi = substr $best_extension, -$overlap, $overlap;
                                            #my $pos_tmp = $position+length($best_extension);
                                            #$split_positions{$id."_HAP2"}{$pos_tmp} = $read_end_tmpi.",".$nucie_tmp;
                                            #print OUTPUT18 $id."_HAP2"."\t".$pos_tmp."\t".$read_end_tmpi.",".$nucie_tmp."\n";
                                        }
                                        $hh++;
                                    }
                                    $hap_position = "yes";
                                }   
#------------------------------------------------------------------------------------------------       
                            }
                        }
                        $N++;
                        $best_extension .= "N";
                        $quality_scores_tmp{length($best_extension)} = '0';
                        $nuc_match = "N";
                        goto SKIP_INPUT_BLAST3_PB;
                    }
#Remove_by_prev_split-----------------------------------------------------------------------------------------------                                                           					
					my $posiie0 = length($best_extension)+$position;
					my $first_rank_tmp2 = "1";
					foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
					{
						$first_rank_tmp2 = $rank_tmp;
						last;
					}
					my $pos_tmp2c = $track_length_ext_total{$first_rank_tmp2}+$track_length_ext{$first_rank_tmp2};
					if ((exists($split_positions_DUP{$seed_id}{$posiie0}) || exists($split_positions_DUP_tmp{$pos_tmp2c})) && $add_rejected_reads eq "" && $add_no_match_reads eq "")
					{
						my $selected_nuc_tmp = "";
						if (exists($split_positions_DUP2{$posiie0}))
						{
							$selected_nuc_tmp = $split_positions_DUP2{$posiie0};
						}
						elsif (exists($split_positions_DUP_tmp2{$pos_tmp2c}))
						{
							$selected_nuc_tmp = $split_positions_DUP_tmp2{$pos_tmp2c};
						}
						print {$filehandle{$seed_id2}}  $selected_nuc_tmp." REMOVE_BY_DUP_POS00\n";
						
						if ($nucs{$selected_nuc_tmp} > 0.25*$total_nuc_count && $nucs{$selected_nuc_tmp} < $total_nuc_count*0.92)
						{
							foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
							{
								my $nuc_tmp = $nucs_by_rank{$rank_tmp};
								if ($nuc_tmp ne $selected_nuc_tmp)
								{
									my $id_tmp0 = $rank_to_id{$rank_tmp};
									delete $extensions{$extensions2{$id_tmp0}};
									delete $extensions2{$id_tmp0};
									delete $extensions2b{$id_tmp0};
									delete $extensions2_tmp{$id_tmp0};
									delete $extensions_nomatch{$extensions2{$id_tmp0}};
									delete $extensions_nomatch2{$id_tmp0};
									delete $extensions_nomatch2b{$id_tmp0};
									delete $extensions_unknown{$extensions2{$id_tmp0}};
									delete $extensions_unknown2{$id_tmp0};
									delete $save_reads_for_next{$id_tmp0};
									delete $add_rej_reads_extra{$id_tmp0};
									delete $read_start_pos_rej{$id_tmp0};
									$ext2_count = keys %extensions2_tmp;
								}
							}
							 print {$filehandle{$seed_id2}} $best_extension."\nREMOVE_BY_DUP_POS\n";
													
							$mismatch_retry++;
							$best_extension = "";
							$best_extension_part = "";
							undef %quality_scores_tmp;
							goto MISMATCH_RETRY_PB;
						}
					}
                    
					my $trace_back_check = "";
					my $find_haps_in_seed_check = "";
					if ($find_haps_in_seed ne "" && ($nucs{"a"}+$nucs{"-"} > $total_nuc_count*0.8 || $nucs{"c"}+$nucs{"-"} > $total_nuc_count*0.8 || $nucs{"t"}+$nucs{"-"} > $total_nuc_count*0.8
						|| $nucs{"g"}+$nucs{"-"} > $total_nuc_count*0.8) && ($nucs{"-"} < $total_nuc_count*0.3 || $nucs{"-"} > $total_nuc_count*0.8))
					{
						$find_haps_in_seed_check = "no";
					}

                    if (($clipped_ext ne "yes" || $best_extension eq "" || length($best_extension) < 300 || ($SNR_read_ahead ne "" && $N < 4)
                         || $N < 5 || $N < length($best_extension)*0.04 || ($longer_extension_for_repeat ne "" && $N < length($best_extension)*0.15))
						&& $total_nuc_count > 1 && $find_haps_in_seed_check eq "" && $found_haps_in_seed eq "")
                    {
#Split into haplotype groups----------------------------------------------------------------------                                                           
                        my %separate_haps_PB;
						undef %separate_haps_PB;
print {$filehandle{$seed_id2}} "\n".length($best_extension)." SEP_HAP\n";
print {$filehandle{$seed_id2}} $nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                        my %SNP_patterns_now;
						undef %SNP_patterns_now;
                        my %SNP_patterns_prev2;
						undef %SNP_patterns_prev2;
						my %SNP_patterns_prev_match;
						undef %SNP_patterns_prev_match;
						my $exclude_reads_check = "";
                        my $current_pos_tmp = $position+length($best_extension);
						$total_count_prev_patterns{length($best_extension)} = undef;

                        my $first_rank = "";
                        foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
                        {
                            my $nuc_tmp = $nucs_by_rank{$rank_tmp};
                            $SNP_patterns_prev{$current_pos_tmp}{$nuc_tmp}{$rank_tmp} = $cp;
                            $SNP_patterns_now{$nuc_tmp}{$rank_tmp} = undef;
                            if ($first_rank eq "")
                            {
                                $first_rank = $nuc_tmp;
                            }
                            #print {$filehandle{$seed_id2}} $rank_tmp." ".$nuc_tmp."\n";
                            
                            if (exists($separate_haps_PB{$nuc_tmp}))
                            {                  
                                my $c_tmp = $separate_haps_PB{$nuc_tmp};
                                $separate_haps_PB{$nuc_tmp} = $c_tmp+1;      
                            }
                            else
                            {
                                $separate_haps_PB{$nuc_tmp} = 1;                          
                            }  
                        }
                        my $SNP_check = "";
                        if ($nucs{"-"} < $total_nuc_count*0.13)
                        {
                            $SNP_check = "yes";
                            my $count_nucs = '0';
                            foreach my $nuc_tmp1 (keys %nucs)
                            {
                                if ($nuc_tmp1 ne "-" && $nucs{$nuc_tmp1} > 2 && $nucs{$nuc_tmp1} >= $total_nuc_count*0.15)
                                {
                                    $count_nucs++;
                                }
                            }
                            if ($count_nucs > 1)
                            {
                                $SNP_check = "yes2";
                            }
                        }
						if ($SNR_read_ahead ne "")
						{
							print {$filehandle{$seed_id2}} "\n".$SNR_read_ahead." SNR_READ_AHEAD\n";
						}
						
#Compare previous split positions of this extension-----------------------------------------------------------------------------------------------------------------------                        
     
                        my %post_SNP_patterns;
						undef %post_SNP_patterns;
						my %find_haps_SNPs;
						undef %find_haps_SNPs;
                        my $prev_pos_count = '0';
						my $local_pattern_matches = '0';
						$local_pattern_matches2 = '0';
                        
POST_SNP_PATTERNS_TMP_PB: foreach my $pos_tmp (sort {$a <=> $b} keys %SNP_patterns_prev)
                        {
                            if ($pos_tmp ne $current_pos_tmp && $pos_tmp < $current_pos_tmp)
                            { 
                                my %post_SNP_patterns_tmp;
								undef %post_SNP_patterns_tmp;
					#print {$filehandle{$seed_id2}} "\n".$pos_tmp." POS\n";   
                                foreach my $nuc_tmp (keys %{$SNP_patterns_prev{$pos_tmp}})
                                {
								    foreach my $rank_tmp (keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_tmp}})
                                    {
										foreach my $nuc_now_tmp2 (keys %SNP_patterns_now)
                                        {              
                                            if (exists($SNP_patterns_now{$nuc_now_tmp2}{$rank_tmp}))
                                            {   
												if (exists($post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp}))
                                                {
                                                    my $count_tmp = $post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp}+1;
                                                    $post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp} = $count_tmp;
                                                }
                                                else
                                                {
                                                    $post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp} = '1';
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                my $verified_tmp = "";
                                my %tmp_check_list;
								undef %tmp_check_list;
								my $gap_count_tmp = keys %{$SNP_patterns_prev{$pos_tmp}{"-"}};
								
                                foreach my $nuc_now_tmp3 (keys %post_SNP_patterns_tmp)
                                {      
                                    my $count_nuc_now_tmp = keys %{$SNP_patterns_now{$nuc_now_tmp3}};
									
                #print {$filehandle{$seed_id2}} $nuc_now_tmp3." NUC_NOW\n";
				
                                    if (($count_nuc_now_tmp > 1 || $total_nuc_count < 11) && $count_nuc_now_tmp > $total_nuc_count*0.095)
                                    {
                                        my $pipi = 0.85;
										if ($count_nuc_now_tmp < 10 || $nuc_now_tmp3 eq "-")
										{
											$pipi = '0.88';
										}
										if ($count_nuc_now_tmp < 5)
										{
											$pipi = '0.95';
										}										
										
										foreach my $nuc_prev_tmp3 (keys %{$post_SNP_patterns_tmp{$nuc_now_tmp3}})
                                        {
                                            $count_nuc_now_tmp = keys %{$SNP_patterns_now{$nuc_now_tmp3}};
											my $count_nuc_prev_tmp = keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_prev_tmp3}};

											if ($nuc_prev_tmp3 ne "-" && $gap_count_tmp < $total_nuc_count*0.15)
											{
												$count_nuc_now_tmp -= $post_SNP_patterns_tmp{$nuc_now_tmp3}{"-"};
												#print {$filehandle{$seed_id2}} $post_SNP_patterns_tmp{$nuc_now_tmp3}{"-"}." NUC_NOW_RANK_COUNT_ADJUST\n";
											}
											if ($nuc_now_tmp3 ne "-" && $nucs{"-"} < $total_nuc_count*0.15)
											{
												$count_nuc_prev_tmp -= $post_SNP_patterns_tmp{"-"}{$nuc_prev_tmp3};
												#print {$filehandle{$seed_id2}} $post_SNP_patterns_tmp{"-"}{$nuc_prev_tmp3}." NUC_PREV_RANK_COUNT_ADJUST\n";
											}
									#print {$filehandle{$seed_id2}} $nuc_prev_tmp3." NUC_PREV\n";
				#print {$filehandle{$seed_id2}} $count_nuc_prev_tmp." NUC_PREV_RANK_COUNT\n";
				#print {$filehandle{$seed_id2}} $count_nuc_now_tmp." NUC_NOW_RANK_COUNT\n";
				#print {$filehandle{$seed_id2}} $post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3}." MATCHES\n";  	
											if ($post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3} > $count_nuc_now_tmp*$pipi && $count_nuc_now_tmp > $post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3}*$pipi
												&& $count_nuc_now_tmp > $count_nuc_prev_tmp*$pipi && $count_nuc_prev_tmp > $count_nuc_now_tmp*$pipi)
                                            {
                                                if (exists($tmp_check_list{$nuc_prev_tmp3}))
                                                {
                                                    next POST_SNP_PATTERNS_TMP_PB;
                                                }
                                                $tmp_check_list{$nuc_prev_tmp3} = undef;
												$find_haps_SNPs{$pos_tmp}{$nuc_now_tmp3} = $nuc_prev_tmp3;
												if ($verified_tmp eq "yes")
												{
													$verified_tmp = "yes2";
												}
												else
												{
													$verified_tmp = "yes";
												}
                                            }
                                            elsif ($post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3} < $total_nuc_count*0.15)
                                            {              
                                            }
                                            else
                                            {
                                                next POST_SNP_PATTERNS_TMP_PB;
                                            }
                                        }
                                    }
                                }
                                if ($verified_tmp eq "yes2")
                                {
									print {$filehandle{$seed_id2}} $pos_tmp." POS_MATCH\n";
									if ($pos_tmp > $current_pos_tmp-150)
									{
										$local_pattern_matches++;
										if ($pos_tmp > $current_pos_tmp-25)
										{
											$local_pattern_matches2++;
										}	
									}		
									
									my $one_tmp = "";
									my $two_tmp = "";
									foreach my $nuc_tmp (keys %{$SNP_patterns_prev{$pos_tmp}})
									{
										foreach my $rank_tmp (keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_tmp}})
										{
											if ($rank_tmp eq '1')
											{
												$one_tmp = $nuc_tmp;
											}
											if ($rank_tmp eq '2')
											{
												$two_tmp = $nuc_tmp;
											}
										}
									}
									if ($one_tmp eq $two_tmp)
									{
										$SNP_patterns_prev_match{$pos_tmp} = $one_tmp;
									}
									
                                    foreach my $nuc_now_tmp4 (keys %SNP_patterns_now)
                                    {
										foreach my $rank_now_tmp4 (keys %{$SNP_patterns_now{$nuc_now_tmp4}})
                                        {
                                            foreach my $nuc_prev_tmp4 (keys %{$SNP_patterns_prev{$pos_tmp}})
                                            {    
												foreach my $rank_prev_tmp4 (keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_prev_tmp4}})
                                                {
                                                    if ($rank_prev_tmp4 eq $rank_now_tmp4)
                                                    {
                                                        my $highest_count_tmp = '0';
                                                        my $highest_nuc_tmp = "";
														
                                                        foreach my $nuc_now_tmp5 (keys %post_SNP_patterns_tmp)
                                                        {                                                          
                                                            foreach my $nuc_prev_tmp5 (keys %{$post_SNP_patterns_tmp{$nuc_now_tmp5}})
                                                            {
                                                                if ($nuc_prev_tmp5 eq $nuc_prev_tmp4)
                                                                {
                                                                    my $count_tmp = $post_SNP_patterns_tmp{$nuc_now_tmp5}{$nuc_prev_tmp5};
                                                                    if ($count_tmp > $highest_count_tmp)
                                                                    {
                                                                        $highest_count_tmp = $count_tmp;
                                                                        $highest_nuc_tmp = $nuc_now_tmp5;
                                                                    } 
                                                                }
                                                            }
                                                        }
                                                        if ($highest_nuc_tmp ne "")
                                                        {
                                                            $post_SNP_patterns{$rank_now_tmp4}{$highest_nuc_tmp}{$pos_tmp} = $nuc_prev_tmp4;
                                                        }
                                                    }
                                                }	
                                            }
                                        }
                                    }
                                    $prev_pos_count++;
                                }
                            }
                        }

 #-----------------------------------------------------------------------------------------------------------------------
						my %split_patterns_final;
						undef %split_patterns_final;
                        undef %split_patterns_final_score;
						
						foreach my $rank_tmp6 (keys %post_SNP_patterns)
                        {                       
                            my $highest_count_tmp = '0';
                            my $highest_nuc_tmp = "";
                            foreach my $nuc_now_tmp6 (keys %{$post_SNP_patterns{$rank_tmp6}})
                            {
                                my $count_tmp = '0';
								foreach my $pos_tmp6 (keys %{$post_SNP_patterns{$rank_tmp6}{$nuc_now_tmp6}})
								{
									if ($post_SNP_patterns{$rank_tmp6}{$nuc_now_tmp6}{$pos_tmp6} eq "-" || $nuc_now_tmp6 eq "-")
									{									
										$count_tmp += 0.5;
									}
									else
									{
										$count_tmp += 1.5;
									}
								}
								#my $count_tmp = keys %{$post_SNP_patterns{$rank_tmp6}{$nuc_now_tmp6}};
                                if ($count_tmp > $highest_count_tmp)
                                {
                                    $highest_count_tmp = $count_tmp;
                                    $highest_nuc_tmp = $nuc_now_tmp6;
                                }
                                elsif (exists($SNP_patterns_now{$nuc_now_tmp6}{$rank_tmp6}))
                                {
                                    if ($count_tmp eq $highest_count_tmp)
                                    {
                                        $highest_count_tmp = $count_tmp;
                                        $highest_nuc_tmp = $nuc_now_tmp6;
                                    }
                                }
                            }
                            $split_patterns_final{$rank_tmp6} = $highest_nuc_tmp;
                            $split_patterns_final_score{$highest_nuc_tmp}{$rank_tmp6} = $highest_count_tmp;
                        }
                        
						if (keys %{$trace_back_split_PB{$id}} > 0 && $SNP_check ne "")
						{
							my $min_pos = $position+length($best_extension)-20;
							
							foreach my $min_pos_tmp (keys %{$trace_back_split_PB{$id}})
                            {
								if ($min_pos_tmp > $min_pos && $min_pos_tmp < $min_pos+30)
								{
									my $last_11 = substr $best_extension, -11, 11;
									my $last_11_prev = $trace_back_split_PB{$id}{$min_pos_tmp};
									my $N_check = $last_11_prev =~ tr/N/N/;
	
									print {$filehandle{$seed_id2}} $last_11_prev." ".$last_11." TRACE_BACK_POSITION!!!!!!!!!!!!!!!!\n";
									if ($last_11 eq $last_11_prev)
									{			
										$trace_back_check = "yes";
									}
									elsif ($N_check > 0)
									{
										$last_11_prev =~ tr/N/\./;
										if ($last_11 =~ m/$last_11_prev/)
										{
											$trace_back_check = "yes";
										}
									}
								}
							}
						}				

                        if (keys %split_patterns_final eq '0' && ($SNP_check ne "" || $trace_back_check eq "yes"))
                        {
                            print {$filehandle{$seed_id2}} $SNP_check." SNP_CHECK\n";
                            foreach my $rank_tmp4 (sort {$a <=> $b} keys %subject_list)
                            {
								my $nuc_tmp = $nucs_by_rank{$rank_tmp4};
                                $split_patterns_final{$rank_tmp4} = $nuc_tmp;
                                $split_patterns_final_score{$nuc_tmp}{$rank_tmp4} = '1';
                            }
                        }

                        my %reads_to_remove;
						undef %reads_to_remove;
                        my $remove_reads = "";
                        my %average_rank_score;
						undef %average_rank_score;
						
						$post_pattern_match = "";
                        my $post_pattern_match_extra = "";
                        my $post_pattern_match_average = "";
                        my %longest_match;
						undef %longest_match;
						my %longest_match2;
						undef %longest_match2;
                        my $longest_longest_match = "";
                        my $longest_longest_match_nuc = "";
						my $count_post_pattern_match3 = '0';
						my $find_haps_found = "";
                        
                        foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
                        {
                            print {$filehandle{$seed_id2}} $rank_tmp13." ".$nucs_by_rank{$rank_tmp13}." ".$split_patterns_final{$rank_tmp13}."\n";
                        }
                        foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
                        {
                            my $rank_count_tmp = '0';
                            my $total_score_count_tmp = '0';
                            
                            foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
                            {
                                if (($rank_tmp13 <= $add_no_match_reads || $add_no_match_reads eq "") && ($rank_tmp13 <= $add_rejected_reads || $add_rejected_reads eq ""))
								{
									$rank_count_tmp++;
									$total_score_count_tmp += $split_patterns_final_score{$nuc_tmp13}{$rank_tmp13};
									my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp13}};
									if (exists($rank_to_id{$rank_tmp13}) && $count_ranks_tmp > 0.1*$total_nuc_count)
									{
										my $id_tmp3 = $rank_to_id{$rank_tmp13};
										#print {$filehandle{$seed_id2}} $long_read_end_pos_save{$id_tmp3}." LONG_READ_END_TMP\n";
										if (exists($read_start_pos_rej{$id_tmp3}))
										{}
										elsif (exists($longest_match{$nuc_tmp13}))
										{
											if ($alignment_length_save{$id_tmp3} > $longest_match{$nuc_tmp13})
											{
												$longest_match{$nuc_tmp13} = $alignment_length_save{$id_tmp3};
											}
											$longest_match2{$nuc_tmp13}{$alignment_length_save{$id_tmp3}}{$id_tmp3} = undef;
										}
										else
										{
											$longest_match{$nuc_tmp13} = $alignment_length_save{$id_tmp3};
											$longest_match2{$nuc_tmp13}{$alignment_length_save{$id_tmp3}}{$id_tmp3} = undef;
										}
									}
								}
                            }
							$total_score_count_tmp *= ($rank_count_tmp/$total_nuc_count)*2;
                            print {$filehandle{$seed_id2}} $nuc_tmp13." ".$total_score_count_tmp." SCORE ".$rank_count_tmp." COUNT\n";
							
							$total_count_prev_patterns = '0';
							foreach my $posie_tmpie (sort {$b <=> $a} keys %total_count_prev_patterns)
							{
								if ($posie_tmpie > length($best_extension)-150)
								{
									$total_count_prev_patterns++;
								}
							}
							my $total_count_prev_patterns_all = keys %total_count_prev_patterns;
   
							if ($rank_count_tmp > 0)
							{
								if (((keys %split_patterns_final > 0.9*$total_nuc_count && ($total_score_count_tmp/$rank_count_tmp > 1.5
									|| ($trace_back_check eq "yes" && $rank_count_tmp > $total_nuc_count*0.2)) && $total_score_count_tmp > 0 && ($total_count_prev_patterns < 30
									|| ($total_count_prev_patterns < 20 && $rank_count_tmp > 5) || ($total_score_count_tmp/$rank_count_tmp > 10))) || $SNP_check eq "yes2" || ($local_pattern_matches2 > 2 && $total_nuc_count > 8 ))
									&& (length($best_extension) > 15 || $clipped_ext ne "") && $total_nuc_count > 5 && $rank_count_tmp > $total_nuc_count*0.1)
								{            
									print {$filehandle{$seed_id2}} $total_count_prev_patterns." TOTAL_COUNT_PREV_PATTERNS\n";
									print {$filehandle{$seed_id2}} $total_count_prev_patterns_all." TOTAL_COUNT_PREV_PATTERNS_ALL\n";
									
									if ($post_pattern_match eq "yes")
									{
										$post_pattern_match = "yes2";
									}
									elsif ($post_pattern_match eq "")
									{
										$post_pattern_match = "yes";
									}
									my $vv = '0.6';
									my $ll = '0.4';
									if ($total_nuc_count > 8 && $rank_count_tmp > 4)
									{
										$vv = '0.4';
										$ll = '0.3';
									}
									if ((($total_count_prev_patterns < 5 && $total_count_prev_patterns_all < 15) || ($total_score_count_tmp/$rank_count_tmp > (($total_count_prev_patterns*$vv)+(10/$total_nuc_count)) &&
										 (($local_pattern_matches > 1 && ($rank_count_tmp > $total_nuc_count*0.35 && $rank_count_tmp < $total_nuc_count*0.65)) || $total_score_count_tmp/$rank_count_tmp > (($total_count_prev_patterns_all*$ll)+(10/$total_nuc_count))))
										 || $total_score_count_tmp/$rank_count_tmp > (20+((10/$total_nuc_count)*10)) || ($local_pattern_matches > 0.7*$total_count_prev_patterns && $local_pattern_matches > 5))
										 && ($rank_count_tmp > 2 || $prev_pos_count > $total_count_prev_patterns_all*0.4))
									{
										if ($post_pattern_match_average eq "yes")
										{
										}
										elsif ($post_pattern_match_average eq "ye")
										{
											$post_pattern_match_average = "yes";
										}
										else
										{
											$post_pattern_match_average = "ye";
											if ($total_score_count_tmp/$rank_count_tmp > (30+((10/$total_nuc_count)*10)) && $rank_count_tmp > 10 &&
											   (($local_pattern_matches > 0.68*$total_count_prev_patterns && $local_pattern_matches > 10) ||($rank_count_tmp > $total_nuc_count*0.35 && $rank_count_tmp < $total_nuc_count*0.65)))
											{
												$post_pattern_match_average = "yes";
											}
										}
									}
									if ((($total_score_count_tmp/$rank_count_tmp > 1 && $SNP_check ne "") || $total_score_count_tmp/$rank_count_tmp > 1.5)
										&& (($rank_count_tmp > 3 && $rank_count_tmp < $total_nuc_count-3) || $total_score_count_tmp/$rank_count_tmp > 2))
									{
										if ($post_pattern_match_extra eq "yes")
										{
										}
										elsif ($post_pattern_match_extra eq "ye")
										{
											$post_pattern_match_extra = "yes";
										}
										else
										{
											$post_pattern_match_extra = "ye";
										}
										
										if ($first_split_pos eq "")
										{
											$first_split_pos = length($best_extension);
										}
									}
									print {$filehandle{$seed_id2}} $post_pattern_match_extra." POST_PATTERN_MATCH_EXTRA\n";
									print {$filehandle{$seed_id2}} $post_pattern_match_average." POST_PATTERN_MATCH_AVERAGE\n";
									print {$filehandle{$seed_id2}} $longest_match{$nuc_tmp13}." LONGEST_MATCH\n";
									
									if (($longest_longest_match eq "" || ($longest_match{$nuc_tmp13} > $longest_longest_match && $rank_count_tmp > $total_nuc_count*0.2)) && $nuc_tmp13 ne "" && $nucs{$nuc_tmp13} > $total_nuc_count*0.2)
									{
										$longest_longest_match = $longest_match{$nuc_tmp13};
										$longest_longest_match_nuc = $nuc_tmp13;
									}
	
									if ($post_pattern_match_save eq "yes" && ($total_score_count_tmp/$rank_count_tmp > 3 && ($total_score_count_tmp/$rank_count_tmp > $total_count_prev_patterns*0.3) &&
										(($total_score_count_tmp/$rank_count_tmp > 5 && $total_score_count_tmp/$rank_count_tmp > $total_count_prev_patterns*0.5) || $rank_count_tmp > 6)
										|| ($total_score_count_tmp/$rank_count_tmp >= $total_count_prev_patterns*0.4 || $total_count_prev_patterns < 2)))
									{                                    
										if ($post_pattern_match_save eq "yes" && $total_score_count_tmp/$rank_count_tmp > 9 && $total_score_count_tmp/$rank_count_tmp > $total_count_prev_patterns*0.4 &&
										($total_score_count_tmp/$rank_count_tmp > $total_count_prev_patterns*0.5 || $rank_count_tmp > 6))
										{
											$post_pattern_match = "yes3";
											$post_pattern_match_extra = "yes";
											$post_pattern_match_average = "yes";
											$post_pattern_match_count++;
										}
									}
									$post_pattern_match_save = "yes";
								}
							}
                        }
						
						if (($local_pattern_matches > 5 || ($local_pattern_matches > 3 && $total_nuc_count > 10 && $SNR_read_ahead eq "") && $total_nuc_count > 4))
						{
							$post_pattern_match = "yes3";
							$post_pattern_match_average = "yes";
							$post_pattern_match_extra = "yes";
						}
						if ($switch_ONT_SNP eq "yes")
						{	
							$post_pattern_match = "yes3";
							$post_pattern_match_average = "yes";
							$post_pattern_match_extra = "yes";
						}
						if ($trace_back_check ne "")
						{	
							$post_pattern_match = "yes3";
							$post_pattern_match_average = "yes";
							$post_pattern_match_extra = "yes";
						}
						if ($post_pattern_match ne "")
						{
							print {$filehandle{$seed_id2}} $post_pattern_match." POST_PATTERN_MATCH\n";
						}

#Select reads based on all mismatches--------------------------------------------------------------------------------------  
						if (($mismatches_tmp_check eq "" || $add_no_match_reads ne "" || $add_rejected_reads ne "") && $find_haps_in_seed eq "" && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3"))
                        {
                            $mismatches_tmp_check = "yes";
							$rank_count_check = $total_nuc_count;
                        
							foreach my $rank_tmp (keys %split_patterns_final)
							{
								if (exists($rank_to_id{$rank_tmp}))
								{
									my $id_tmp = $rank_to_id{$rank_tmp};
									if (exists($store_mismatches_PB{$id_tmp}))
									{
										foreach my $posie (keys %{$store_mismatches_PB{$id_tmp}})
										{
											if ($add_no_match_reads ne ""  && $rank_tmp > $add_no_match_reads && $posie < $position-$add_no_match_reads_pos)
											{
											}
											else
											{
												$mismatches_tmp{$posie}{$rank_tmp} = $store_mismatches_PB{$id_tmp}{$posie};
											}								
										}
									}
								}
							}   

							foreach my $posie (sort {$a <=> $b} keys %mismatches_tmp)
							{          
								my $count_mm_tmp = keys %{$mismatches_tmp{$posie}};
								my $count_mm_tmp_extra = '0';
								foreach my $rank_tmp (keys %split_patterns_final)
								{ 
									if (exists($rank_to_id{$rank_tmp}))
									{
										my $id_tmpi = $rank_to_id{$rank_tmp};
										if (exists($alignment_length_save{$id_tmpi}))
										{
											my $overlap_tmp = $alignment_length_save{$id_tmpi};
											if ($posie < $position-$overlap_tmp)
											{                                
												$count_mm_tmp_extra++;
											}
										}
									}
								}
	
								if ($count_mm_tmp > 0.89*$total_nuc_count || $count_mm_tmp_extra+$count_mm_tmp > 0.95*$total_nuc_count)
								{
									delete $mismatches_tmp{$posie};
								}
								elsif ($count_mm_tmp > 1 && $count_mm_tmp > $total_nuc_count*0.07)
								{                                    
									my $count_below_10 = '0';
									my $ii = '1';
									while ($ii < 10)
									{
										if (exists($mismatches_tmp{$posie}{$ii}))
										{
											$count_below_10++;
										}
										$ii++;
									}
									
									if ($count_below_10 < 10)
									{
										foreach my $rank_tmp (keys %{$mismatches_tmp{$posie}})
										{
											$reads_mismatch{$rank_tmp}{$posie} = undef;
											$reads_mismatchb{$posie}{$rank_tmp} = undef;
										}
									}
								}
							}
                        
							foreach my $rank_tmp2 (sort {$a <=> $b} keys %reads_mismatch)
							{
								foreach my $posie_tmp2 (sort {$a <=> $b} keys %{$reads_mismatch{$rank_tmp2}})
								{
									foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatchb{$posie_tmp2}})
									{
										if ($rank_tmp3 ne $rank_tmp2)
										{
											if (exists($reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}))
											{
												$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}{$posie_tmp2} = undef;
											}
											elsif (exists($reads_mismatch2_tmp{$rank_tmp3}{$rank_tmp2}))
											{
												$reads_mismatch2_tmp{$rank_tmp3}{$rank_tmp2}{$posie_tmp2} =undef;
											}
											else
											{
												$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}{$posie_tmp2} = undef;
											}
										}
									}
								}
							}
							foreach my $rank_tmp2 (sort {$a <=> $b} keys %reads_mismatch2_tmp)
							{
								foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp{$rank_tmp2}})
								{
									my $count_tmp = keys %{$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}};
									if ($count_tmp > 0)
									{  
										foreach my $posie_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}})
										{
											$reads_mismatch2{$count_tmp}{$rank_tmp2}{$rank_tmp3}{$posie_tmp3} = undef;
										}
									}
								}
							}
							#foreach my $posie2 (sort {$a <=> $b} keys %reads_mismatchb)
							#{
								#foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$reads_mismatchb{$posie2}})
								#{
									#foreach my $posie3 (sort {$a <=> $b} keys %{$reads_mismatch{$rank_tmp2}})
									#{
										#if ($posie2 ne $posie3)
										#{
											#if (exists($reads_mismatch2b_tmp{$posie2}{$posie3}))
											#{
												#$reads_mismatch2b_tmp{$posie2}{$posie3}{$rank_tmp2} = undef;
											#}
											#elsif (exists($reads_mismatch2b_tmp{$posie3}{$posie2}))
											#{
												#$reads_mismatch2b_tmp{$posie3}{$posie2}{$rank_tmp2} =undef;
											#}
											#else
											#{
												#$reads_mismatch2b_tmp{$posie2}{$posie3}{$rank_tmp2} = undef;
											#}
										#}
									#}
								#}
							#}
							#foreach my $posie2 (sort {$a <=> $b} keys %reads_mismatch2b_tmp)
							#{
								#foreach my $posie3 (sort {$a <=> $b} keys %{$reads_mismatch2b_tmp{$posie2}})
								#{
									#my $count_tmp = keys %{$reads_mismatch2b_tmp{$posie2}{$posie3}};
									#if ($count_tmp > 3)
									#{  
										#foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2b_tmp{$posie2}{$posie3}})
										#{
											#$reads_mismatch2b{$count_tmp}{$posie2}{$posie3}{$rank_tmp3} = undef;
										#}
									#}
								#}
							#}
						}
#----------------------------------------------------------------------------------------------------------------------------------------------------------											
                        my %pos_list_number;
						undef %pos_list_number;
						my %SNP_pattern_average;
						undef %SNP_pattern_average;
                        my $SNP_pattern_average = '0';
                        my $SNP_pattern_average_tmp = '0';
						my $high_score_save = "";
						my $highest_first_no_match = "";
                            
                        if ($mismatches_tmp_check eq "yes" && $find_haps_in_seed eq "" && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3"))
                        {                             
                            foreach my $rank_tmp (sort {$a <=> $b} keys %reads_mismatch)
                            {
                                my $pos_list = "";
                                my %post_SNP_matching_score;
								undef %post_SNP_matching_score;
                                my $pos_list_number = '0';
                                
                                foreach my $posie_tmp (sort {$a <=> $b} keys %{$reads_mismatch{$rank_tmp}})
                                {                               
                                    if (exists($split_patterns_final{$rank_tmp}))
                                    {
                                        my $nuc_tmp18 = $split_patterns_final{$rank_tmp};
                                        if (exists($post_SNP_matching_score{$nuc_tmp18}))
                                        {
                                            my $count_tmp = $post_SNP_matching_score{$nuc_tmp18};
                                            $post_SNP_matching_score{$nuc_tmp18} = $count_tmp+1;
                                        }
                                        else
                                        {
                                            $post_SNP_matching_score{$nuc_tmp18} = '1';
                                        }                            
                                    }
                                    #print {$filehandle{$seed_id2}} $posie_tmp." POS ".$reads_mismatch{$rank_tmp}{$posie_tmp}."\n";
                                    if ($pos_list eq "")
                                    {
                                        $pos_list = $posie_tmp;
                                        $pos_list_number++;
                                    }
                                    else
                                    {
                                        $pos_list .= ";".$posie_tmp;
                                        $pos_list_number++;
                                    }
                                }
                                $pos_list_number{$rank_tmp} = $pos_list_number;
                                my $length_match_tmp = '1000';
                                if (exists($rank_to_id{$rank_tmp}))
                                {
                                    my $id_tmpi = $rank_to_id{$rank_tmp};
                                    $length_match_tmp = $alignment_length_save{$id_tmpi};
                                    if ($length_match_tmp > $position-$original_seed_length{$id})
                                    {
                                        $length_match_tmp -= $original_seed_length{$id} - ($position-$length_match_tmp);
                                    }
                                }
								if ($length_match_tmp < 1) #CHECKKKKKKKKKKKKKKKKKKKKKKKK
								{
									$length_match_tmp = '1';
								}
                                $SNP_pattern_average_tmp += $pos_list_number/$length_match_tmp;
                                $SNP_pattern_average{$pos_list_number/$length_match_tmp}{$rank_tmp} = $pos_list_number;
								
                                if ($pos_pattern_list_check eq "")
								{
									print {$filehandle{$seed_id2}} $rank_tmp." RANK\n";
									print {$filehandle{$seed_id2}} $pos_list."\n";
								}
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------                                                                
                                my $total_pattern_count = keys %{$reads_mismatch{$rank_tmp}};
                                foreach my $nuc_tmp19 (keys %post_SNP_matching_score)
                                {
                                    if ($post_SNP_matching_score{$nuc_tmp19} > 0.85*$total_pattern_count)
                                    {
                                        if (exists($SNP_patterns_prev2{$nuc_tmp19}))
                                        {
                                            my $count_tmp = $SNP_patterns_prev2{$nuc_tmp19};
                                            $SNP_patterns_prev2{$nuc_tmp19} = $count_tmp+1;
                                        }
                                        else
                                        {
                                            $SNP_patterns_prev2{$nuc_tmp19} = '1';
                                        }
										if ($pos_pattern_list_check eq "")
										{
											print {$filehandle{$seed_id2}} $nuc_tmp19." PATTERN_MATCH\n";
										}
                                    }
                                }               
                            }
                            
                            $SNP_pattern_average = $SNP_pattern_average_tmp/$total_nuc_count;                           
#------------------------------------------------------------------------------------------------------------------------
                            if ($pos_pattern_list_check eq "" && $find_haps_in_seed eq "" && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3"))
                            {
                                $pos_pattern_list_check = "yes";
					my $time_check = time;			
								print {$filehandle{$seed_id2}} $SNP_pattern_average." SNP_PATTERN_AVERAGE\n";
										
                                my $count_patterns = '0';
								foreach my $count_tmp (sort {$b <=> $a} keys %reads_mismatch2)
								{
									my %pos_pattern_list_tmp;
									undef %pos_pattern_list_tmp;
									my %pos_pattern_list_out_of_range;
									undef %pos_pattern_list_out_of_range;
									
	 #print {$filehandle{$seed_id2}} "\n".$count_tmp." COUNT\n";
									foreach my $rank_tmp (sort {$a <=> $b} keys %{$reads_mismatch2{$count_tmp}})
									{
										my %read_patterns2_tmp;
										undef %read_patterns2_tmp;
										$read_patterns2_tmp{$rank_tmp} = undef;
						#print {$filehandle{$seed_id2}} $rank_tmp." RANK1\n";                
										foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$reads_mismatch2{$count_tmp}{$rank_tmp}})
										{
											$read_patterns2_tmp{$rank_tmp2} = undef;
											
											foreach my $posie_tmp (keys %{$reads_mismatch2{$count_tmp}{$rank_tmp}{$rank_tmp2}})
											{
												$pos_pattern_list_tmp{$posie_tmp} = '2';
												 #print {$filehandle{$seed_id2}} $posie_tmp." POSIE\n";
											}
									#print {$filehandle{$seed_id2}} $rank_tmp2." RANK2\n";
HIGHEST_RANK_PB:											
											my $highest_score_rank = '0';
											my $highest_rank_tmp = "";
											my %pos_pattern_list_tmp2;
											undef %pos_pattern_list_tmp2;
											my %pos_pattern_list_tmp3;
											undef %pos_pattern_list_tmp3;
											
											my $highest_pos_score_tmp = '0';
											
											foreach my $posie_tmp (keys %pos_pattern_list_tmp)
											{
												if ($pos_pattern_list_tmp{$posie_tmp} > $highest_pos_score_tmp)
												{
													$highest_pos_score_tmp = $pos_pattern_list_tmp{$posie_tmp};
												}
											}
											my $fi = '0.6';
											if (keys %read_patterns2_tmp eq '2')
											{
												$fi = '0.45';
											}
											foreach my $rank_tmp3 (sort {$b <=> $a} keys %reads_mismatch)
											{
												my $match_tmp = '0';
												my $no_match_tmp = '0';
												my $count_tmp_new = '0';

												if (!exists($read_patterns2_tmp{$rank_tmp3}))
												{
													foreach my $posie_tmp (keys %pos_pattern_list_tmp)
													{
														if ($pos_pattern_list_tmp{$posie_tmp} > $highest_pos_score_tmp*$fi)
														{
															if (exists($rank_to_id{$rank_tmp3}))
															{
																my $id_tmpi = $rank_to_id{$rank_tmp3};
																if (exists($alignment_length_save{$id_tmpi}))
																{
																	my $overlap_tmp = $alignment_length_save{$id_tmpi};
																	$count_tmp_new++;
																	if ($posie_tmp > $position-$overlap_tmp)
																	{                                
																		if (exists($reads_mismatch{$rank_tmp3}{$posie_tmp}))
																		{
																			$match_tmp++;
																			$pos_pattern_list_tmp2{$rank_tmp3}{$posie_tmp} = '1';
																		}
																		else
																		{
																			$no_match_tmp++;
																			$pos_pattern_list_tmp2{$rank_tmp3}{$posie_tmp} = '-0.5';
																		}
																	}
																	else
																	{
																		$pos_pattern_list_tmp3{$rank_tmp3}{$posie_tmp} = '1';
																	}
																}
															}
														}
													}
												}
												
												if ($match_tmp > 0 && $no_match_tmp < $match_tmp*0.1 && $no_match_tmp < 0.1*$count_tmp_new &&
													($match_tmp > $count_tmp_new*0.5 || ($match_tmp > 2 && $match_tmp > $count_tmp_new*0.2 && $highest_pos_score_tmp < 3)))
												{
													if ($match_tmp > $highest_score_rank)
													{
														$highest_score_rank = $match_tmp;
														$highest_rank_tmp = $rank_tmp3;
													}
												}
											}
											if ($highest_rank_tmp ne "")
											{
												$read_patterns2_tmp{$highest_rank_tmp} = undef;
												foreach my $posie_tmp3 (keys %{$pos_pattern_list_tmp2{$highest_rank_tmp}})
												{
													$pos_pattern_list_tmp{$posie_tmp3} += $pos_pattern_list_tmp2{$highest_rank_tmp}{$posie_tmp3};
												}
												foreach my $posie_tmp3 (keys %{$pos_pattern_list_tmp3{$highest_rank_tmp}})
												{
													$pos_pattern_list_out_of_range{$posie_tmp3} += $pos_pattern_list_tmp3{$highest_rank_tmp}{$posie_tmp3};
												}
												###CHECKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK DELETED
											
												goto HIGHEST_RANK_PB;
											}
											
											my $highest_pos_list = '0';
											foreach my $posie_tmp5 (keys %pos_pattern_list_tmp)
											{
												if ($pos_pattern_list_tmp{$posie_tmp5} > $highest_pos_list)
												{
													$highest_pos_list = $pos_pattern_list_tmp{$posie_tmp5};
												}
											}
											my $total_score_tmp = '0';
											foreach my $posie_tmp5 (keys %pos_pattern_list_tmp)
											{
												if ($pos_pattern_list_tmp{$posie_tmp5} > 0 && ($pos_pattern_list_tmp{$posie_tmp5} > $highest_pos_list*0.5 ||    ###CHECKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
												   ($pos_pattern_list_tmp{$posie_tmp5} > 3 && $pos_pattern_list_tmp{$posie_tmp5} > $total_nuc_count*0.1))
													&& $pos_pattern_list_tmp{$posie_tmp5}+$pos_pattern_list_out_of_range{$posie_tmp5} > $highest_pos_list*0.7)
												{
													$total_score_tmp += $pos_pattern_list_tmp{$posie_tmp5};
												}
												else
												{
													delete $pos_pattern_list_tmp{$posie_tmp5};
												}
											}
											
											my $final_score_tmp = $total_score_tmp/($total_nuc_count*0.25);
											
											if ($final_score_tmp > 1)
											{
												$count_patterns++;
												my $first_rank_tmp = "";
												foreach my $rank_tmp6 (sort {$a <=> $b} keys %read_patterns2_tmp)
												{
													$read_patterns2{$final_score_tmp}{$count_patterns}{$rank_tmp6} = $count_tmp;
													if ($first_rank_tmp eq "")
													{
														$first_rank_tmp = $rank_tmp6;
													}
												}
												foreach my $pos_tmp6 (keys %pos_pattern_list_tmp)
												{
													$pos_pattern_list{$final_score_tmp}{$first_rank_tmp}{$pos_tmp6} = undef;
												}
											}
											
											undef %pos_pattern_list_tmp;
											undef %pos_pattern_list_out_of_range;
											undef %read_patterns2_tmp;
											$read_patterns2_tmp{$rank_tmp} = undef;
										}
									}                                     
								}
								
								my $df = "no";
								if ($df eq "")
								{
									my $time_check_MID2_point = time;
							my $time_check_MID2 = $time_check_MID2_point - $time_check;
									print {$filehandle{$seed_id2}} $time_check_MID2." TIME_CHECK_MID\n\n";
									
									my $fff = keys %reads_mismatchb;
							print {$filehandle{$seed_id2}} $fff." KEYS_READ_MMb\n";
							
									foreach my $count_tmp (sort {$b <=> $a} keys %reads_mismatch2b)
									{
										my %rank_pattern_list_tmp;
										undef %rank_pattern_list_tmp;
										my %rank_pattern_list_out_of_range;
										undef %rank_pattern_list_out_of_range;
			my $time_check_MID2_point_new = time;
														
		 print {$filehandle{$seed_id2}} "\n".$count_tmp." COUNT\n";
		 my $fff2 = keys %{$reads_mismatch2b{$count_tmp}};
							print {$filehandle{$seed_id2}} $fff2." KEYS_READ_MM2b2\n";
										foreach my $posi_tmp (sort {$a <=> $b} keys %{$reads_mismatch2b{$count_tmp}})
										{
											my %read_patterns2_tmp;
											undef %read_patterns2_tmp;
											$read_patterns2_tmp{$posi_tmp} = undef;
							print {$filehandle{$seed_id2}} $posi_tmp." POS1\n";
							my $fff3 = keys %{$reads_mismatch2b{$count_tmp}{$posi_tmp}};
							print {$filehandle{$seed_id2}} $fff3." KEYS_READ_MM2b3\n";
											foreach my $posi_tmp2 (sort {$b <=> $a} keys %{$reads_mismatch2b{$count_tmp}{$posi_tmp}})
											{
												$read_patterns2_tmp{$posi_tmp2} = undef;
												
												foreach my $rank_tmp (sort {$a <=> $b} keys %{$reads_mismatch2b{$count_tmp}{$posi_tmp}{$posi_tmp2}})
												{
													$rank_pattern_list_tmp{$rank_tmp} = '2';
													 #print {$filehandle{$seed_id2}} $posie_tmp." POSIE\n";
												}
										#print {$filehandle{$seed_id2}} $rank_tmp2." RANK2\n";
	HIGHEST_RANK_PB_B:											
												my $highest_score_pos = '0';
												my $highest_pos_tmp = "";
												my %rank_pattern_list_tmp2;
												undef %rank_pattern_list_tmp2;
												my %rank_pattern_list_tmp3;
												undef %rank_pattern_list_tmp3;
												my $highest_rank_score_tmp = '0';
												
												foreach my $rank_tmp (keys %rank_pattern_list_tmp)
												{
													if ($rank_pattern_list_tmp{$rank_tmp} > $highest_rank_score_tmp)
													{
														$highest_rank_score_tmp = $rank_pattern_list_tmp{$rank_tmp};
													}
												}
												
												foreach my $pos_tmp3 (sort {$b <=> $a} keys %reads_mismatchb)
												{
													my $match_tmp = '0';
													my $no_match_tmp = '0';
													my $count_tmp_new = '0';
	
													if (!exists($read_patterns2_tmp{$pos_tmp3}))
													{
														foreach my $rank_tmp (keys %rank_pattern_list_tmp)
														{
															if ($rank_pattern_list_tmp{$rank_tmp} > $highest_rank_score_tmp*0.65)
															{
																if (exists($rank_to_id{$rank_tmp}))
																{
																	my $id_tmpi = $rank_to_id{$rank_tmp};
																	if (exists($alignment_length_save{$id_tmpi}))
																	{
																		my $overlap_tmp = $alignment_length_save{$id_tmpi};
																		$count_tmp_new++;
																		if ($pos_tmp3 > $position-$overlap_tmp)
																		{                                
																			if (exists($reads_mismatchb{$pos_tmp3}{$rank_tmp}))
																			{
																				$match_tmp++;
																				$rank_pattern_list_tmp2{$pos_tmp3}{$rank_tmp} = '1';
																			}
																			else
																			{
																				$no_match_tmp++;
																				$rank_pattern_list_tmp2{$pos_tmp3}{$rank_tmp} = '-0.5';
																			}
																		}
																		else
																		{
																			$rank_pattern_list_tmp3{$pos_tmp3}{$rank_tmp} = '1';
																		}
																	}
																}
															}
														}
													}
													
													if ($match_tmp > 0 && $no_match_tmp < $match_tmp*0.1 && $no_match_tmp < 0.1*$count_tmp_new &&
														($match_tmp > $count_tmp_new*0.5 || ($match_tmp > 2 && $match_tmp > $count_tmp_new*0.2 && $highest_rank_score_tmp < 3)))
													{
														if ($match_tmp > $highest_score_pos)
														{
															$highest_score_pos = $match_tmp;
															$highest_pos_tmp = $pos_tmp3;
														}
													}
												}
												if ($highest_pos_tmp ne "")
												{
													$read_patterns2_tmp{$highest_pos_tmp} = undef;
													foreach my $rank_tmp3 (keys %{$rank_pattern_list_tmp2{$highest_pos_tmp}})
													{
														$rank_pattern_list_tmp{$rank_tmp3} += $rank_pattern_list_tmp2{$highest_pos_tmp}{$rank_tmp3};
													}
													foreach my $rank_tmp3 (keys %{$rank_pattern_list_tmp3{$highest_pos_tmp}})
													{
														$rank_pattern_list_out_of_range{$rank_tmp3} += $rank_pattern_list_tmp3{$highest_pos_tmp}{$rank_tmp3};
													}
													###CHECKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK DELETED
												
													goto HIGHEST_RANK_PB_B;
												}
												
												my $highest_rank_list = '0';
												foreach my $rank_tmp5 (keys %rank_pattern_list_tmp)
												{
													if ($rank_pattern_list_tmp{$rank_tmp5} > $highest_rank_list)
													{
														$highest_rank_list = $rank_pattern_list_tmp{$rank_tmp5};
													}
												}
												my $total_score_tmp = '0';
												foreach my $rank_tmp5 (keys %rank_pattern_list_tmp)
												{
													if ($rank_pattern_list_tmp{$rank_tmp5} > 0 && ($rank_pattern_list_tmp{$rank_tmp5} > $highest_rank_list*0.5 ||    ###CHECKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
													   ($rank_pattern_list_tmp{$rank_tmp5} > 3 && $rank_pattern_list_tmp{$rank_tmp5} > $total_nuc_count*0.1))
														&& $rank_pattern_list_tmp{$rank_tmp5}+$rank_pattern_list_out_of_range{$rank_tmp5} > $highest_rank_list*0.7)
													{
														$total_score_tmp += $rank_pattern_list_tmp{$rank_tmp5};
													}
													else
													{
														delete $rank_pattern_list_tmp{$rank_tmp5};
													}
												}
												
												my $final_score_tmp = $total_score_tmp/($total_nuc_count*0.25);
												
												if ($final_score_tmp > 1)
												{
													$count_patterns++;
													my $first_rank_tmp = "";
													foreach my $rank_tmp6 (sort {$a <=> $b} keys %rank_pattern_list_tmp)
													{
														$read_patterns2{$final_score_tmp}{$count_patterns}{$rank_tmp6} = $count_tmp;
														if ($first_rank_tmp eq "")
														{
															$first_rank_tmp = $rank_tmp6;
														}
													}
													foreach my $pos_tmp6 (keys %read_patterns2_tmp)
													{
														$pos_pattern_list{$final_score_tmp}{$first_rank_tmp}{$pos_tmp6} = undef;
													}
												}
												
												foreach my $posi_tmp2b (keys %{$reads_mismatch2b{$count_tmp}{$posi_tmp}})
												{
													if ($posi_tmp2b ne $posi_tmp2 && exists($read_patterns2_tmp{$posi_tmp2b}))
													{
														delete $reads_mismatch2b{$count_tmp}{$posi_tmp}{$posi_tmp2b};
													}
												}
												undef %rank_pattern_list_tmp;
												undef %rank_pattern_list_out_of_range;
												undef %read_patterns2_tmp;
												$read_patterns2_tmp{$posi_tmp} = undef;
											}
										}
										my $time_check_MID3a = time - $time_check_MID2_point_new;
									print {$filehandle{$seed_id2}} $time_check_MID3a." TIME_CHECK_MID2a\n\n";
									}
									my $time_check_MID3 = time - $time_check_MID2_point;
									print {$filehandle{$seed_id2}} $time_check_MID3." TIME_CHECK_MID2\n\n";
								}			
								
								foreach my $score_tmp5 (sort {$b <=> $a} keys %read_patterns2)
								{
									foreach my $pattern_number (sort {$a <=> $b} keys %{$read_patterns2{$score_tmp5}})
									{
										my $first = "";
										my $count_ranks = keys %{$read_patterns2{$score_tmp5}{$pattern_number}};
										if ($count_ranks < 2)
										{}
										else
										{
											foreach my $rank_tmp7 (sort {$a <=> $b} keys %{$read_patterns2{$score_tmp5}{$pattern_number}})
											{
												$first = $rank_tmp7;
												my $count_pos_tmp = keys %{$reads_mismatch{$rank_tmp7}};
												last;
											}
											foreach my $rank_tmp8 (sort {$a <=> $b} keys %{$read_patterns2{$score_tmp5}{$pattern_number}})
											{
												if ($rank_tmp8 ne $first)
												{
													$read_patterns_final{$score_tmp5}{$first}{$rank_tmp8} = undef;
												}
											}
										}
									}
								}
							}
#Remove based on SNP density----------------------------------------------------------------------------------------------					
							if ($remove_reads eq "fiueffi")
							{
								foreach my $ranki_tmp (sort {$a <=> $b} keys %subject_list)
								{
									if (exists($reads_mismatch{$ranki_tmp}))
									{
									}
									else
									{
										$SNP_pattern_average{'0'}{$ranki_tmp} = '0';
									}
								}
								
								my $ft = '0';
								my $first_score = "";
								my $fifth_score = "";
								my $first_score_count = "";
								my $fifth_score_count = "";
								my $diff_score = "";
								my $diff_score_count = "";
								my $top_rank = '0';
								foreach my $average_SNP_tmp (sort {$a <=> $b} keys %SNP_pattern_average)
								{
									foreach my $rank_tmp8 (sort {$a <=> $b} keys %{$SNP_pattern_average{$average_SNP_tmp}})
									{
										if (exists($subject_list{$rank_tmp8}))
										{
											$ft++;
											if ($rank_tmp8 < 11)
											{
												$top_rank++;
											}
											if ($first_score eq "")
											{
												$first_score = $average_SNP_tmp;
												$first_score_count = $SNP_pattern_average{$average_SNP_tmp}{$rank_tmp8};
											}
											elsif ($ft > 4 && $top_rank > 4 && $fifth_score eq "")
											{
												$diff_score = $average_SNP_tmp-$first_score;		
												$fifth_score = $average_SNP_tmp;
												$fifth_score_count = $SNP_pattern_average{$average_SNP_tmp}{$rank_tmp8};
												$diff_score_count = $fifth_score_count - $first_score_count;
											}
										}
									}
								}
								my $worst_score = "";
								foreach my $average_SNP_tmp (sort {$b <=> $a} keys %SNP_pattern_average)
								{
									foreach my $rank_tmp8 (sort {$a <=> $b} keys %{$SNP_pattern_average{$average_SNP_tmp}})
									{
										if (exists($subject_list{$rank_tmp8}))
										{
											if ($average_SNP_tmp-$fifth_score > $diff_score*3 && $SNP_pattern_average{$average_SNP_tmp}{$rank_tmp8} > 4
												&& $SNP_pattern_average{$average_SNP_tmp}{$rank_tmp8}-$fifth_score_count > $diff_score_count+5
												&& ($worst_score eq "" || ($worst_score-$average_SNP_tmp)*3 < $average_SNP_tmp-$fifth_score))
											{
												$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
												$remove_reads = "yes";
												$exclude_reads_check = "yes2";
												print {$filehandle{$seed_id2}} $rank_tmp8." REMOVE_HIGH_SNP\n";
											}
										}
									}	
								}
								if ($remove_reads eq "yes")
								{
									goto REMOVE_READS_PB;
								}
							}
#-----------------------------------------------------------------------------------------------------------------------------------------------                          
						
							my $highest_avg_score = "";
							my $highest_avg_score2 = "";
                            my $highest_rank_count = "";
                            my $highest_high_score_count = "";
							my $highest_count_matches = "";
                            my $current_score = "";
                            my $current_rank = "";
							my $selected_patterns_count = '0';
                            my %first_no_match;
							undef %first_no_match;
                            my $score_diff = "";
                            my %highest_avg_score;
							undef %highest_avg_score;
							my %pattern_list;
							undef %pattern_list;
							my %rank_patterns;
							undef %rank_patterns;
							
							foreach my $score_tmp (sort {$b <=> $a} keys %read_patterns_final)
                            {
								foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                {
									if (exists($split_patterns_final{$rank_tmp}))
									{
									}
									else
									{
										my $first_rank_tmp = "";
										foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
										{
											$first_rank_tmp = $rank_tmp2;
										}
										foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
										{
											if ($rank_tmp3 ne $first_rank_tmp)
											{
												$read_patterns_final{$score_tmp}{$first_rank_tmp}{$rank_tmp3} = undef;
											}
										}
										delete $read_patterns_final{$score_tmp}{$rank_tmp};
									}
									foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
									{
										if (exists($split_patterns_final{$rank_tmp2}))
										{
										}
										else
										{
											delete $read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp2};
										}
									}  
								}
							}
                            
                            foreach my $score_tmp (sort {$b <=> $a} keys %read_patterns_final)
                            {       
								if ($highest_avg_score eq "")
                                {
                                    $highest_avg_score = $score_tmp;
                                    foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                    {
                                        $highest_avg_score{$rank_tmp} = undef;
                                        foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
                                        {
                                            $highest_avg_score{$rank_tmp2} = undef;
                                        }   
                                    }
                                }
                                elsif ($score_tmp > 0.65*$highest_avg_score)
                                {
                                    foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                    {
                                        if (exists($highest_avg_score{$rank_tmp}))
                                        {}
                                        else
                                        {
                                           $score_diff = "no"; 
                                        }
                                        foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
                                        {
                                            if (exists($highest_avg_score{$rank_tmp2}))
                                            {}
                                            else
                                            {
                                               $score_diff = "no"; 
                                            }
                                        }   
                                    }
                                }
                                
                                foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                {
                                    my $pattern_print = $rank_tmp.";";
                                    my $rank_count_tmp = '1';
                                    my $high_score_count_tmp = '0';
                                    if ($rank_tmp <= 4)
                                    {
                                        $high_score_count_tmp++;
                                    }
                                    foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
                                    {
										$pattern_print .= $rank_tmp2.";";
                                        $rank_count_tmp++;
                                        if ($rank_tmp2 <= 4)
                                        {
                                            $high_score_count_tmp++;
                                        }
                                    }
                                    if ($highest_rank_count eq "")
                                    {
                                        $highest_rank_count = $rank_count_tmp;
                                    }
                                    if ($highest_high_score_count eq "")
                                    {
                                        $highest_high_score_count = $high_score_count_tmp;
                                    }
#match split pattern with SNP pattern------------------------------------------------------------------                                    
                                    my $count_matches_tmp = '0';
                                    my $count_total_tmp = '0';
                                    my $first_no_match = "";				
                                    my $nuc_match = $split_patterns_final{$rank_tmp};

                                    foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
                                    {
                                        if ($split_patterns_final{$rank_tmp13} eq $nuc_match)
                                        {
                                            if ($rank_tmp eq $rank_tmp13)
                                            {
                                                $count_matches_tmp++;
                                            }
                                            elsif (exists($read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp13}))
                                            {
                                                $count_matches_tmp++;
                                            }
                                            else
                                            {
                                                $count_total_tmp++;
                                                if ($first_no_match eq "")
                                                {
                                                    $first_no_match = $rank_tmp13;
                                                }
                                            }
                                        }
                                        elsif (exists($read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp13}))
                                        {
                                            if ($first_no_match eq "")
                                            {
                                                $first_no_match = $rank_tmp13;
                                            }
                                        }
                                    }
                                    if ($first_no_match eq "" && keys %split_patterns_final > 0.85*$total_nuc_count)
                                    {
                                        $first_no_match = $total_nuc_count;
                                    }									              
									if ($highest_count_matches eq "")
									{
										$highest_count_matches = $count_matches_tmp;
									}
									
									if (exists($pattern_list{$pattern_print}))
									{	
									}
									else
									{
										if ($highest_first_no_match eq "" || $score_tmp > $highest_avg_score*0.85)
										{
											$selected_patterns_count++;
										}
										
										print {$filehandle{$seed_id2}} $pattern_print." FINAL_READ_PATTERN_TEST ".$score_tmp." SCORE ".$first_no_match." FIRST_NO_MATCH\n";
										
										if (($count_matches_tmp > 2 || $score_tmp > $highest_avg_score*0.95 || $rank_count_tmp > $highest_rank_count) 
											&& (($score_tmp > $highest_avg_score*0.85)
											|| (($score_tmp > $highest_avg_score*0.3 || ($score_tmp*$count_matches_tmp > ($highest_avg_score*$highest_count_matches)/2)) && $score_tmp > 2 && $first_no_match > $highest_first_no_match && $rank_count_tmp > $highest_rank_count && $count_matches_tmp > $highest_count_matches)
											|| ($score_tmp > $highest_avg_score*0.7 && $first_no_match > $highest_first_no_match && $rank_count_tmp >= $highest_rank_count && $count_matches_tmp >= $highest_count_matches)
											|| ($score_tmp > $highest_avg_score*0.7 && $first_no_match >= $highest_first_no_match && $rank_count_tmp > $highest_rank_count && $count_matches_tmp > $highest_count_matches)
											|| ($score_tmp > $highest_avg_score*0.7 && $first_no_match > $highest_first_no_match && $count_matches_tmp eq $rank_count_tmp)
											|| ($score_tmp > $highest_avg_score*0.4 && $post_pattern_match_extra eq "yes" && $rank_count_tmp > $highest_rank_count)
											|| ($score_tmp > 5 && $rank_count_tmp > 2 && $SNP_check eq "yes2")
											|| ($score_tmp > $highest_avg_score-2 && $score_tmp > 2.5 && $rank_count_tmp > $highest_rank_count && $first_no_match >= $highest_first_no_match)
											|| ($score_tmp > $highest_avg_score*0.6 && ($post_pattern_match_extra eq "yes" || $SNP_check ne "") && ($first_no_match > $highest_first_no_match || $count_matches_tmp > $highest_count_matches))
											|| ($post_pattern_match eq "yes3" && $score_tmp > 1 && $count_matches_tmp > 3 && $first_no_match > $highest_first_no_match && $score_tmp > $highest_avg_score*0.3))
											&& ($count_matches_tmp > 1 || $highest_first_no_match eq "" || ($score_tmp > 10 && $rank_count_tmp > 3))
											&& ($first_no_match > $highest_first_no_match-3 || $highest_first_no_match eq "" || ($first_no_match >= $highest_first_no_match && $rank_count_tmp > $highest_rank_count)))
										{
											$highest_first_no_match = $first_no_match;
											$first_no_match{$score_tmp}{$rank_tmp}{$first_no_match} = undef;
											$rank_patterns{$score_tmp} = $rank_count_tmp." ".$first_no_match." ".$count_matches_tmp;
											print {$filehandle{$seed_id2}} "SELECT\n";
										}				

										if ($highest_avg_score2 eq "")
										{
											$highest_avg_score2 = $score_tmp;
										}
										$pattern_list{$pattern_print} = undef;
									}
                                }
                            }
							
							my $first_rank_tmp = "1";
							my %new_pattern_rank;
							undef %new_pattern_rank;

RANK_PATTERNS_PB:							
							
							my $high_score_tmp = "0";
							my $high_rank_count_tmp = "0";
							my $high_first_no_match_tmp = "0";
							my $high_count_matches_tmp = "0";
							
							foreach my $score_tmp2 (sort {$b <=> $a} keys %rank_patterns)
                            {
                                my @rank_patterns = split /\s/, $rank_patterns{$score_tmp2};
								if ($high_score_tmp eq "0"
								|| ($post_pattern_match_extra eq "yes" && $score_tmp2 > $high_score_tmp*0.7 && $rank_patterns[0] >= $high_rank_count_tmp && $rank_patterns[1] >= $high_first_no_match_tmp
								&& $rank_patterns[2] >= $high_count_matches_tmp && ($rank_patterns[0] > $high_rank_count_tmp || $rank_patterns[1] > $high_first_no_match_tmp))
                                || ($post_pattern_match eq "yes3" && $score_tmp2 > $high_score_tmp*0.4 && $rank_patterns[1] > $high_first_no_match_tmp && $rank_patterns[2] > $high_count_matches_tmp)
								|| ($post_pattern_match ne "yes3" && $score_tmp2 > $high_score_tmp*0.45 && ($score_tmp2 > 5 || $score_tmp2 > $high_score_tmp*0.8) && $rank_patterns[0] > $high_rank_count_tmp))
								{
									$high_score_tmp = $score_tmp2;
									$high_rank_count_tmp = $rank_patterns[0];
									$high_first_no_match_tmp = $rank_patterns[1];
									$high_count_matches_tmp = $rank_patterns[2];
                                }
                            }
							$new_pattern_rank{$first_rank_tmp}{$high_score_tmp} = undef;
							delete $rank_patterns{$high_score_tmp};
							
							if (keys %rank_patterns > 0)
							{
								$first_rank_tmp++;
								goto RANK_PATTERNS_PB;
							}							
							
READ_PATTERN_FINAL_PB0:    	foreach my $rankie_tmp (sort {$a <=> $b} keys %new_pattern_rank)
                            {
								foreach my $score_tmp (sort {$b <=> $a} keys %{$new_pattern_rank{$rankie_tmp}})
								{
									if (exists($first_no_match{$score_tmp}))
									{
READ_PATTERN_FINAL_PB:              	foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
										{                       
											if ($highest_first_no_match ne "")
											{
												if (exists($first_no_match{$score_tmp}{$rank_tmp}{$highest_first_no_match}))
												{   
												}
												else
												{
													next READ_PATTERN_FINAL_PB;
												}
											}
											my $pattern_print = $rank_tmp.";";
											my $count_ranks_tmp =  keys %{$read_patterns_final{$score_tmp}{$rank_tmp}};
																					
											foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
											{
												$pattern_print .= $rank_tmp2.";";
											}
		
											$reads_to_remove{$rank_tmp}{$rank_tmp} = $score_tmp;
											foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
											{
												$reads_to_remove{$rank_tmp}{$rank_tmp2} = $score_tmp;
												$remove_reads = "yes";
											}
											print {$filehandle{$seed_id2}} $pattern_print." FINAL_READ_PATTERN ".$score_tmp." SCORE\n";
											
											if ($remove_reads eq "yes")
											{
												$current_score = $score_tmp;
												$current_rank = $rank_tmp;	
												$remove_reads = "";
												my $pos_count_tmp = keys %{$pos_pattern_list{$current_score}{$current_rank}};
             									foreach my $rank_tmp0 (keys %reads_to_remove)
												{
													my $count_tmp = keys %{$reads_to_remove{$rank_tmp0}};
													my $SNP_pattern_average_remove = "";
													my $SNP_pattern_average_remove_tmp = '0';
													my $SNP_pattern_average_count = "";
													my $SNP_pattern_average_count_tmp = '0';
													my $cover_complete_assembly = "";
													
													if ($count_tmp > 0)
													{
														my $high_score_count = '0';
														my $high_score_count2 = '0';
														my $rank_one_check = "";
														my $score_diff_check = "";
														my $rank_tmp2 = "";
														
														foreach my $rank_tmp (sort {$a <=> $b} keys %{$reads_to_remove{$rank_tmp0}})
														{
															if ($rank_tmp <= 4)
															{
																$high_score_count++;
															}
															if ($rank_tmp <= 6)
															{
																$high_score_count2++;
															}
															if ($rank_tmp eq '1')
															{
																$rank_one_check = "yes";
																
																$rank_tmp2 = $rank_tmp;
																while (exists($reads_to_remove{$rank_tmp0}{$rank_tmp2}))
																{
																	$rank_tmp2++;
																}
																my $id_tmp01 = $rank_to_id{'1'};
																my $id_tmp02 = $rank_to_id{$rank_tmp2};
																my $score_tmp1 = "";
																my $score_tmp2 = "";
																foreach my $score_tmp (sort {$b <=> $a} keys %scores2)
																{
																	my @ids_tmp = split /,/, $scores2{$score_tmp};
																	foreach my $ids_tmp (@ids_tmp)
																	{
																		if ($ids_tmp eq $id_tmp01)
																		{
																			$score_tmp1 = $score_tmp;
																		}
																		if ($ids_tmp eq $id_tmp02)
																		{
																			$score_tmp2 = $score_tmp;
																		} 
																	}
																}
																if ($score_tmp2 > $score_tmp1*0.7)
																{
																	$score_diff_check = "yes";
																}
															}
															my $id_tmp = $rank_to_id{$rank_tmp};
															my $length_tmp = $alignment_length_save{$id_tmp};
															$SNP_pattern_average_remove_tmp += $pos_list_number{$rank_tmp}/$length_tmp;
															$SNP_pattern_average_count_tmp += $pos_list_number{$rank_tmp};										
				
															if (exists($rank_to_id{$rank_tmp}))
															{
																my $id_tmp = $rank_to_id{$rank_tmp};
																if (exists($extensions2{$id_tmp}))
																{
																	if ($alignment_length_save{$id_tmp} > length($read)-500)
																	{
																		$cover_complete_assembly = "yes";
																	}
																}
															}
														}
														
														$SNP_pattern_average_remove = $SNP_pattern_average_remove_tmp/$count_tmp;
														$SNP_pattern_average_count = $SNP_pattern_average_count_tmp/$count_tmp;
														
														print {$filehandle{$seed_id2}} $SNP_pattern_average_remove." SNP_PATTERN_AVERAGE_REMOVE\n";
														
														my $count_matches_tmp = '0';
														my $count_pos_no_matches_tmp = '0';
														my $count_no_matches_tmp = '0';
														my $first_no_match = "";
														my $first_no_match2 = '0';
														my $count_total_tmp = '0';
														my $nuc_match = $split_patterns_final{$rank_tmp0};
												
														foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
														{
															$count_total_tmp++;
															if ($split_patterns_final{$rank_tmp13} eq $nuc_match)
															{                                   
																if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp13}))
																{
																	$count_matches_tmp++;
																	if ($first_no_match eq "")
																	{
																		$first_no_match2++;
																	}
																}
																else
																{
																	my $no_match = "";
																	my $no_match_tmp = '0';
																	my $match_tmp = '0';
																	if (exists($rank_to_id{$rank_tmp13}))
																	{
																		my $id_tmpi = $rank_to_id{$rank_tmp13};
																		if (exists($alignment_length_save{$id_tmpi}))
																		{
																			my $overlap_tmp = $alignment_length_save{$id_tmpi};
																			
																			foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$pos_pattern_list{$current_score}{$current_rank}})
																			{
																				if ($position-$pos_snp_tmp < $overlap_tmp)
																				{
																					if (exists($store_mismatches_PB{$id_tmpi}{$pos_snp_tmp}))
																					{
																						$match_tmp++;
																					}
																					else
																					{
																						$no_match_tmp++;
																					}
																				}
																			} 
																		}
																		elsif ($first_no_match eq "")
																		{
																			$first_no_match = $rank_tmp13;
																		}
																	}
																	if ($no_match_tmp > 0 && $no_match_tmp > ($match_tmp+$no_match_tmp)*0.15)
																	{
																		$no_match = "yes";
																	}
																	
																	if ($no_match eq "" && $post_pattern_match ne "" && $count_matches_tmp > 2 && $count_no_matches_tmp < 2)
																	{
																		$count_matches_tmp++;
																	}
																	elsif ($no_match ne "")
																	{
																		$count_no_matches_tmp++;
																	}
																	if ($first_no_match eq "" && ($no_match ne "" || $match_tmp < 3))
																	{
																		$first_no_match = $rank_tmp13;
																	}
																	elsif ($first_no_match eq "")
																	{
																		$first_no_match2++;
																	}
																}
															}
															elsif (exists($reads_to_remove{$rank_tmp0}{$rank_tmp13}))
															{
																if ($first_no_match eq "")
																{
																	$first_no_match = $rank_tmp13;
																}
																$count_no_matches_tmp++;
															}
															else
															{          
																if (exists($rank_to_id{$rank_tmp13}))
																{
																	my $id_tmpi = $rank_to_id{$rank_tmp13};
																	if (exists($alignment_length_save{$id_tmpi}))
																	{
																		my $overlap_tmp = $alignment_length_save{$id_tmpi};
																		my $no_pos_match_tmp = '0';
																		my $pos_match_tmp = '0';
																		
																		foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$pos_pattern_list{$current_score}{$current_rank}})
																		{
																			if ($position-$pos_snp_tmp < $overlap_tmp)
																			{
																				$pos_match_tmp++;
																			}
																			else
																			{
																				$no_pos_match_tmp++;
																			}
																		}
																		if ($pos_match_tmp > 0 && $pos_match_tmp > 0.3*($pos_match_tmp+$no_pos_match_tmp))
																		{
																			$count_pos_no_matches_tmp++;
																		}           
																	}
																}
															}
														}
	
														if ($first_no_match eq "" && keys %split_patterns_final > 0.8*$total_nuc_count)
														{
															$first_no_match = $total_nuc_count;
															if ($first_no_match < 10)
															{
																$first_no_match = '20';
															}
														}
														
														if (($add_no_match_reads ne "" || $add_rejected_reads ne "") && (($rank_tmp > $add_no_match_reads && $add_no_match_reads ne "") || ($rank_tmp > $add_rejected_reads && $add_rejected_reads ne "")))
														{
															my $matches_count = '0';
															my $matches_no_count = '0';
															foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
															{
																if (($rank_tmp13 > $add_no_match_reads && $add_no_match_reads ne "") || ($rank_tmp13 > $add_rejected_reads && $add_rejected_reads ne ""))
																{
																	if (exists($read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp13}))
																	{
																		$matches_count++;
																	}
																	else
																	{
																		my $match_tmp = '0';
																		my $no_match_tmp = '0';
																		if (exists($rank_to_id{$rank_tmp13}))
																		{
																			my $id_tmpi = $rank_to_id{$rank_tmp13};
																			if (exists($alignment_length_save{$id_tmpi}))
																			{
																				my $overlap_tmp = $alignment_length_save{$id_tmpi};
	
																				foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$pos_pattern_list{$current_score}{$rank_tmp}})
																				{
																					if ($position-$pos_snp_tmp < $overlap_tmp)
																					{
																						if (exists($store_mismatches_PB{$id_tmpi}{$pos_snp_tmp}))
																						{
																							$match_tmp++;
																						}
																						else
																						{
																							$no_match_tmp++;
																						}
																					}
																				}
																				if ($match_tmp > 3 && $match_tmp > ($no_match_tmp+$match_tmp)*0.15)
																				{
																					$matches_count++;
																				}
																				else
																				{
																					$matches_no_count++;
																				}
																			}
																		}
																	}
																}
															}
															if ($matches_count > 0 && $matches_no_count eq '0')
															{
																foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
																{
																	if (($rank_tmp13 > $add_no_match_reads && $add_no_match_reads ne "") || ($rank_tmp13 > $add_rejected_reads && $add_rejected_reads ne ""))
																	{
																		$reads_to_remove{$rank_tmp0}{$rank_tmp13} = undef;
																		print {$filehandle{$seed_id2}} $rank_tmp13." ADD_REJ_READS\n";
																	}
																}
															}
														}
														if ($add_no_match_reads ne "" || $add_rejected_reads ne "")
														{	
															foreach my $rankie_tmp (sort {$a <=> $b} keys %new_pattern_rank)
															{
																foreach my $score_tmp (sort {$b <=> $a} keys %{$new_pattern_rank{$rankie_tmp}})
																{
																	if (exists($first_no_match{$score_tmp}) && $score_tmp > 2)
																	{
								                                    	foreach my $rank_tmp18 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
																		{
																			if (($rank_tmp18 > $add_no_match_reads && $add_no_match_reads ne "") || ($rank_tmp18 > $add_rejected_reads && $add_rejected_reads ne ""))
																			{
																				$reads_to_remove{$rank_tmp0}{$rank_tmp18} = undef;
																				print {$filehandle{$seed_id2}} $rank_tmp18." ADD_REJ_READS\n";
																			}
																			
																			foreach my $rank_tmp19 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp18}})
																			{
																				if (($rank_tmp19 > $add_no_match_reads && $add_no_match_reads ne "") || ($rank_tmp19 > $add_rejected_reads && $add_rejected_reads ne ""))
																				{
																					$reads_to_remove{$rank_tmp0}{$rank_tmp19} = undef;
																					print {$filehandle{$seed_id2}} $rank_tmp19." ADD_REJ_READS\n";
																				}
																			}
																		}
																	}
																}
															}
														}

														if ($count_pos_no_matches_tmp > 0 && $count_matches_tmp > 2 && $count_matches_tmp > 0.15*$count_total_tmp && $count_no_matches_tmp < 0.15*$count_matches_tmp
															&& ($first_no_match > 10 || ($first_no_match > 5 && $count_matches_tmp > 5) || $count_no_matches_tmp eq '0'))
														{
															print {$filehandle{$seed_id2}} $count_matches_tmp." ADD_ALL_SNP_PATTERN\n";
															foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
															{
																if ($split_patterns_final{$rank_tmp13} eq $nuc_match)
																{
																	if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp13}))
																	{                                                     
																	}
																	else
																	{
																		$reads_to_remove{$rank_tmp0}{$rank_tmp13} = undef;
																		if ($rank_tmp13 <= 4)
																		{
																			$high_score_count++;
																		}
																		if ($rank_tmp13 <= 6)
																		{
																			$high_score_count2++;
																		}
																	}
																}
															}
															if ($highest_first_no_match < 10)
															{
																$highest_first_no_match = '10';
															}
														}										
														
														if ($count_matches_tmp > 4 && $count_matches_tmp > 0.9*($count_no_matches_tmp+$count_matches_tmp) && $count_matches_tmp > $count_total_tmp*0.6)
														{
															if ($first_no_match < 10)
															{
																$first_no_match = '10';
																print {$filehandle{$seed_id2}} $first_no_match." CORRECT_FIRST_NO_MATCH\n";
															}
														}
														
														my $score_limit = '4';
														if ($first_rank_tmp eq "1" && $SNP_check eq "yes2")
														{
															$score_limit = '2';
														}
														
														print {$filehandle{$seed_id2}} $first_no_match." FIRST_NO_MATCH\n";
														if (($first_no_match < 10 && $first_no_match ne "" && $total_nuc_count < 9 && $current_score < 4)
															|| ($first_no_match < 10 && $current_score < 3 && $count_tmp < 3)
															|| ($post_pattern_match_extra ne "yes" && $count_tmp < 3 && $first_no_match < 10 && $current_score < 8)
															|| ($first_no_match < 7 && $current_score < $score_limit && $count_tmp < 5)
															|| ($post_pattern_match eq "" && $current_score < $score_limit && $first_no_match < 7)
															|| ($first_no_match < 7 && $current_score < 5 && $count_matches_tmp < $count_tmp)
															|| ($first_no_match < 10 && $current_score < 3 && $count_matches_tmp < $count_tmp)
															|| ($post_pattern_match_extra ne "yes" && $SNP_check eq "" && $current_score < 5)
															|| ($SNR_read_ahead ne "" && $post_pattern_match_extra ne "yes" && $current_score < 20 && $first_no_match < 10)
															|| ($high_score_count > 1 && $count_tmp < 4 && $current_score < 5)
															|| ($first_no_match < 7 && $total_nuc_count < 8 && $current_score < 10)
															|| ($high_score_count > 1 && $SNP_check ne "yes2" && $current_score < 8 && $post_pattern_match ne "yes3")
															|| ($high_score_count > 2 && $count_pos_no_matches_tmp < 2 && $post_pattern_match_extra eq "yes" && $current_score < 7 && $post_pattern_match ne "yes3" && ($first_no_match < 10 || $count_tmp < 5))
															|| ($high_score_count2 > 3 && $high_score_count > 2 && $current_score < 10 && $post_pattern_match ne "yes3" && ($first_no_match < 10 || $count_tmp < 5))
															|| ($first_no_match < 10 && $count_matches_tmp < 3 && $current_score < 4)
															|| ($first_no_match < 10 && $high_score_count2 > 1 && $current_score < 3 && $count_matches_tmp < $count_tmp)
															|| ($high_score_count2 > 4 && $high_score_count > 2 && $current_score < 10)
															|| ($count_tmp < 4 && $total_nuc_count < 10 && $first_no_match < 10 && ($post_pattern_match eq "" || $post_pattern_match eq "yes" || $post_pattern_match_average eq ""))
															|| ($first_no_match < 9 && $count_matches_tmp < 3 && $current_score < 5 && $total_nuc_count < 13))
														{     
															undef %reads_to_remove;
															#delete $read_patterns_final{$current_score}{$current_rank};
															print {$filehandle{$seed_id2}} $count_matches_tmp." COUNT_MATCHES ".$score_diff_check." CANCEL_REMOVE\n";
															$highest_first_no_match = "";
															$remove_reads = "";
															last READ_PATTERN_FINAL_PB;
														}
														else
														{
															$remove_reads = "yes";
															$high_score_save = $current_score;													
#Exclude reads------------------------                                              
															if ($count_matches_with_high_scores-$count_tmp > 8 && ($current_score > 5 || $first_no_match > 9))
															{
																$exclude_reads_check = "yes";	
															}
															if ($SNP_check ne "yes2" && ($first_no_match < 7 || $count_matches_tmp < 3 || $count_no_matches_tmp > 1))
															{
																$exclude_reads_check = "yes";	
															}
															last READ_PATTERN_FINAL_PB0;
														}
													}
												}
											}
										}
									}
                                }  
                            }
#-------------------                 
							my $count_pattern_lists = keys %reads_mismatch;
                            foreach my $nuc_tmp20 (keys %SNP_patterns_prev2)
                            {
                                if ($SNP_patterns_prev2{$nuc_tmp20} > $count_pattern_lists*0.25 && $SNP_patterns_prev2{$nuc_tmp20} > 1)
                                {
                                    print {$filehandle{$seed_id2}} $nuc_tmp20." ".$SNP_patterns_prev2{$nuc_tmp20}." PATTERN_MATCH_FINAL\n";
                                }
                            }
                        }
						
						if (($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") &&
                            $post_pattern_match_average eq "yes" && $post_pattern_match_extra eq "yes" && $remove_reads eq "" && $find_haps_in_seed eq "")
                        {
                            if ($assembly_length_max eq "WG" && $y eq "1" && ($first_back_assembly eq "" || length($read) < 5000))
							{
								print "GOTO_NEXT_SEED3\n";
								$first_back_assembly = "yes";
								goto END1;
							}
						}
						
#Resolve ambigious positions through other haplotype ----------------------------------------------------------------------------------------------                                   
						if ($find_haps_in_seed eq "" && $ext2_count > 0 && $merged_ext ne "" && $remove_reads eq "" && $SNR_read_ahead eq "")
						{
							my $nuc_highest_tmp = "";
							my $count_highest_tmp = '0';
							my $count_total_tmp = '0';
							my %nuc_tmp2;
							undef %nuc_tmp2;
	
							foreach my $ranki_tmp (sort {$a <=> $b} keys %subject_list)
							{
								if (exists($rank_to_id{$ranki_tmp}))
								{
									if (exists($extensions2{$rank_to_id{$ranki_tmp}}))
									{
										my $nuc_tmp = $nucs_by_rank{$ranki_tmp};
										$nuc_tmp2{$nuc_tmp} += 1;
										if ($nuc_tmp2{$nuc_tmp} > $count_highest_tmp)
										{
											$count_highest_tmp = $nuc_tmp2{$nuc_tmp};
											$nuc_highest_tmp = $nuc_tmp;
										}
										$count_total_tmp++;
									}
								}
							}
							
							print {$filehandle{$seed_id2}} $nuc_highest_tmp." NUC_HIGHEST\n";
	
							if ($nuc_highest_tmp ne "" && $nucs{$nuc_highest_tmp} > $total_nuc_count*0.2 && ($nucs{$nuc_highest_tmp} > $total_nuc_count*0.32 || $count_highest_tmp > 2
								|| ($SNP_check eq "yes2" && $count_matches_with_high_scores > $sequencing_depth_PB)) && $count_highest_tmp > 0.95*$count_total_tmp
								&& ($nucs{"a"}+$nucs{"c"}+$nucs{"t"}+$nucs{"g"}) > $total_nuc_count*0.9 && ($total_nuc_count > 4 || $post_pattern_match eq "yes3"))
							{
								foreach my $nuc_tmp (keys %nucs)
								{
									if ($nuc_tmp ne $nuc_highest_tmp)
									{
										foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
										{
											$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
											$remove_reads = "yes";
										}
									}
								}
								if ($remove_reads eq "yes")
                                {
                                    print {$filehandle{$seed_id2}} $nuc_highest_tmp." N_CORRECTION\n";
                                    goto REMOVE_READS_PB;
                                }
							}
							elsif ($nuc_highest_tmp ne "" && $nucs{$nuc_highest_tmp} > $total_nuc_count*0.2 && ($nucs{$nuc_highest_tmp} > $total_nuc_count*0.35 || $count_highest_tmp > 2
								|| ($SNP_check eq "yes2" && $count_matches_with_high_scores > $sequencing_depth_PB)) && $count_highest_tmp > 0.95*$count_total_tmp && ($total_nuc_count > 5 || $post_pattern_match eq "yes3"))
							{
								$nuc_match = $nuc_highest_tmp;
								$nuc_match =~ tr/actgn/ACTGN/;
								if ($nuc_highest_tmp eq "-")
								{
									$nuc_match = "";
								}
								$best_extension .= $nuc_match;
								
								if ($nuc_highest_tmp eq "-")
								{
								}
								else
								{
									$quality_scores_tmp{length($best_extension)} = $count_highest_tmp/$count_total_tmp;
								}
		
								print {$filehandle{$seed_id2}} $nuc_match." N_CORRECTION2\n";
								goto SKIP_INPUT_BLAST3_PB
							}
						}
						
#Select based on average score of each group---------------------------------------------------------------------------                                           
                        
                        if (($post_pattern_match eq "yes3" || ($SNP_check eq "yes2" && $post_pattern_match_average ne "") || ($post_pattern_match_average eq "yes" && $post_pattern_match_extra eq "yes")) && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3")
							&& ($total_nuc_count > 10 || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") && $remove_reads eq "" && $find_haps_in_seed eq "" && $add_no_match_reads eq "" && $add_rejected_reads eq "")
                        {
							my %average_rank_score_first;
							undef %average_rank_score_first;
                            my %average_rank_score_firstb;
							undef %average_rank_score_firstb;
                            my $highest_nuc_tmp = "";
                            my $hihest_score_tmp = '0';
                            
                            foreach my $nuc_tmp (sort {$a <=> $b} keys %split_patterns_final_score)
                            {
                                my $rank_score = '0';
                                my $rank_count = '0';

                                foreach my $rank_tmp (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp}})
                                {
                                    my $score_tmp = '0';
                                    if (exists($rank_to_id{$rank_tmp}))
                                    {
                                        my $id_tmp = $rank_to_id{$rank_tmp};
                                        if (exists($scores{$id_tmp}))
                                        {
                                            $score_tmp = $scores{$id_tmp};
                                        }
                                    }
                                    if ($rank_score eq '0')
                                    {
                                        $average_rank_score_first{$nuc_tmp} = $score_tmp;
                                        $average_rank_score_firstb{$nuc_tmp} = $rank_tmp;
                                    }
                                    $rank_score += $score_tmp;
                                    $rank_count++;
                                }
                                my $average_rank = $rank_score/$rank_count;
                                if ($rank_count > 1 && $rank_count > $total_nuc_count*0.14)
                                {
                                    $average_rank_score{$nuc_tmp} = $average_rank;
                                    print {$filehandle{$seed_id2}} $nuc_tmp." ".$average_rank." AVERAGE_RANK\n";
                                    if ($average_rank > $hihest_score_tmp && $highest_nuc_tmp ne "-")
                                    {
                                        $hihest_score_tmp = $average_rank;
                                        $highest_nuc_tmp = $nuc_tmp;
                                    }
                                } 
                            }
                            if (exists($average_rank_score{$first_rank}))
                            {         
                                my $nuc_best = "";
                                foreach my $nuc_tmp (keys %average_rank_score)
                                {
                                    print {$filehandle{$seed_id2}} $average_rank_score{$first_rank}." ".$average_rank_score{$nuc_tmp}." ".$average_rank_score_firstb{$nuc_tmp}." AVERAGE_RANK2\n";
									my $count_ranks = keys %{$SNP_patterns_now{$nuc_tmp}};
                                    if (($count_ranks > 1 && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2")) && $nuc_tmp ne $first_rank &&
                                        ($average_rank_score{$first_rank}*0.4 > $average_rank_score{$nuc_tmp} || ($average_rank_score_first{$first_rank} > 2*$average_rank_score_first{$nuc_tmp} && $average_rank_score_firstb{$nuc_tmp} > 5)
                                       || ($post_pattern_match eq "yes3" && $average_rank_score{$first_rank}*0.7 > $average_rank_score{$nuc_tmp}
                                        && $average_rank_score_firstb{$nuc_tmp}/$total_nuc_count > 0.3 && $average_rank_score_firstb{$nuc_tmp} > 2)
                                    || (($post_pattern_match_average eq "yes" || $post_pattern_match_extra eq "yes") && $average_rank_score{$first_rank}*0.5 > $average_rank_score{$nuc_tmp}
                                        && $average_rank_score_firstb{$nuc_tmp}/$total_nuc_count > 0.5)))
                                    {
                                        if (($post_pattern_match_extra eq "yes" && $post_pattern_match_average eq "yes") || ($count_ranks > 1 && $SNP_check eq "yes2" && $total_nuc_count > 9))
                                        {
                                            my $count_tmpi = '0';
                                            foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
                                            {
                                                if ($rank_tmp < 7)
                                                {
                                                    last;
                                                } 
                                                $reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
                                                $remove_reads = "yes";
                                            }
                                        }
										else
										{
											my $count_tmpi = '0';
                                            foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
                                            {
                                                if ($rank_tmp < 7)
                                                {
                                                    $nuc_best = "no";
                                                }
                                            }
										}
                                    }
                                    else
                                    {
                                        if ($nuc_best eq "")
                                        {
                                            $nuc_best = $nuc_tmp;
                                        }
                                        else
                                        {
                                            $nuc_best = "no";
                                        }
                                    }
                                }
                     
                                if ($remove_reads eq "yes")
                                {
                                    print {$filehandle{$seed_id2}} "REMOVE_BOTTOM_SCORES\n";
                                    goto REMOVE_READS_PB;
                                }
                            }
							my $nuc_highest_tmp = "";
                            my $count_highest_tmp = '0';
                            my $count_total_tmp = '0';
                            my $count_total_ext2 = '0';
                            my %nuc_tmp2;
							undef %nuc_tmp2;
    
                            foreach my $ranki_tmp (sort {$a <=> $b} keys %subject_list)
                            {
                                if (exists($rank_to_id{$ranki_tmp}))
                                {
                                    my $id_tmp = $rank_to_id{$ranki_tmp};
                                    if (exists($extensions2{$id_tmp}))
                                    {
                                        if ($alignment_length_save{$id_tmp} > length($read)-500)
                                        {
											my $nuc_tmp = $nucs_by_rank{$ranki_tmp};
                                            $nuc_tmp2{$nuc_tmp} += 1;
                                            if ($nuc_tmp2{$nuc_tmp} > $count_highest_tmp)
                                            {
                                                $count_highest_tmp = $nuc_tmp2{$nuc_tmp};
                                                $nuc_highest_tmp = $nuc_tmp;
                                            }
                                            $count_total_tmp++;
                                        }
                                    }
                                    $count_total_ext2++;
                                }
                            }
    
                            if ($nuc_highest_tmp ne "" && $count_highest_tmp > $total_nuc_count*0.1 && $count_highest_tmp > 1
                                && $count_highest_tmp eq $count_total_tmp && $nucs{$nuc_highest_tmp} > $total_nuc_count*0.3)
                            {
                                if ($SNP_check ne "")
                                {
                                    my $count_tmpi = '0';
                                    foreach my $nuc_tmp (keys %SNP_patterns_now)
                                    {
                                        if ($nuc_tmp ne $nuc_highest_tmp && $nuc_tmp ne "-" && $nucs{$nuc_tmp} > $total_nuc_count*0.2)
                                        {
                                            foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
                                            {
                                                if ($rank_tmp < 5)
                                                {
                                                    $remove_reads = "";
                                                    undef %reads_to_remove;
													last;
                                                }
                                                if ($rank_tmp < 10)
                                                {
                                                    $count_tmpi++;
                                                    if ($count_tmpi > 1)
                                                    {
                                                        $remove_reads = "";
                                                        undef %reads_to_remove;
                                                        last;
                                                    }
                                                }
                                                $reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
                                                $remove_reads = "yes";
                                            }
                                        }
                                    }
                                    if ($remove_reads eq "yes")
                                    {
                                        print {$filehandle{$seed_id2}} "REMOVE_BOTTOM_SCORES2\n";
                                        goto REMOVE_READS_NP;
                                    }
                                }
                            }
						}
						
						my $lowest_longest_match_nuc = "";
						foreach my $nuc_tmp14 (keys %longest_match)
						{
							my $longest_match_tmp = $longest_match{$nuc_tmp14};
							if ($lowest_longest_match eq "" || $longest_match_tmp < $lowest_longest_match)
							{
								$lowest_longest_match = $longest_match_tmp;
								$lowest_longest_match_nuc = $nuc_tmp14;
							}
							if ($longest_longest_match eq "" || $longest_match_tmp > $longest_longest_match)
							{
								$longest_longest_match = $longest_match_tmp;
							}
						}
						
#Select reads based on length--------------------------------------------------------------------------------------  
						if ($remove_reads eq "" && ($total_nuc_count > 10 || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") &&
                            ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3") && ($SNR_read_ahead eq ""|| $post_pattern_match eq "yes3") && $find_haps_in_seed eq "")
                        {  						
							my $count_tmp2 = '0';
							if ($longest_longest_match > $lowest_longest_match*2)
							{
								foreach my $nuc_tmp11 (keys %longest_match2)
								{
									if ($nuc_tmp11 ne $longest_longest_match_nuc)
									{
										foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp11}})
										{
											if ($length_tmp14 > $longest_longest_match/2)
											{
												$count_tmp2 = '0';
												last;
											}
											else
											{
												$count_tmp2++;
											}
										}
									}
								}
								my $count_tmp3 = '0';					
								foreach my $nuc_tmp14 (keys %longest_match2)
								{
									if ($nuc_tmp14 eq $longest_longest_match_nuc)
									{
										foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp14}})
										{
											$count_tmp3++;
										}
									}
								}
								if ($count_tmp2 > 1 && $count_tmp3 > $sequencing_depth_PB/15 && $count_tmp3 > 2)
								{
									$remove_reads = "yes";
									print {$filehandle{$seed_id2}} $count_tmp3." REMOVE_BY_LENGTH2\n";
									
									foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
									{
										if ($split_patterns_final{$rank_tmp} eq $lowest_longest_match_nuc)
										{
											$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
										}
									}
									goto REMOVE_READS_PB;
								}
							}
							
							my %second_longest;
							undef %second_longest;
							foreach my $nuc_tmp11 (keys %longest_match2)
							{
								my $second_check = "";
								foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp11}})
								{
									if ($second_check eq "")
									{
										$second_check = "yes";
										next;
									}
									else
									{
										$second_longest{$length_tmp14} = $nuc_tmp11;
										last;
									}
								}
							}
							if ($total_nuc_count > 20)
							{
								my $highest = "";
								my $highest_nuc = "";
								foreach my $length_tmp15 (sort {$b <=> $a} keys %second_longest)
								{
									if ($highest eq "")
									{
										$highest = $length_tmp15;
										$highest_nuc = $second_longest{$length_tmp15};
									}
									elsif ($length_tmp15 < $highest/4 && $length_tmp15 < 6000)
									{
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $count_tmp2." REMOVE_BY_LENGTH3\n";
										
										foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
										{
											if ($split_patterns_final{$rank_tmp} eq $second_longest{$length_tmp15})
											{
												$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
											}
										}
										goto REMOVE_READS_PB;
									}
								}
							}
						}
						
#Add rejected reads to mafft-------------------------------------------------------------------------------------------------------------------------------                                        
	
						if ($add_rejected_reads eq "" && $add_no_match_reads eq "" && $remove_reads eq "" && ($total_nuc_count > 10 || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") &&
                            ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3") && ($SNR_read_ahead eq ""|| $post_pattern_match eq "yes3") && $find_haps_in_seed eq "")
                        {    
NEW_LONGEST_MATCH_PB:							
							print {$filehandle{$seed_id2}} $lowest_longest_match." ADD_REJECTED_READS\n";   

                            my $count_tmp = '0';
                            my $count_tmp3 = '0';
                            my %read_start_pos_rej_tmp;
							undef %read_start_pos_rej_tmp;

                            foreach my $id_tmp5 (keys %read_start_pos_rej)
                            {                                   
								if ($read_start_pos_rej{$id_tmp5} > $lowest_longest_match-60 && length($read) > 1000)
                                {
                                    $count_tmp++;
									print {$filehandle{$seed_id2}} $read_start_pos_rej{$id_tmp5}." REJ\n";  
                                    if (exists($read_start_pos_rej_tmp{$read_start_pos_rej{$id_tmp5}}))
                                    {
                                        $read_start_pos_rej_tmp{$read_start_pos_rej{$id_tmp5}}{$id_tmp5} = undef;
                                    }
                                    else
                                    {
                                        my $check_tmp = "";
                                        foreach my $pos_tmp1 (keys %read_start_pos_rej_tmp)
                                        {
                                            if ($pos_tmp1 > $read_start_pos_rej{$id_tmp5}-550 && $pos_tmp1 < $read_start_pos_rej{$id_tmp5}+550)
                                            {
                                                $read_start_pos_rej_tmp{$pos_tmp1}{$id_tmp5} = undef;
                                                $check_tmp = "yes";
                                                last;
                                            }
                                        }
                                        if ($check_tmp eq "")
                                        {
                                            $read_start_pos_rej_tmp{$read_start_pos_rej{$id_tmp5}}{$id_tmp5} = undef;
                                        }
                                    }
                                }
                            }
							my $longest_count3 = '0';
                            foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
                            {
                                if (keys %{$read_start_pos_rej_tmp{$pos_tmp5}} > 1)
                                {
                                    $count_tmp3++;
									if ($pos_tmp5 > $longest_count3)
									{
										$longest_count3 = $pos_tmp5;
									}
                                }
                            }
							my $singles = '0';
							my $extra_check = "yes";
							foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
                            {
                                my $co_tmp = keys %{$read_start_pos_rej_tmp{$pos_tmp5}};
								if ($co_tmp > 1)
                                {
									if ($co_tmp > 2 || $pos_tmp5 < $longest_longest_match+60)
									{
										$extra_check = "yes";
									}
                                }
								elsif ($pos_tmp5 > $longest_count3*0.7)
								{
									$singles++;
								}
                            }

							print {$filehandle{$seed_id2}} $count_tmp." COUNT_TMP\n";  
                            print {$filehandle{$seed_id2}} $count_tmp3." COUNT_TMP3\n";   
                            if ($count_tmp > 1 && $count_tmp3 > 0 && $count_tmp3 < 4 && $extra_check eq "yes" && ($singles eq '0' || $singles < $count_tmp*0.2) && $count_tmp < 30)
                            {
                                my $ff = keys %read_start_pos_rej_tmp;
								print {$filehandle{$seed_id2}} $ff." KEYS_REJ\n";  
								undef %id_matches;
															
                                foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
                                {                                   
									my $rej_reads_count = keys %{$read_start_pos_rej_tmp{$pos_tmp5}};
									if ($rej_reads_count > 1)
									{
										foreach my $id_tmp5 (sort {$a <=> $b} keys %{$read_start_pos_rej_tmp{$pos_tmp5}})
										{ 
											print {$filehandle{$seed_id2}} $id_tmp5." ID ".$pos_tmp5." POS_REJ\n";
											
											if (exists($read_start_pos_rej_saved{$id_tmp5}))
											{
												$id_matches{$id_tmp5} = undef;
												print {$filehandle{$seed_id2}} $id_tmp5." ID ".$pos_tmp5." POS_REJ000\n";
												delete $save_alignment_data_PB{$seed_id}{$id_tmp5};
												delete $read_start_pos_rej{$id_tmp5};
											}
											else
											{
												my $long_read_tmp = "";
												if (exists($reverse_list{$id_tmp5}))
												{
													$long_read_tmp = reverse($hash_PB_reads_tmp{$id_tmp5});
													$long_read_tmp =~ tr/ACTG/TGAC/;
												}
												else
												{
													$long_read_tmp = $hash_PB_reads_tmp{$id_tmp5};
												}
												
												my $long_read_end_pos_tmp = $long_read_end_pos_save{$id_tmp5};
												my $ext = substr $long_read_tmp, $long_read_end_pos_tmp-90, $length_extension;
												if (exists($scores2{'0'}))
												{
													$scores2{'0'} .= ",$id_tmp5"; 
												}
												else
												{
													$scores2{'0'} = $id_tmp5;
												}
												$extensions2_tmp{$id_tmp5} = $ext;
											}
										}
									}
                                }
								foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
								{
									if (exists($split_positions_VIP{$id}{$pos_tmp14}))
									{}
									elsif ($pos_tmp14 > $position+length($best_extension)+150)
									{
										 delete $split_positions_DUP{$id}{$pos_tmp14};
										 delete $split_positions_DUP2{$id}{$pos_tmp14};
									}
								}
                                $add_rejected_reads = $total_nuc_count_original;
								$add_rejected_reads_pos = length($best_extension);
								
                                print {$filehandle{$seed_id2}} $best_extension."\nHALLE1\n";
                                $mismatch_retry++;
                                $best_extension = "";
								$best_extension_part = "";
                                undef %quality_scores_tmp;
                                $remove_reads_check = "";
                                
                                if (keys %id_matches > 0)
                                {
                                    goto ADD_REJ_POS_PB;
                                }
                                goto SELECT_LENGTH_PB2;   
                            }
							elsif ($count_tmp > 24)
							{
								my $length_check = "";
								foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
								{
									if (keys %{$read_start_pos_rej_tmp{$pos_tmp5}} > 1)
									{
										if ($pos_tmp5 > $longest_longest_match)
										{
											$length_check = "yes";
										}
									}
								}
								if ($length_check eq "" && $lowest_longest_match < $longest_longest_match/2 && $longest_longest_match > 7000)
								{
									foreach my $nuc_tmp (keys %SNP_patterns_now)
                                    {
                                        if ($nuc_tmp eq $lowest_longest_match)
                                        {
                                            foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
                                            {
                                                if ($rank_tmp < 10)
                                                {
                                                    $remove_reads = "";
                                                    undef %reads_to_remove;
													last;
                                                }
                                                $reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
                                                $remove_reads = "yes";
												 print {$filehandle{$seed_id2}} $nuc_tmp." REMOVE_BY_LENGTH_AND_REJ\n";
                                            }
                                        }
                                    }
								}
							}
                        }
                        elsif ($add_rejected_reads ne "" && $longest_longest_match_nuc ne "" && $remove_reads eq "" && length($best_extension) > $add_rejected_reads_pos-20 && length($best_extension) < $add_rejected_reads_pos+20
							   && ($post_pattern_match eq "yes3" || ($SNP_check eq "yes2" && $post_pattern_match_average eq "yes")))
                        {          
                            print {$filehandle{$seed_id2}} $longest_longest_match_nuc." LONGEST_NUC\n";
							
							my $second_longest = $longest_longest_match;
							my $longest_longest_match_id = "";
							foreach my $id_tmp99 (keys %alignment_length_save)
							{
								if ($alignment_length_save{$id_tmp99} eq $longest_longest_match)
								{
									$longest_longest_match_id = $id_tmp99;
									last;
								}
							}
							foreach my $nuc_tmp11 (keys %longest_match2)
							{
								if ($nuc_tmp11 eq $longest_longest_match_nuc && $longest_longest_match+$length_ext_all{$longest_longest_match_id} > $average_length_PB*1.5)
								{
									my $check_tmp = "";
									foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp11}})
									{
										if ($check_tmp eq "")
										{
											$check_tmp = "yes";
											next;
										}
										else
										{
											$second_longest = $length_tmp14;
											print {$filehandle{$seed_id2}} $second_longest." SECOND_LONGEST\n";
											last;
										}
									}
								}
							}
									
							foreach my $nuc_rej_tmp (keys %nucs_rej)
                            {
                                print {$filehandle{$seed_id2}} $nuc_rej_tmp." NUC_REJ\n";
								if ($nuc_rej_tmp eq $longest_longest_match_nuc && $nucs_rej{$nuc_rej_tmp} > $total_nuc_count_rej*0.04 && $longest_longest_match > $lowest_longest_match+1000 && $second_longest > $lowest_longest_match)
                                {
                                    goto REMOVE_READS_PB;
                                }
                            }
							my $count_tmp = keys %nucs_rej;
							if ($count_tmp > 1)
							{
								goto REMOVE_READS_PB;
							}
							
                            foreach my $nuc_rej_tmp (keys %nucs_rej)
                            {		
								my $count_tmp2 = "0";
								my $length_check = "";
								foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
								{
									if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
									{
										$count_tmp2++;
										my $id_tmp8 = $rank_to_id{$rank_tmp8};
										if ($longest_match{$nuc_rej_tmp} > $alignment_length_save{$id_tmp8})
										{
											#$length_check = "no"
										}
									}
								}
								
								my $good_nuc = "";
								foreach my $nuc_tmp8 (keys %split_patterns_final_score)
								{
									if ($nuc_tmp8 ne $nuc_rej_tmp && $good_nuc eq "")
									{
										$good_nuc = $nuc_tmp8
									}
									elsif ($nuc_tmp8 ne $nuc_rej_tmp)
									{
										$good_nuc = "";
										last;
									}
								}
									
								if ($length_check eq "" && ($nucs_rej{$nuc_rej_tmp} > 1
									|| ($nucs_rej{$nuc_rej_tmp} > 0 && $post_pattern_match eq "yes3" && $nuc_rej_tmp ne $longest_longest_match_nuc))
									&& $count_tmp2 > 0.15*$total_nuc_count_original && $good_nuc ne "" && ($nuc_rej_tmp ne $longest_longest_match_nuc || $second_longest < $lowest_longest_match))
                                {
                                    $remove_reads = "yes";
                                    print {$filehandle{$seed_id2}} $add_rejected_reads." REMOVE_BY_REJECTED_READS0\n";
                                    print {$filehandle{$seed_id2}} $nuc_rej_tmp." REMOVE_BY_REJECTED_READS1\n";
                                    print {$filehandle{$seed_id2}} $total_nuc_count_rej." TOTAL_NUC_REJ\n";
                                    $add_rejected_reads = "";
									$add_rejected_reads_pos = "";
                                    
                                    foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
                                    {
                                        if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
                                        {
                                            $reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
                                            my $id_tmp0 = $rank_to_id{$rank_tmp8};
                                            delete $read_start_pos_rej{$id_tmp0};
                                        }
                                    }
                                    foreach my $id_tmp5 (keys %read_start_pos_rej)
                                    {
                                        delete $extensions2_tmp{$id_tmp5};
                                    }
                                    delete $scores2{'0'};
	
									my $last_11 = substr $best_extension, -11, 11;
									$track_split_PB{$id}{$position+length($best_extension)} = $last_11."+".$good_nuc;
									foreach my $posie_tmp (keys %SNP_patterns_prev_match)
									{
										my $last_11_tmp = substr $best_extension, $posie_tmp-$position-11, 11;
										$track_split_PB{$id}{$posie_tmp} = $last_11_tmp."+".$SNP_patterns_prev_match{$posie_tmp};
									}
                                }
                            }
                        }
						
#Add no match reads to mafft-------------------------------------------------------------------------------------------------------------------------------                                        
                        			
						if ($add_no_match_reads eq "" && $add_rejected_reads eq "" && $add_no_match_reads_stop eq "" && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3")
							&& ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3") && $remove_reads eq "" && $extensions_nomatch2b_count+$extensions_nomatch2b_count_saved > 0 && $find_haps_in_seed eq ""
							 && ($total_nuc_count > 10 || $post_pattern_match eq "yes3" || $SNP_check eq "yes2"))
                        {          
							my $score_score_no_match = '0';
							my $score_score_no_match2 = '0';
							my %extensions_nomatch2b_tmp;
							undef %extensions_nomatch2b_tmp;

							foreach my $ext_id_tmp (keys %extensions_nomatch2b_saved)
							{
								if (exists($extensions_nomatch2b{$ext_id_tmp}))
								{}
								else
								{
									foreach my $score_no_match_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}})
									{
										foreach my $score_match_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_no_match_tmp}})
										{
											foreach my $aln_length_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_no_match_tmp}{$score_match_tmp}})
											{
												foreach my $pos_prev_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_no_match_tmp}{$score_match_tmp}{$aln_length_tmp}})
												{
													if ($extensions_nomatch2b_saved{$ext_id_tmp}{$score_no_match_tmp}{$score_match_tmp}{$aln_length_tmp}{$pos_prev_tmp}+$pos_prev_tmp > $position+length($best_extension)
														&& $position-$pos_prev_tmp+$aln_length_tmp > $lowest_longest_match)
													{
														$score_score_no_match++;
														print {$filehandle{$seed_id2}} $ext_id_tmp." ADD_NOMATCH_SAVED\n";
														$extensions_nomatch2b_tmp{$ext_id_tmp} = undef;
														if ($score_match_tmp eq '0')
														{
															$score_score_no_match2++;
														}
													}
												}
											}
										}
									}
								}
							}

							foreach my $ext_id_tmp (keys %extensions_nomatch2b)
							{
								foreach my $ext_tmp (keys %{$extensions_nomatch2b{$ext_id_tmp}})
								{
									foreach my $score_no_match_tmp (keys %{$extensions_nomatch2b{$ext_id_tmp}{$ext_tmp}})
									{
										if (length($ext_tmp) > length($best_extension) && $alignment_length_save{$ext_id_tmp} > $lowest_longest_match)
										{
											$score_score_no_match++;
											print {$filehandle{$seed_id2}} $ext_id_tmp." ADD_NOMATCH\n";
											$extensions_nomatch2b_tmp{$ext_id_tmp} = undef;
											if ($extensions_nomatch2b{$ext_id_tmp}{$ext_tmp}{$score_no_match_tmp} eq '0')
											{
												$score_score_no_match2++;
											}
										} 
									}
								}
							}
							print {$filehandle{$seed_id2}} $score_score_no_match." SCORE_NO_SCORE_MATCH\n";   
							if (($score_score_no_match > 0 && ($score_score_no_match > 1 || $score_score_no_match2 > 0) && ((keys %scores2 < $sequencing_depth_PB*4 && $compare_haps_stop eq "") || $score_score_no_match > 2)) && $score_score_no_match < 65)
							{
								undef %id_matches;
								foreach my $id_tmp55 (keys %extensions_nomatch2b_tmp)
								{	
									if (exists($extensions_nomatch2b_saved{$id_tmp55}))
									{
										$id_matches{$id_tmp55} = undef;
										#delete $save_alignment_data_PB{$seed_id}{$ext_id_tmp};
									}
									if (exists($extensions_nomatch2b{$id_tmp55}))
									{
										if (exists($scores2{'0'}))
										{
											$scores2{'0'} .= ",$id_tmp55"; 
										}
										else
										{
											$scores2{'0'} = $id_tmp55;
										}
										foreach my $ext_tmp (keys %{$extensions_nomatch2b{$id_tmp55}})
										{
											$extensions2_tmp{$id_tmp55} = $ext_tmp; 
										}
									}
								}
								foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
								{
									if (exists($split_positions_VIP{$id}{$pos_tmp14}))
									{}
									elsif ($pos_tmp14 > $position+length($best_extension)+150)
									{
										 delete $split_positions_DUP{$id}{$pos_tmp14};
										 delete $split_positions_DUP2{$id}{$pos_tmp14};
									}
								}
								$add_no_match_reads = $total_nuc_count_original;
								$add_no_match_reads_pos = $lowest_longest_match;
								print {$filehandle{$seed_id2}} $best_extension."\nHALLE0\n";
								$mismatch_retry++;
								$best_extension = "";
								$best_extension_part = "";
								$remove_reads_check = "";
								undef %quality_scores_tmp;
								
								if (keys %id_matches > 0)
								{
									goto ADD_REJ_POS_PB;
								}
								goto SELECT_LENGTH_PB2;
							}
                        }
						elsif ($add_no_match_reads ne "" && $remove_reads eq "" && ($post_pattern_match eq "yes3" || ($SNP_check eq "yes2" && $post_pattern_match_average eq "yes")))
                        {                     
#Check if nomatch reads have same SNP patterns as matched reads-----------------------------------------------------------------				
							
							my %reads_exclude_splits;
							undef %reads_exclude_splits;
							foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
							{
								if ($rank_tmp8 > $add_no_match_reads)
								{
									my $id_tmp0 = $rank_to_id{$rank_tmp8};
									foreach my $pos_tmp (keys %SNP_no_matches)
									{
										if (exists($SNP_no_matches{$pos_tmp}{$id_tmp0}))
										{
											foreach my $nuc_tmp (sort {$a <=> $b} keys %split_patterns_final_score)
											{
												my $rank_count_tmp = keys %{$split_patterns_final_score{$nuc_tmp}};
												if ($rank_count_tmp > $total_nuc_count*0.18)
												{
													foreach my $rank_tmp (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp}})
													{
														if (exists($rank_to_id{$rank_tmp}))
														{
															my $id_tmp3 = $rank_to_id{$rank_tmp};
															if (exists($SNP_matches{$pos_tmp}{$id_tmp3}))
															{
																$reads_exclude_splits{$rank_tmp8}{$nuc_tmp} = undef;
															}
														}
													}
												}
											}
										}
									}
								}
							}
							
							foreach my $rank_tmp9 (sort {$a <=> $b} keys %reads_exclude_splits)
							{
								if (keys %{$reads_exclude_splits{$rank_tmp9}} > 1)
								{
									$reads_to_remove{$rank_tmp9}{$rank_tmp9} = undef;
									my $id_tmp0 = $rank_to_id{$rank_tmp9};
									delete $extensions2_tmp{$id_tmp0};
									$remove_reads = "yes";
								}
							}
#-------------------------------------------------------------------------------------------------------------------------------				
							
							my $no_match_count_tmp = keys %nucs_rej;
							
							if ($remove_reads eq "yes")
							{}
							elsif ($no_match_count_tmp > 1)
							{
								print {$filehandle{$seed_id2}} $no_match_count_tmp." CANCEL_NO_MATCH\n";
								goto REMOVE_READS_PB0;
							}
							else
							{
								foreach my $nuc_rej_tmp (keys %nucs_rej)
								{
									if ($nucs_rej{$nuc_rej_tmp} eq 1 && $SNP_check ne "yes2")
									{
										print {$filehandle{$seed_id2}} $no_match_count_tmp." SKIP_NO_MATCH\n";
										goto REMOVE_READS_PB0;
									}
									my $count_tmp = $nucs_rej{$nuc_rej_tmp};
									foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
									{
										if ($rank_tmp8 > $add_no_match_reads && $split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
										{
											if (exists($reads_exclude_splits{$rank_tmp8}{$nuc_rej_tmp}))
											{
												$count_tmp--;
											}
										}
									}
									if ($nucs_rej{$nuc_rej_tmp} > 0 && $count_tmp > 0)
									{
										my $count_removed = '0';
										foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
										{
											if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
											{
												$count_removed++;
											}
											if ($count_removed > 4 && $rank_tmp8 eq "5")
											{
												print {$filehandle{$seed_id2}} $no_match_count_tmp." CANCEL_NO_MATCH\n";
												goto REMOVE_READS_PB0;
											}
										}
										if ($total_nuc_count_original-$count_removed < 4)
										{
											goto REMOVE_READS_PB0;
										}
										
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $add_no_match_reads." REMOVE_BY_NO_MATCH_READS0\n";
										print {$filehandle{$seed_id2}} $nuc_rej_tmp." REMOVE_BY_NO_MATCH_READS1\n";
										print {$filehandle{$seed_id2}} $total_nuc_count_rej." TOTAL_NUC_REJ\n";
										$add_no_match_reads = "";
										$add_no_match_reads_pos = "";
										
										foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
										{
											if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
											{
												$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
												my $id_tmp0 = $rank_to_id{$rank_tmp8};
											}
										}
										foreach my $id_tmp5 (keys %extensions_nomatch2b)
										{
											delete $extensions2_tmp{$id_tmp5};
										}
										delete $scores2{'0'};
									}
								}
							}
REMOVE_READS_PB0:
							if ($remove_reads eq "" && $post_pattern_match eq "yes3")
							{
								$add_no_match_reads_stop = "yes";
								foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
                                {
                                    if ($rank_tmp8 > $add_no_match_reads)
									{
										$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
									}
								}
								$add_no_match_reads = "";
								$add_no_match_reads_pos = "";
								foreach my $id_tmp5 (keys %extensions_nomatch2b)
								{
									delete $extensions2_tmp{$id_tmp5};
								}
								delete $scores2{'0'};
							}
                        }
						
REMOVE_READS_PB:                            
                        if (keys %reads_to_remove > 0)
						{}
						elsif ($remove_reads ne "")
						{
							$remove_reads = "";
							print {$filehandle{$seed_id2}} "REMOVE_ERROR\n";
							goto BASECALL2_PB;
						}
						if ($remove_reads eq "yes")
                        {
                            my $removed_reads_tmp = '0';
                            my $highest_nuc = "";
                            my $add_rejected_reads_new = '0';
							
							my $reads_to_remove = '0';
							foreach my $rank_tmp0 (keys %reads_to_remove)
                            {
								foreach my $rank_tmp2 (keys %{$reads_to_remove{$rank_tmp0}})
								{
									$reads_to_remove++;
								}
							}
							if ($total_nuc_count - $reads_to_remove < 4 && $full_reset_PB ne "" && $post_pattern_match ne "yes3" && $count_matches_with_high_scores-$count_tmp < 5)
							{
								$remove_reads = "";
								undef %reads_to_remove;
								goto BASECALL2_PB;
							}
                            my %count_nucs;
							undef %count_nucs;
                            foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
                            {
                                my $removed = "";
                                foreach my $rank_tmp0 (keys %reads_to_remove)
                                {
                                    if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
                                    {
                                        $removed_reads_tmp++;
                                        $removed = "yes";
                                        my $id_tmp0 = $rank_to_id{$rank_tmp};
                                        delete $extensions{$extensions2{$id_tmp0}};
                                        delete $extensions2{$id_tmp0};
                                        delete $extensions2b{$id_tmp0};
                                        delete $extensions2_tmp{$id_tmp0};
                                        delete $extensions_nomatch{$extensions2{$id_tmp0}};
                                        delete $extensions_nomatch2{$id_tmp0};
                                        delete $extensions_nomatch2b{$id_tmp0};
                                        delete $extensions_unknown{$extensions2{$id_tmp0}};
                                        delete $extensions_unknown2{$id_tmp0};
                                        delete $save_reads_for_next{$id_tmp0};
                                        delete $add_rej_reads_extra{$id_tmp0};
                                        delete $read_start_pos_rej{$id_tmp0};
										$ext2_count = keys %extensions2_tmp;
                                        if (($rank_tmp <= $add_rejected_reads && $add_rejected_reads ne "") || ($rank_tmp <= $add_no_match_reads && $add_no_match_reads ne ""))
                                        {
                                            $add_rejected_reads_new++;
                                        }
#Exclude reads------------------------                                              
										if ($exclude_reads_check ne "" || ($SNP_check eq "yes2" && keys %count_nucs eq '1'))
										{
											my $id_tmpi = "";
											if (exists($rank_to_id{$rank_tmp}))
											{
												$id_tmpi = $rank_to_id{$rank_tmp};
											}
											if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "")
											{
												$exclude_reads_PB{$id}{$id_tmpi} = $position+$alignment_length_save{$id_tmpi};
											}
										}
#Exclude reads------------------------ 
                                    }									

                                }
                                if ($highest_nuc eq "" && $removed eq "")
                                {
                                    $highest_nuc = $nucs_by_rank{$rank_tmp};
                                }
								if ($removed eq "" && $rank_tmp < 12)
								{
									$count_nucs{$nucs_by_rank{$rank_tmp}} = undef;
								}
                            }
                            if ($removed_reads_tmp > 0 && keys %extensions2_tmp > 1)
                            {
                                my $read_end_tmpi;
								if (length($best_extension) < $overlap)
								{
									$read_end_tmpi = substr $read, -($overlap-length($best_extension)), ($overlap-length($best_extension));
									$read_end_tmpi .= substr $best_extension, 0, length($best_extension);
								}
								else
								{
									$read_end_tmpi = substr $best_extension, -$overlap, $overlap;
								}

                                my $pos_tmp = $position+length($best_extension);
                                
								if (keys %count_nucs eq '1' && $exclude_reads_check ne "yes2" && $SNP_check ne "" && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3"))
                                {
									my $first_rank_tmp = '1';
									foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
									{
										my $remove_check_tmp = "";
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
											{
												$remove_check_tmp = "yes";
											}
										}
										if ($remove_check_tmp eq "")
										{
											$first_rank_tmp = $rank_tmp;
											last;
										}
									}
									
									my $pos_tmp2 = $track_length_ext_total{$first_rank_tmp}+$track_length_ext{$first_rank_tmp};
									$split_positions_DUP_tmp{$pos_tmp2} = $read_end_tmpi;
									$split_positions_DUP_tmp2{$pos_tmp2} = $highest_nuc;
									print {$filehandle{$seed_id2}} $seed_id."\t".$pos_tmp."\t".$first_rank_tmp."\t".$read_end_tmpi.",".$highest_nuc." DUP_POS\n";
								}

                                foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
								{
									if (exists($split_positions_VIP{$id}{$pos_tmp14}))
									{}
									elsif ($pos_tmp14 > $position+length($best_extension)+7000)
									{
										 delete $split_positions_DUP{$id}{$pos_tmp14};
										 delete $split_positions_DUP2{$id}{$pos_tmp14};
									}
								}
								
								if ($post_pattern_match eq "yes2222")
								{
									my %split_patterns;
									undef %split_patterns;
									my %split_patterns_no_indel;
									undef %split_patterns_no_indel;
									foreach my $nuc_tmp7 (keys %split_patterns)
									{
										foreach my $pos_tmp7 (keys %{$split_patterns{$nuc_tmp7}})
										{
											my $indel_check_tmp2 = "";
											foreach my $nuc_tmp8 (keys %{$split_patterns_no_indel{$pos_tmp7}})
											{
												if ($nuc_tmp8 eq "-")
												{
													$indel_check_tmp2 = "yes";
												}
											}
											if ($indel_check_tmp2 eq "")
											{
												my $overlap_tmp = $overlap;
												my $d = $pos_tmp7 - $position - $overlap;
												if ($d < 0)
												{
												   $overlap_tmp -= $d;
												   $d = '0';                         
												}
												my $read_end_tmpi = substr $best_extension, $d, $overlap_tmp;
												$read_end_tmpi =~ tr/-//d;
												$read_end_tmpi =~ tr/actgn/ACTGN/;
												
												#$split_positions_DUP{$seed_id}{$pos_tmp7} = $read_end_tmpi.",unknown";
												print {$filehandle{$seed_id2}} $seed_id."\t".$pos_tmp7."\t".$read_end_tmpi.","." DUP_POS_PREV\n";
											}
											else
											{
												print {$filehandle{$seed_id2}} $seed_id."\t".$pos_tmp7." INDEL\n";
											}
										}
									}
								}
								
                                print {$filehandle{$seed_id2}} $best_extension."\nHALLE2\n";
								
								my $remaining_rej = '0';
REMAIN_REJ_PB:					foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
								{
									if (($add_rejected_reads ne "" && $rank_tmp > $add_rejected_reads) || ($add_no_match_reads ne "" && $rank_tmp > $add_no_match_reads))
									{
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
											{
												next REMAIN_REJ_PB;
											}
										}
										$remaining_rej++;
									}
								}
													
                                $mismatch_retry++;
                                $best_extension = "";
								$best_extension_part = "";
                                undef %quality_scores_tmp;
								$remove_reads_check = "yes";
                                
								if ($add_rejected_reads ne "")
                                {    
									if ($remaining_rej > 0)
									{
										$add_rejected_reads -= $add_rejected_reads_new;
										goto SELECT_LENGTH_PB;
									}
                                    else
									{
										$add_rejected_reads = "";
									}
                                }
								if ($add_no_match_reads ne "")
                                {
									if ($remaining_rej > 0)
									{
										$add_no_match_reads -= $add_rejected_reads_new;
										goto SELECT_LENGTH_PB;
									}
                                    else
									{
										$add_no_match_reads = "";
										$add_no_match_reads_pos = "";
										$add_no_match_reads_stop = "yes";
									}
                                }
                                if ($mismatch_retry > 500000000 && $total_nuc_count_original-$removed_reads_tmp > 7 && $high_quality eq "")
                                {
                                    $high_quality = "yes";
                                    goto SELECT_LENGTH_PB;
                                }

                                goto MISMATCH_RETRY_PB;
                            }
                        }
						
						my $AT_rich_tmp5 = "";
						if (length($best_extension) > 80)
						{
							my $h = '80';
							my $last_80 = substr $best_extension, -$h, 80;
							$AT_rich_tmp5 = AT_rich_test ($last_80, '15');
						}
					print {$filehandle{$seed_id2}} $post_pattern_match." ".$NP_reads_support." ".$add_rejected_reads." NP_CHECK\n";
						if (($clipped_ext eq "yes" || $trace_back_check ne "" || $post_pattern_match eq "yes3") && ($NP_reads_support eq "yes" || $NP_reads_support > length($best_extension)+50)
							&& ($SNP_check eq "yes2" || $post_pattern_match_extra eq "yes" || $post_pattern_match eq "yes3")
							&& ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3") && ($AT_rich_tmp5 eq "" || $post_pattern_match eq "yes3") && ($total_nuc_count > 10 || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") 
							&& (length($best_extension) > $add_rejected_reads_pos-20 || $add_rejected_reads eq ""))               
						{
#Split into haplotype groups----------------------------------------------------------------------                                                           
							my %separate_haps_PB;
							undef %separate_haps_PB;
							
							foreach my $ext_line_tmp (sort {$a <=> $b} keys %split_patterns_final)
							{
								if (($add_rejected_reads eq "" || $ext_line_tmp < $add_rejected_reads) && ($add_no_match_reads eq "" || $ext_line_tmp < $add_no_match_reads))
								{
									my $nuc_tmp = substr $subject_list{$ext_line_tmp}, $cp, 1;
									if (exists($separate_haps_PB{$nuc_tmp}))
									{                  
										$separate_haps_PB{$nuc_tmp} .= ",".$ext_line_tmp;
									}
									else
									{
										$separate_haps_PB{$nuc_tmp} = $ext_line_tmp;
									}
								}
							}
#------------------------------------------------------------------------------------------------
							my $gap_split = "";
GAP_SPLIT:							
							my $f2 = $cp;
							my %hap_seqs;
							undef %hap_seqs;
													
							my $r0 = '0';
							if (length($best_extension) > $r0+1 && $gap_split ne "")
							{
								my $N_check = substr $best_extension, -1, 1;
								my $count_check_tmp = '0';
								while ($N_check eq "N" && length($best_extension) > 1)
								{
									foreach my $nuc_tmp (keys %separate_haps_PB)
									{
										my @list_ranks = split /,/, $separate_haps_PB{$nuc_tmp};
										if (@list_ranks > 0.2*$total_nuc_count && (@list_ranks > 1 || $total_nuc_count < 3))
										{
											my %list_ranks;
											undef %list_ranks;
											foreach my $rank_tmp (@list_ranks)
											{
												$list_ranks{$rank_tmp} = undef;
											}
											my $total_nuc_count2 = '0';
											my %nucs2;
											undef %nucs2;
											foreach my $ext_line_tmp (sort {$a <=> $b} keys %split_patterns_final)
											{                         
												if (exists($list_ranks{$ext_line_tmp}))
												{
													if (length($subject_list{$ext_line_tmp}) > $cp+50)
													{
														my $nuc = substr $subject_list{$ext_line_tmp}, $cp-1, 1;
														$nucs2{$nuc} += 1;
														$total_nuc_count2++;
													}
												}
											}
											foreach my $nucs2_tmp (keys %nucs2)
											{
												if ($nucs2{$nucs2_tmp} > 0.5*$total_nuc_count2)
												{
													$nucs2_tmp =~ tr/actgn/ACTGN/;
													$nucs2_tmp =~ tr/-//d;
													my $seq_tmp = $hap_seqs{$nuc_tmp};
													$hap_seqs{$nuc_tmp} = $nucs2_tmp.$seq_tmp;
													print {$filehandle{$seed_id2}} $nuc_tmp." ".$hap_seqs{$nuc_tmp}." PREV_N_CONV\n";
													$count_check_tmp++;
												}
											}
										}
									}
									if ($count_check_tmp > 1)
									{
										$cp--;
										chop($best_extension);
										$r0++;
									}
									elsif ($count_check_tmp > 0)
									{
										print {$filehandle{$seed_id2}} $best_extension." ERRORRRRRRRRRRRRRRRRRRRRRRRR\n";
										$cp--;
										chop($best_extension);
										$r0++;
									}
								}
							}							
							
NEXT_HAP_NUC_PB:                                                       
							my $count_check_tmp = '0';
							foreach my $nuc_tmp (keys %separate_haps_PB)
							{
								my @list_ranks = split /,/, $separate_haps_PB{$nuc_tmp};
								if (@list_ranks > 0.2*$total_nuc_count && (@list_ranks > 1 || $total_nuc_count < 3))
								{
									print {$filehandle{$seed_id2}} $nuc_tmp." NUCIE0\n";
									print {$filehandle{$seed_id2}} $separate_haps_PB{$nuc_tmp}." READ_IDS0\n";
									my %list_ranks;
									undef %list_ranks;
									foreach my $rank_tmp (@list_ranks)
									{
										$list_ranks{$rank_tmp} = undef;
									}
									my $total_nuc_count2 = '0';
									my %nucs2;
									undef %nucs2;
									foreach my $ext_line_tmp (sort {$a <=> $b} keys %split_patterns_final)
									{                         
										if (exists($list_ranks{$ext_line_tmp}))
										{
											if (length($subject_list{$ext_line_tmp}) > $f2+50)
											{
												my $nuc = substr $subject_list{$ext_line_tmp}, $f2, 1;
												$nucs2{$nuc} += 1;
												$total_nuc_count2++;
											}
										}
									}
									foreach my $nucs2_tmp (keys %nucs2)
									{
										if ($nucs2{$nucs2_tmp} > 0.5*$total_nuc_count2 && $nucs2{$nucs2_tmp} > 1)
										{
											$nucs2_tmp =~ tr/actgn/ACTGN/;
											$nucs2_tmp =~ tr/-//d;
											$hap_seqs{$nuc_tmp} .= $nucs2_tmp;
											$count_check_tmp++;
										}
									}
								}
							}
							$f2++;
							my $haps_seq_prev = "";
							my $haps_seq_prev_check = "";
							
							foreach my $nucs2_tmp (keys %hap_seqs)
							{ 
								if ($haps_seq_prev_check eq "")
								{
									$haps_seq_prev = $hap_seqs{$nucs2_tmp};
									$haps_seq_prev_check = "yes";
								}
								else
								{
									my $haps_seq = $hap_seqs{$nucs2_tmp};
									my $shortest_seq = "";
									my $longest_seq = "";
									if (length($haps_seq) <= length($haps_seq_prev))
									{
										$shortest_seq = $haps_seq;
										$longest_seq = $haps_seq_prev;
									}
									else
									{
										$shortest_seq = $haps_seq_prev;
										$longest_seq = $haps_seq;
									}
									
									print {$filehandle{$seed_id2}} $shortest_seq." SHORT\n";
									print {$filehandle{$seed_id2}} $longest_seq." LONG\n";
									my $long_check = substr $longest_seq, 0, length($shortest_seq);
									
									if (($long_check eq $shortest_seq || $shortest_seq eq "") && length($longest_seq) > 100)
									{
										goto SKIP_GO_TO_NP;
										#goto END1;
									}
									elsif (($long_check eq $shortest_seq || $shortest_seq eq "") && $gap_split eq "yes" && $count_check_tmp > 1)
									{
										goto NEXT_HAP_NUC_PB;
									}
									elsif (($long_check eq $shortest_seq || $shortest_seq eq "") && $gap_split eq "")
									{
										foreach my $posi_tmp (sort {$a <=> $b} keys %find_haps_SNPs)
										{
											my $gap_check = "";
											my $nuc_prev_tmp = "";
											foreach my $nuc_now_tmp (keys %{$find_haps_SNPs{$posi_tmp}})
											{
												$nuc_prev_tmp = $find_haps_SNPs{$posi_tmp}{$nuc_now_tmp};
												if ($find_haps_SNPs{$posi_tmp}{$nuc_now_tmp} eq "-")
												{
													$gap_check = "yes";
												}
											}
											if ($gap_check eq "")
											{
												my $length_tmp = $posi_tmp-$position;
												substr $best_extension, -$length_tmp-1, $length_tmp+1, "";
												foreach my $ranki_tmp (keys %{$SNP_patterns_prev{$posi_tmp}{$nuc_prev_tmp}})
												{
													$cp = $SNP_patterns_prev{$posi_tmp}{$nuc_prev_tmp}{$ranki_tmp};
													$cp--;
													last;
												}
												
												foreach my $qscore_pos (sort {$b <=> $a} keys %quality_scores_tmp)
												{
													if ($qscore_pos > length($best_extension))
													{
														delete $quality_scores_tmp{$qscore_pos};
													}
													else
													{
														last;
													}
												}
												foreach my $pos (sort {$b <=> $a} keys %SNP_patterns_prev)
												{
													my $pos2 = $pos-$position;
													if ($pos2 > length($best_extension))
													{
														delete $SNP_patterns_prev{$pos};
													}
													else
													{
														last;
													}
												}
												foreach my $pos (sort {$b <=> $a} keys %total_count_prev_patterns)
												{
													if ($pos > length($best_extension))
													{
														delete $total_count_prev_patterns{$pos};
													}
													else
													{
														last;
													}
												}
												$switch_ONT_SNP = "yes";
												print {$filehandle{$seed_id2}} $best_extension." GO_BACK_AND_SPLIT\n";
												next INPUT_MAFFT3_PB;
											}
										}
										if ($gap_split eq "")
										{
											$gap_split = "yes";
											goto GAP_SPLIT;
										}
										
#Assemble both splits---------------------------------------------------------------------------------------------------------------
										if ($total_nuc_count > 80000000000 && keys %split_patterns_final_score > 1 && $repetitive_detect2 eq "")
										{
											foreach my $nuc_tmp17 (sort {$a <=> $b} keys %split_patterns_final_score)
											{
												my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp17}};
												if ($count_ranks_tmp > 0.2*$total_nuc_count)
												{
													$split_contigs_PB = "yes";
													foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp17}})
													{
														if (exists($rank_to_id{$rank_tmp13}))
														{
															my $id_tmpi = $rank_to_id{$rank_tmp13};
															if (exists($reverse_list{$id_tmpi}))
															{
																$assemble_split_reads{$id}{$lowest_longest_match}{$nuc_tmp17}{$id_tmpi} = "yes";
															}
															else
															{
																$assemble_split_reads{$id}{$lowest_longest_match}{$nuc_tmp17}{$id_tmpi} = "no";
															}
														}
													}
												}	
											}
										}
										
										#goto SKIP_GO_TO_NP;
										#goto END1;
									}
									$haps_seq_prev = $hap_seqs{$nucs2_tmp};
								}
							}
	
#Switch to Nanopore data------------------------------------------------------------------      
							$NP_reads_support = length($best_extension);
							print {$filehandle{$seed_id2}} $best_extension." SWITCH_TO_NANOPORE\n";
							
							my $last_4 = substr $best_extension, -4, 4;
							if ($last_4 eq "AAAA" || $last_4 eq "CCCC" || $last_4 eq "TTTT" || $last_4 eq "GGGG")
							{
								$NP_reads_support_SNR = substr $best_extension, -1, 1;
							}
							
							$read .= $best_extension;                                                 
							$position += length($best_extension);
							$position{$id} = $position;
							$best_extension = "";
							$seed{$id} = $read;
							undef %PB_split_nucs;
							undef %PB_split_ids;
							$PB_extension = $best_extension;
							undef %quality_scores_tmp;
							
							foreach my $nucie (keys %separate_haps_PB)
							{
								if (exists($hap_seqs{$nucie}))
								{
									my @list_tmp = split /,/, $separate_haps_PB{$nucie};
									my $list_ids_tmp = "";
									foreach my $rank_tmp (@list_tmp)
									{
										if (exists($rank_to_id{$rank_tmp}))
										{
											if ($list_ids_tmp eq "")
											{
												$list_ids_tmp = $rank_to_id{$rank_tmp};
											}
											else
											{
												$list_ids_tmp .= ",".$rank_to_id{$rank_tmp};
											}
											my $rev_tmp = "no";
											if (exists($reverse_list{$rank_to_id{$rank_tmp}}))
											{
												$rev_tmp = "yes";
											}
											$PB_split_ids{$rank_to_id{$rank_tmp}} = $rev_tmp;
										}
									}
									$PB_split_nucs{$nucie}{$hap_seqs{$nucie}} = $list_ids_tmp;
									print {$filehandle{$seed_id2}} $nucie." PB_SPLIT_NUC\n";
								} 
							}
							
							goto NP_READS;
SKIP_GO_TO_NP:
						}
			
ALL_MISMATCHES_PB:						
						if ($remove_reads eq "" && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3") && $find_haps_in_seed eq "")
						{
#Select reads based on all mismatches--------------------------------------------------------------------------------------  
							my %mismatch_pattern;
							undef %mismatch_pattern;
							my %mismatch_pattern_N;
							undef %mismatch_pattern_N;
							my $count_groups_tmp = '0';
							foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								my $total_count_tmp = '0';
								my $total_score_count_tmp = '0';
								my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp13}};
								if ($count_ranks_tmp > 3)
								{
									$count_groups_tmp++;
									foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
									{
										if (exists($rank_to_id{$rank_tmp13}))
										{
											my $id_tmpi = $rank_to_id{$rank_tmp13};
											foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_PB{$id_tmpi}})
											{
												$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi} = undef;
											}
											foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_N_PB{$id_tmpi}})
											{
												my @store_mismatches_N_PB = split /,/, $store_mismatches_N_PB{$id_tmpi}{$pos_snp_tmp};
												$mismatch_pattern_N{$pos_snp_tmp}{$nuc_tmp13}{$store_mismatches_N_PB[1]}{$id_tmpi} = undef;
											}
										}
									}
								}	
							}
							if ($count_groups_tmp > 1)
							{
								my $count_tmp = keys %mismatch_pattern;
								print {$filehandle{$seed_id2}} $count_tmp." CHECK_ALL_MISMATCHES\n";
								my %pos_no_matches;
								undef %pos_no_matches;
								my %rank_pattern;
								undef %rank_pattern;

								foreach my $pos_snp_tmp (sort {$b <=> $a} keys %mismatch_pattern)
								{
									my $one_nuc_match = "";
									my $one_nuc_no_match = "";
									my $total_rank_count = '0';
									foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
									{
										$total_rank_count += keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}}
									}
									foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
									{
										my $this_rank_count_tmp = keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}};
										if ($this_rank_count_tmp < 2 && $this_rank_count_tmp < 0.15*$total_rank_count)
										{
											foreach my $id_tmpi14 (sort {$a <=> $b} keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}})
											{
												delete $mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}{$id_tmpi14};
											}
											delete $mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14};
										}
									}
									if (keys %{$mismatch_pattern{$pos_snp_tmp}} eq '1')
									{
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
										{
											if (keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}} > 3)
											{
												my $rank_pattern_tmp = "";
												foreach my $id_tmpi14 (sort {$a <=> $b} keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}})
												{
													if ($rank_pattern_tmp eq "")
													{
														$rank_pattern_tmp = $id_tmpi14;
													}
													else
													{
														$rank_pattern_tmp .= "_".$id_tmpi14
													}
												}
												$rank_pattern{$rank_pattern_tmp}{$nuc_tmp14}{$pos_snp_tmp} = 3;
											}
										}
									}

									foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
									{
										my $nuc_mismatches_count = '0';
										my $too_short_count = '0';
										my $match_count = '0';
										my $total_count_tmp = '0';
										
										foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
										{
											if (exists($rank_to_id{$rank_tmp13}))
											{
												my $id_tmpi = $rank_to_id{$rank_tmp13};
												if (exists($mismatch_pattern{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi}))
												{
													$nuc_mismatches_count++;
												}
												elsif (exists($alignment_length_save{$id_tmpi}))
												{
													my $overlap_tmp = $alignment_length_save{$id_tmpi};
													if ($position - $pos_snp_tmp > $overlap_tmp)
													{
														$too_short_count++;
													}
													else
													{
														$match_count++;
													}
												}
											}
											$total_count_tmp++;
										}
										if (($match_count < 2 && $nuc_mismatches_count > 3 && $nuc_mismatches_count > $total_count_tmp*0.3 && $nuc_mismatches_count > $match_count*4
											&& $match_count < $total_count_tmp*0.1) || ($match_count eq '0' && $nuc_mismatches_count > 2))
										{
											$one_nuc_no_match = $nuc_tmp13;
										}
										elsif (($nuc_mismatches_count < $total_count_tmp*0.1 && $match_count > 2 && $match_count > 3*$nuc_mismatches_count
											  ) || ($nuc_mismatches_count eq '0' && $match_count > 2))
										{
											$one_nuc_match = $nuc_tmp13;
										}
									}
									
									if ($one_nuc_match ne "" && $one_nuc_no_match ne "")
									{
										$pos_no_matches{$one_nuc_no_match} += 2;
										
										print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_PATTERN_MATCH1\n";
										print {$filehandle{$seed_id2}} $one_nuc_no_match." FINAL_PATTERN_MATCH_NUC1\n";
									}
								}
	
								my $nuc_to_delete = '0';
								my $nuc_to_delete2 = '0';
								my $count_below_5 = '0';
								my $high_pos_count = "";
								my $high_pos_nuc = "";
								my $rank1_check = "";
								foreach my $nuc (keys %pos_no_matches)
								{
									my $pos_count = $pos_no_matches{$nuc};
									$nuc_to_delete++;
									print {$filehandle{$seed_id2}} $nuc." NUC\n";
									print {$filehandle{$seed_id2}} $pos_count." POS_COUNT\n";
									if ($pos_count > 5 || (keys %pos_no_matches < 2 && $pos_count > 4 && $post_pattern_match eq "yes3"))
									{
										$nuc_to_delete2++;
										foreach my $rank_tmp14 (keys %{$split_patterns_final_score{$nuc}})
										{
											$reads_to_remove{$rank_tmp14}{$rank_tmp14} = undef;
											if ($rank_tmp14 < 5)
											{
												$count_below_5++;
											}
											if ($rank_tmp14 eq "1")
											{
												$rank1_check = "yes";
											}
										}
										$high_pos_count = $pos_count;
										$high_pos_nuc = $nuc;
									}
									print {$filehandle{$seed_id2}} $count_below_5." COUNT_BELOW_5\n";
								}
								my $multi_match_check = "";
								foreach my $nuc (keys %pos_no_matches)
								{
									if ($high_pos_nuc ne $nuc)
									{
										my $pos_count = $pos_no_matches{$nuc};
										if ($pos_count > $high_pos_count*0.2)
										{
											$multi_match_check = "no";
										}
									}
								}
								if (($nuc_to_delete eq '1' || ($multi_match_check eq "")) && $nuc_to_delete2 eq '1' && ($count_below_5 < 3 || ($high_pos_count > 20 && $count_below_5 < 4 && $total_nuc_count > 10))
									&& ($rank1_check eq "" || ($count_below_5 < 3 && $nuc_to_delete eq '1' && $high_pos_count > 10)))
								{
									$remove_reads = "yes";
									print {$filehandle{$seed_id2}} $high_pos_nuc." REMOVE_BY_all_MISMATCH\n";
									
									my $one_nuc_match_tmp = "";
									foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
									{
										my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp13}};
										if ($nuc_tmp13 ne $high_pos_nuc && $count_ranks_tmp > $total_nuc_count*0.25)
										{
											if ($one_nuc_match_tmp eq "")
											{
												$one_nuc_match_tmp = $nuc_tmp13
											}
											else
											{
												$one_nuc_match_tmp = "";
												last;
											}
										}
									}
									if ($one_nuc_match_tmp ne "")
									{
										my $last_11 = substr $best_extension, -11, 11;
										$track_split_PB{$id}{$position+length($best_extension)} = $last_11."+".$one_nuc_match_tmp;
										foreach my $posie_tmp (keys %SNP_patterns_prev_match)
										{
											my $last_11_tmp = substr $best_extension, $posie_tmp-$position-11, 11;
											$track_split_PB{$id}{$posie_tmp} = $last_11_tmp."+".$SNP_patterns_prev_match{$posie_tmp};
										}
									}
									
									goto REMOVE_READS_PB;
								}
#Go back to resolve previous SNP position-----------------------------------------------------------------------------------------------------------------
								elsif ($post_pattern_match eq "yes3")
								{
									my $found_pos = "";
									foreach my $pos_snp_tmp (sort {$a <=> $b} keys %mismatch_pattern_N)
									{
										my %N_matches;
										undef %N_matches;
										foreach my $nuc_split14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}})
										{
											my $total_pattern_count_tmp = '0';
											my $split_patterns_count_tmp = keys %{$split_patterns_final_score{$nuc_split14}};
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}})
											{
												$total_pattern_count_tmp += keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}{$nuc_tmp14}};
											}
											
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}})
											{
												my $nuc_count_tmp4 = keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}{$nuc_tmp14}};
												if ($nuc_count_tmp4 > 0.8*$total_pattern_count_tmp && $nuc_count_tmp4 > 3 && ($nuc_count_tmp4 > $split_patterns_count_tmp*0.45 || $nuc_count_tmp4 > 5))
												{
													$N_matches{$nuc_tmp14} = $nuc_count_tmp4;
												}
											}
										}
										if (keys %N_matches > 1)
										{
											print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_N_PATTERN_MATCH\n";
											my $indel_check_tmp = "";
											foreach my $nuc_tmp15 (keys %N_matches)
											{
												if ($nuc_tmp15 eq "-")
												{
													$indel_check_tmp = "yes";
												}
											}
N_MATCHES_PB:								foreach my $nuc_tmp15 (keys %N_matches)
											{
												print {$filehandle{$seed_id2}} $nuc_tmp15." FINAL_N_PATTERN_MATCH_NUC\n";
												print {$filehandle{$seed_id2}} $N_matches{$nuc_tmp15}." FINAL_N_PATTERN_MATCH_COUNT\n";
												
												foreach my $pos_tb_tmp (keys %{$trace_back_split_PB{$id}})
												{
													if ($pos_snp_tmp > $pos_tb_tmp-30 && $pos_snp_tmp < $pos_tb_tmp+30)
													{
														next N_MATCHES_PB;
													}
												}
												if (exists($trace_back_split_PB{$id}{$pos_snp_tmp}))
												{}
												elsif ($indel_check_tmp eq "")
												{
													my $last_11 = substr $read, $pos_snp_tmp-12, 11;
													foreach my $pos_snp_tmp2 (keys %{$trace_back_split_PB{$id}})
													{
														if ($pos_snp_tmp2 > $pos_snp_tmp-500 && $pos_snp_tmp2 < $pos_snp_tmp+500)
														{
															if ($last_11 eq $trace_back_split_PB{$id}{$pos_snp_tmp2})
															{
																next N_MATCHES_PB;
															}
														}
													}
													
													$trace_back_split_PB{$id}{$pos_snp_tmp} = $last_11;
													print {$filehandle{$seed_id2}} $last_11." LAST11\n";

													if ($found_pos eq "")
													{
														$found_pos = $pos_snp_tmp;
													}
												}
											}		
										}
									}
								
									my $found_pos2 = "";
									my $yy = keys %mismatch_pattern;
									print {$filehandle{$seed_id2}} $yy." MISMATCH_PATTER_ALL\n";
MISMATCH_PATTER_ALL_PB: 			foreach my $pos_snp_tmp (sort {$a <=> $b} keys %mismatch_pattern)
									{
										my %all_matches;
										undef %all_matches;
										my %nuc_matches;
										undef %nuc_matches;
										my %nuc_matches2;
										undef %nuc_matches2;
										my $total_pattern_count_tmp = '0';
										my $nucie_tmp = '0';
										my $nucie_tmp2 = '0';
					my $within_range2 = "";					
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
										{
											my $tmp_count = keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}};
											$total_pattern_count_tmp += $tmp_count;
											foreach my $id_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}})
											{
												my $nuc_tmp2 = $mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}{$id_tmp14};
												my @nuc_tmp2 = split /\+/, $nuc_tmp2;
												$nuc_matches{$nuc_tmp2[0]} += 1;
												$nuc_matches2{$nuc_tmp2[1]} += 1;
											}
											
											foreach my $nuc_tmp15 (keys %nuc_matches)
											{
												if ($nuc_matches{$nuc_tmp15} > 0.9*$tmp_count && $tmp_count > 3)
												{
													if ($nuc_matches{$nuc_tmp15} ne "-")
													{
														$nucie_tmp += 1;
													}
												}
											}
											foreach my $nuc_tmp15 (keys %nuc_matches2)
											{
												if ($nuc_matches2{$nuc_tmp15} > 0.9*$tmp_count && $tmp_count > 3)
												{
													if ($nuc_matches2{$nuc_tmp15} ne "-")
													{
														$nucie_tmp2 += 1;
													}
												}
											}
										}									
										
										if ($nucie_tmp < 1 || $nucie_tmp2 < 1)
										{
											next MISMATCH_PATTER_ALL_PB;
										}
										
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
										{
											my $within_range = '0';
											my $total_count_tmp = '0';
										
											foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp14}})
											{
												if (exists($rank_to_id{$rank_tmp13}))
												{
													my $id_tmpi = $rank_to_id{$rank_tmp13};
													
													if (exists($alignment_length_save{$id_tmpi}))
													{
														my $overlap_tmp = $alignment_length_save{$id_tmpi};
														if ($position - $pos_snp_tmp > $overlap_tmp)
														{
														}
														else
														{
															$within_range++;
														}
													}
												}
												$total_count_tmp++;
											}
								if ($within_range > '0')
											{
												$within_range2 = "yes";

											}
											print {$filehandle{$seed_id2}} $nuc_tmp14." ".$within_range." NUCIE_TMPP\n";
											my $split_patterns_count_tmp = keys %{$split_patterns_final_score{$nuc_tmp14}};
											my $nuc_count_tmp4 = keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}};
											print {$filehandle{$seed_id2}} $total_pattern_count_tmp." ".$split_patterns_count_tmp." ".$nuc_count_tmp4." NUCIE_TMPP2\n";
											if ($nuc_count_tmp4 > 0.89*$total_pattern_count_tmp && $nuc_count_tmp4 > 4 && $nuc_count_tmp4 > 0.89*$within_range
												&& ($nuc_count_tmp4 > $split_patterns_count_tmp*0.6 || $nuc_count_tmp4 > 5))
											{
												$all_matches{$nuc_tmp14} = $nuc_count_tmp4;
												print {$filehandle{$seed_id2}} $nuc_tmp14." FINAL_ALL_PATTERN_MATCH_TEST\n";
											}
										}
										if ($within_range2 eq "")
											{
												print {$filehandle{$seed_id2}} $pos_snp_tmp." ".$total_pattern_count_tmp." ".$within_range2." FINAL_ALL_PATTERN_MATCH_TEST\n";
											}
										if (keys %all_matches eq 1)
										{
											print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_ALL_PATTERN_MATCH\n";

ALL_MATCHES_PB:  							foreach my $nuc_tmp15 (keys %all_matches)
											{
												print {$filehandle{$seed_id2}} $nuc_tmp15." FINAL_ALL_PATTERN_MATCH_NUC\n";
												print {$filehandle{$seed_id2}} $all_matches{$nuc_tmp15}." FINAL_ALL_PATTERN_MATCH_COUNT\n";
												
												foreach my $pos_tb_tmp (keys %{$trace_back_split_PB{$id}})
												{
													if ($pos_snp_tmp > $pos_tb_tmp-50 && $pos_snp_tmp < $pos_tb_tmp+50)
													{
														next ALL_MATCHES_PB;
													}
												}
												if (exists($trace_back_split_PB{$id}{$pos_snp_tmp}))
												{}
												else
												{
													my $last_11 = substr $read, $pos_snp_tmp-12, 11;
													$trace_back_split_PB{$id}{$pos_snp_tmp} = $last_11;
													print {$filehandle{$seed_id2}} length($read)." READ\n";
													print {$filehandle{$seed_id2}} $pos_snp_tmp." POS\n";
													print {$filehandle{$seed_id2}} $last_11." LAST10\n";
													
													if ($found_pos2 eq "")
													{
														$found_pos2 = $pos_snp_tmp;
													}
												}
											}		
										}
									}
									if (($found_pos2 < $found_pos || $found_pos eq "") && $found_pos2 ne "")
									{
										$found_pos = $found_pos2;
									}
									if ($found_pos ne "")
									{
										$read = substr $read, 0, $found_pos-500;				
										delete $exclude_reads_PB{$id};
										delete $save_alignment_data_PB{$id};
										delete $rejected_alignment_data_PB{$id};
										$position = length($read);
										$position{$id} = $position;
										$seed{$id} = $read;
										foreach my $pos_split (keys %{$split_positions{$id}})
										{
											if (exists($split_positions_VIP{$id}{$pos_split}))
											{}
											elsif ($pos_split > $position)
											{
												delete $split_positions{$id}{$pos_split};
											}
										}
										foreach my $pos_split (keys %{$split_positions_DUP{$id}})
										{
											if (exists($split_positions_VIP{$id}{$pos_split}))
											{}
											elsif ($pos_split > $position)
											{
												delete $split_positions_DUP{$id}{$pos_split};
												delete $split_positions_DUP2{$id}{$pos_split};
											}
										}
										$best_extension = "";
										
										if ($hap_compare_pos{$id} > $position)
										{
											$hap_compare_pos{$id} = $position;
										}
										
										print {$filehandle{$seed_id2}} $position." HALLE5\n";
										
										if ($NP_reads_support ne "" && $NP_reads_support ne "yes")
										{
											$NP_reads_support = "yes";
											$NP_reads_support_SNR = "";
											print {$filehandle{$seed_id2}} $best_extension." RESET_NP_SUPPORT0\n";
										}
										
										goto PB_READS;
									}

									my %score_by_nuc;
									undef %score_by_nuc;
									foreach my $rank_pattern_tmp13 (sort {$a <=> $b} keys %rank_pattern)
									{
										if (keys %{$rank_pattern{$rank_pattern_tmp13}} eq '1')
										{
											foreach my $nuc_tmp14 (keys %{$rank_pattern{$rank_pattern_tmp13}})
											{
												if (keys %{$rank_pattern{$rank_pattern_tmp13}{$nuc_tmp14}} > 3)
												{
													my $count_tmp = '0';
													my $score_tmp = '0';
													foreach my $pos_snp_tmp (keys %{$rank_pattern{$rank_pattern_tmp13}{$nuc_tmp14}})
													{
														$count_tmp++;
														$score_tmp += $rank_pattern{$rank_pattern_tmp13}{$nuc_tmp14}{$pos_snp_tmp};
													}
													if ($count_tmp > 4 && $score_tmp > 5)
													{
														print {$filehandle{$seed_id2}} $rank_pattern_tmp13." RANK_PATTERN_TEST\n";
														print {$filehandle{$seed_id2}} $nuc_tmp14." NUC ".$count_tmp." COUNT ".$score_tmp." SCORE\n";
														$score_by_nuc{$nuc_tmp14} += $score_tmp;
													}
												}
											}
										}
									}
									my $nuc_to_remove = "";
									if (keys %score_by_nuc eq '1')
									{ 
										foreach my $nuc_tmp41 (keys %score_by_nuc)
										{
											if (($score_by_nuc{$nuc_tmp41} > 18 || ($N > 10 && $N_resolved > length($best_extension)*0.08 && $score_by_nuc{$nuc_tmp41} > 12)) && $split_patterns_final{'1'} ne $nuc_tmp41)
											{
												foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
												{
													if ($split_patterns_final{$rank_tmp8} eq $nuc_tmp41)
													{
														$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
														$remove_reads = "yes";
														$nuc_to_remove = $nuc_tmp41;
														if ($rank_tmp8 eq '1')
														{
															$remove_reads = "";
															undef %reads_to_remove;
															last;
														}
													}
												}
											}
										}
									}
									elsif ($post_pattern_match eq "yes3" && $N > 10 && $N_resolved > length($best_extension)*0.08)
									{
SCORE_BY_NUC_PB:     					foreach my $nuc_tmp41 (keys %score_by_nuc)
										{
											if ($score_by_nuc{$nuc_tmp41} > 15)
											{
												foreach my $nuc_tmp41b (keys %score_by_nuc)
												{
													if ($nuc_tmp41 ne $nuc_tmp41b && $score_by_nuc{$nuc_tmp41} > $score_by_nuc{$nuc_tmp41b}*5 && $nuc_to_remove eq "")
													{
														$nuc_to_remove = $nuc_tmp41;
													}
													elsif ($nuc_tmp41 ne $nuc_tmp41b && $score_by_nuc{$nuc_tmp41} > $score_by_nuc{$nuc_tmp41b}*5)
													{
														$nuc_to_remove = "";
														last SCORE_BY_NUC_PB;
													}
												}
											}
										}
										if ($split_patterns_final{'1'} ne $nuc_to_remove)
										{
											foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
											{
												if ($split_patterns_final{$rank_tmp8} eq $nuc_to_remove)
												{
													$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
													$remove_reads = "yes";
													if ($rank_tmp8 eq '1')
													{
														$remove_reads = "";
														undef %reads_to_remove;
														last;
													}
												}
											}
										}
									}
																			
									if ($remove_reads eq "yes")
									{
										my $reads_to_remove = '0';
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											foreach my $rank_tmp2 (keys %{$reads_to_remove{$rank_tmp0}})
											{
												$reads_to_remove++;
											}
										}
										if ($reads_to_remove < $total_nuc_count*0.65 && ($total_nuc_count - $reads_to_remove >= 4 || $post_pattern_match ne "yes3"))
										{
											print {$filehandle{$seed_id2}} $nuc_to_remove." NUC ".$score_by_nuc{$nuc_to_remove}." REMOVE_BY_RANK_PATTERN\n";
											foreach my $rank_tmp0 (keys %reads_to_remove)
											{
												foreach my $rank_tmp2 (keys %{$reads_to_remove{$rank_tmp0}})
												{
													my $id_tmp0 = $rank_to_id{$rank_tmp2};
													delete $read_start_pos_rej{$id_tmp0};
												}
											}
											goto REMOVE_READS_PB;
										}
										else
										{
											$remove_reads = "";
											undef %reads_to_remove;
										}
									}
								}
							}
						}
						if ($remove_reads eq "" && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") && $SNR_read_ahead eq "" && $find_haps_in_seed eq "")
						{
							if (length($best_extension) > 1000 && keys %subject_list < $total_nuc_count_original*0.8)
							{
								goto AFTER_NEXT_MAFFT_PB;
							}
						}
                    }
					elsif (($total_nuc_count < 5 || ($total_nuc_count > $sequencing_depth_PB/5 && $sequencing_depth_PB ne "")) && $SNR_read_ahead eq "" && length($best_extension) > 500 && $longer_extension_for_repeat eq "")
					{
						substr $best_extension, -150, 150, "";
						print {$filehandle{$seed_id2}} $best_extension." TERMINATE_EARLY\n";
						goto AFTER_NEXT_MAFFT_PB;
					}
					if ($post_pattern_match eq "yes3" && $full_reset_PB eq "" && $find_haps_in_seed eq "" && $SNR_read_ahead eq "")
                    {
                        delete $exclude_reads_PB{$id};
						#delete $save_alignment_data_PB{$id};
						delete $rejected_alignment_data_PB{$id};
						$full_reset_PB = $best_extension;
						print {$filehandle{$seed_id2}} $best_extension." FULL_RESET\n";
						$best_extension = "";
						$seed_id = $id;
						$y++;
						$y{$id} = $y;
						goto FULL_RESET;
                    }
					elsif ($post_pattern_match eq "yes3" && ($N_resolved > length($best_extension)*0.01 || $N_resolved > 5) && $trace_back_check eq "" && $post_pattern_match_count > 2 && $find_haps_in_seed eq "")
                    {					
						print {$filehandle{$seed_id2}} $best_extension." LAST_EXTENSION\n";
						$unresolvable_PB = "yes";
#Split into contigs---------------------------------------------------------------------------------------------------------------
						if ($total_nuc_count > 8 && keys %split_patterns_final_score > 1)
						{
							my $new_contig_seed = substr $read, -$lowest_longest_match, $lowest_longest_match;
							
							foreach my $nuc_tmp17 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp17}};
								if ($count_ranks_tmp > 0.16*$total_nuc_count)
								{
									$split_contigs_PB = "yes";
									print {$filehandle{$seed_id2}} $lowest_longest_match." NEW_CONTIG_LENGTH\n";
									print $id." ID0\n";
									print $nuc_tmp17." NEW_NUC_SPLIT0\n";
									$contig_number++;
									$split_contigs_num{$contig_number} = undef;
									foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp17}})
									{
										if (exists($rank_to_id{$rank_tmp13}))
										{
											my $id_tmpi = $rank_to_id{$rank_tmp13};
											print {$filehandle{$seed_id2}} $id_tmpi." NEW_CONTIG_ID\n";
											
											if (exists($reverse_list{$id_tmpi}))
											{
												$split_contigs_reads{$contig_number}{$id}{$new_contig_seed}{$nuc_tmp17}{$id_tmpi} = "yes";
											}
											else
											{
												$split_contigs_reads{$contig_number}{$id}{$new_contig_seed}{$nuc_tmp17}{$id_tmpi} = "no";
											}
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$split_positions{$id}})
									{
										if ($pos_tmp5 > $position-$lowest_longest_match)
										{
											my $pos_tmp5_new = $pos_tmp5+$lowest_longest_match-$position;
											$split_positions{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions{$id}{$pos_tmp5};
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$split_positions_DUP{$id}})
									{
										if ($pos_tmp5 > $position-$lowest_longest_match)
										{
											my $pos_tmp5_new = $pos_tmp5+$lowest_longest_match-$position;
											$split_positions_DUP{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions_DUP{$id}{$pos_tmp5};
											$split_positions_DUP2{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions_DUP2{$id}{$pos_tmp5};
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$split_positions_VIP{$id}})
									{
										if ($pos_tmp5 > $position-$lowest_longest_match)
										{
											my $pos_tmp5_new = $pos_tmp5+$lowest_longest_match-$position;
											$split_positions_VIP{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions_VIP{$id}{$pos_tmp5};
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$trace_back_split_PB{$id}})
									{
										if ($pos_tmp5 > $position-$lowest_longest_match)
										{
											my $pos_tmp5_new = $pos_tmp5+$lowest_longest_match-$position;
											$trace_back_split_PB{$id."c".$contig_number}{$pos_tmp5_new} = $trace_back_split_PB{$id}{$pos_tmp5};
										}
									}
								}	
							}
						}
#----------------------------------------------------------------------------------------------------------------------------------
						last INPUT_MAFFT3_PB;
                    }
BASECALL2_PB:
                    
					if ($found_haps_in_seed eq "" && ($clipped_ext ne "yes" || $best_extension eq "" || length($best_extension_part) < $length_extension_part*0.8  ||
                           ($SNR_read_ahead ne "" && $N < 4) || $N < 5 || $N < length($best_extension)*0.1 || ($longer_extension_for_repeat ne "" && $N < length($best_extension)*0.15) || $total_nuc_count < 6))
                    {
                        my $last3 = substr $best_extension, -3, 3;
						my $last5 = substr $best_extension, -5, 5;
						my $count_tmp8 = '0';
						foreach my $nucs_tmp (keys %nucs)
						{
							if ($nucs{$nucs_tmp} > 0.2*$total_nuc_count && $nucs{$nucs_tmp} > 2)
							{
								$count_tmp8++;
							}
						}
						if ($count_tmp8 > 1)
						{
							$N_resolved++;
						}

						if ($nucs{"a"} > $total_nuc_count*0.84 || ($nucs{"a"} > $total_nuc_count*0.7 && $nucs{"-"} > $total_nuc_count*0.19 && $SNR_read_ahead eq "yes"))
                        {
                            $best_extension .= "A";
							$best_extension_part .= "A";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"a"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "A";
                        }
                        elsif ($nucs{"c"} > $total_nuc_count*0.84 || ($nucs{"c"} > $total_nuc_count*0.7 && $nucs{"-"} > $total_nuc_count*0.19 && $SNR_read_ahead eq "yes"))
                        {
                            $best_extension .= "C";
							$best_extension_part .= "C";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"c"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "C";
                        }
						elsif ($nucs{"t"} > $total_nuc_count*0.84 || ($nucs{"t"} > $total_nuc_count*0.7 && $nucs{"-"} > $total_nuc_count*0.19 && $SNR_read_ahead eq "yes"))
                        {
                            $best_extension .= "T";
							$best_extension_part .= "T";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"t"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "T";
                        }
                        elsif ($nucs{"g"} > $total_nuc_count*0.84 || ($nucs{"g"} > $total_nuc_count*0.7 && $nucs{"-"} > $total_nuc_count*0.19 && $SNR_read_ahead eq "yes"))
                        {
                            $best_extension .= "G";
							$best_extension_part .= "G";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"g"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "G";
                        }
                        elsif (($nucs{"-"} > $total_nuc_count*0.83) || ($nucs{"-"} > $total_nuc_count*0.7 && $nucs{"c"} < $total_nuc_count*0.15 && $nucs{"g"} < $total_nuc_count*0.15 &&
                                $nucs{"t"} < $total_nuc_count*0.15 && $nucs{"a"} < $total_nuc_count*0.15))
                        {
							if ($nucs{"-"}/$total_nuc_count < 0.84)
							{
								#$quality_scores_gap_tmp{length($best_extension)} = $nucs{"-"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
							}
                            $nuc_match = "";
                        }
                        else
                        {
                            $N++;
                            $best_extension .= "N";
							$best_extension_part .= "N";
                            $quality_scores_tmp{length($best_extension)} = '0'." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "N";
                        }
					}
                    else
                    {
                        print {$filehandle{$seed_id2}} $nuc_match." TERMINATE EARLY2\n";
						goto AFTER_NEXT_MAFFT_PB;
                    }
                                    
SKIP_INPUT_BLAST3_PB:                   
                    if ($hap_position eq "" && $find_haps_in_seed ne "")
                    {
                        $extensions_seed{"HAP1"} .= $nuc_match;
                        $extensions_seed{"HAP2"} .= $nuc_match;
                    }
                    $hap_position = "";

                    #if (($N > length($best_extension)*0.08 || ($N > length($best_extension)*0.045 && length($best_extension) > 1000)) && $N > 5 && $confirmed_reads_count_NP > 4 && $skip_confirmed eq "" && $only_confirmed eq "yes")
                   # {
                        #print {$filehandle{$seed_id2}} $best_extension." EXT_remove\n";
                        #$best_extension = "";
                        #$skip_confirmed = "yes";
                       # undef %quality_scores_tmp;
                        
                        #goto SKIP_CONFIRMED_NP;
                    #}
                    foreach my $subject_rank (keys %subject_list)
                    {
                        if (exists($length_ext{$subject_rank}))
                        {
                            if ($length_ext{$subject_rank} < $track_length_ext_total{$subject_rank}+$track_length_ext{$subject_rank}+50)
                            {
                                delete $subject_list{$subject_rank}
                            }
                            if ($length_ext{$subject_rank} < length($best_extension))
                            {
                                delete $subject_list{$subject_rank}
                            }
							
							if ($track_length_ext{$subject_rank} > $length_extension_part)
                            {
                                $end_this_mafft_part = "yes";
                            }
                        }
                    }
                    $nuc_prev = $nuc_match;
                    $cp++;
					my $time_CONS_LOOP_END = time - $time_CONS_LOOP_START;
					if ($time_CONS_LOOP_END > 1)
					{
						print {$filehandle{$seed_id2}} $time_CONS_LOOP_END." TIME_CONS_LOOP_END\n\n";
					}
                }
#Go to the next mafft consensus------------------------------------------------------------------------------------------------------

				my $time_CONS3 = time;
                my $time10 = $time_CONS3 - $time_BLAST3;
                print {$filehandle{$seed_id2}} $time10." TIME_CONS\n\n";
				
				if (length($best_extension) < $length_extension-$extension_part_length && length($best_extension) > 0 && $unresolvable_PB eq "" && $loop_check eq "yes")
				{
					if ($mafft_count < 3)
					{
						foreach my $rank_tmp3 (keys %track_length_ext)
						{
							$track_length_ext_total{$rank_tmp3} = $track_length_ext{$rank_tmp3};
						}
					}
					else
					{
						foreach my $rank_tmp3 (keys %track_length_ext_total)
						{
							$track_length_ext_total{$rank_tmp3} += $track_length_ext{$rank_tmp3};
						}
					}
					print {$filehandle{$seed_id2}} length($best_extension)." NEXT_MAFFT\n";   
					goto MAFFT_PB;
				}
				else
				{
					print {$filehandle{$seed_id2}} length($best_extension)." ".$loop_check." NO_NEXT_MAFFT\n";   
				}
				$halle5 = "";
AFTER_NEXT_MAFFT_PB:				
				             
#-------------------------------------------------------------------------------------------------------------------------

                if ($found_haps_in_seed ne "yes" && ($clipped_ext eq "yes" || ($find_haps_in_seed eq "yes" && $best_extension ne "")))
                {
					if ($unresolvable_PB ne "" && length($full_reset_PB) > length($best_extension)+1 && $split_contigs_PB eq "")
					{
						$best_extension = $full_reset_PB;
					}
					
					my $last_70b = substr $best_extension, -70, 70;
					my $N_test = $last_70b =~ tr/N/N/;
					while ($N_test > 5 && length($best_extension) > 500)
					{
						substr $best_extension, -100,100, "";  
						$last_70b = substr $best_extension, -70, 70;
						$N_test = $last_70b =~ tr/N/N/;
					}
                    print {$filehandle{$seed_id2}} $best_extension." EXT0\n";
                }
                elsif ($found_haps_in_seed eq "yes")
                {
                    print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_FOUND_HAPS\n"; 
                    $best_extension = "";
                    delete $seed{$id};
                    $compare_haps = "yes2";
                    foreach my $id_tmp (keys %extensions_seed)
                    {
                        $seed{$id."_".$id_tmp} = $extensions_seed{$id_tmp};
						if ($find_haps_in_seed eq "yes2")
                        {
                            $seed{$id."_".$id_tmp} = $read.$extensions_seed{$id_tmp};
                        }
						$original_seed_length{$id."_".$id_tmp} = length($seed{$id."_".$id_tmp});
                        print {$filehandle{$seed_id2}} $extensions_seed{$id_tmp}." EXT_SEED\n"; 
                        
                        $hap_compare_pos{$id."_".$id_tmp} = 0;
                        delete $find_haps_in_seed{$id};
                        $position{$id."_".$id_tmp} = length($seed{$id."_".$id_tmp});

						my $fh;
						$filehandle{$id."_".$id_tmp} = $fh;
						$output_file5  = $output_path."log_extended_".$project."_".$id."_".$id_tmp.".txt";
						open($filehandle{$id."_".$id_tmp}, ">".$output_file5) or die "Can't open file $output_file5, $!\n";
						
						my $fh4;
						$filehandle4{$id."_".$id_tmp} = $fh4;
						$output_file13 = $output_path."quality_scores_".$project."_".$id."_".$id_tmp.".txt";
						open($filehandle4{$id."_".$id_tmp}, ">".$output_file13) or die "Can't open file $output_file13, $!\n";
                    }
                }
                else
                {
                    print {$filehandle{$seed_id2}} "NOCLIP\n";
                    print {$filehandle{$seed_id2}} $best_extension." EXT\n";
                    $best_extension = "";
                    delete $seed{$id};
                }            
 #-------------------------------------------------------------------------------------------------------------------------
 
 
                my $cut_repeat_seq = "";
                
                if (length($best_extension) > 100 && ($clipped_ext eq "yes" || $found_haps_in_seed ne "yes") && $unresolvable_PB eq "")
                {
                    my $best_extension_original = length($best_extension);
CUT_AGAIN_PB:       my $h = '70';
                    my $last_70 = substr $best_extension, -$h, 70;
                    my $AT_rich_tmp = AT_rich_test ($last_70, '10');
                    
                    while (length($best_extension) > $h+70 && $AT_rich_tmp eq "yes")
                    {
                        $h += 70;
                        $last_70 = substr $best_extension, -$h, 70;
                        $AT_rich_tmp = AT_rich_test ($last_70, '10');
                    }
                    if ($h > 70 || $AT_rich_tmp eq "yes")
                    {      
                        if (length($best_extension) > $h+100)
                        {
                            $h -= 50;
							substr $best_extension, -$h, $h, "";
                            $cut_repeat_seq{$seed_id} = undef;
                            $cut_repeat_seq = "yes";
                            print {$filehandle{$seed_id2}} $best_extension." CUT_REPEAT_SEQ0\n";
                            if (length($best_extension) > 100)
                            {
                                goto CUT_AGAIN_PB;
                            }   
                        }
                        elsif ($longer_extension_for_repeat eq "" && $best_extension_original < 3000)
                        {
                            $longer_extension_for_repeat = $best_extension_original+800;
                            $length_extension = 3000;
                            print {$filehandle{$seed_id2}} $longer_extension_for_repeat." LONGER_EXTENSIONS0\n";
                            $best_extension = "";
                            #$high_quality = "yes";
                            undef %quality_scores_tmp;
                            goto SELECT_LENGTH_PB;
                        }
                    }
                    my $h3 = '0';
                    my $h3_limit = '30';
                    my $check_rep15_full = "";
CUT_AGAIN_PB2:                   
                    my $h2 = '15';
                    my $last_15 = substr $best_extension, -$h2-$h3, 15;
                    my $last_250 = substr $best_extension, -250, 250;
                    my $check_rep15 = $last_250 =~ s/$last_15/$last_15/g;
                    my $N_check = $last_15 =~ tr/N/N/;
                    my $best_extension_tmp = $best_extension;
                    #my $check_rep15_full = $best_extension_tmp =~ s/$last_15/\+/g;
                 
                    my @check_rep15_full = split /$last_15/, $best_extension_tmp;
                    my %lengths_tmp;
                    undef %lengths_tmp;
                    
                    if (@check_rep15_full > 2)
                    {
                        foreach my $seq_tmp (@check_rep15_full)
                        {
                            if (exists($lengths_tmp{length($seq_tmp)}))
                            {
                                my $count_tmp = $lengths_tmp{length($seq_tmp)}+1;
                                $lengths_tmp{length($seq_tmp)} = $count_tmp;
                            }
                            else
                            {
                                 $lengths_tmp{length($seq_tmp)} = '1';
                            }                    
                        }
                        my $score_tmp = '0';
                        my $prev_length = "";
                        
                        foreach my $length_tmp (sort {$a <=> $a} keys %lengths_tmp)
                        {
                            if ($prev_length eq "" || $prev_length < $length_tmp-150 || $prev_length < $length_tmp*0.92)
                            {
                                $score_tmp = $lengths_tmp{$length_tmp};
                            }
                            else
                            {
                                $score_tmp += $lengths_tmp{$length_tmp};
                            }
                            
                            if ($score_tmp > 1)
                            {
                                $check_rep15_full = "yes";
                                if (length($check_rep15_full[0]) > $length_tmp)
                                {
                                    $check_rep15_full = "yes2";
                                }
                                print {$filehandle{$seed_id2}} $score_tmp." LONG_REP_TEST\n";
                            }
                        }
                    }
                    
                    while ($check_rep15 > 1 && length($best_extension) > $h2+$h3+50)
                    {
                        $h2 +=230;
                        $last_15 = substr $best_extension, -$h2-$h3, 15;
                        $last_250 = substr $best_extension, -250-$h2+15, 250;
                        $check_rep15 = $last_250 =~ s/$last_15/$last_15/g;
                    }
                    
                    if ($h2 > 15 || $check_rep15_full eq "yes")
                    {
                        $h2 -= 15;
                        
                        if ($longer_extension_for_repeat <= $length_extension && $longer_extension_for_repeat < length($best_extension)+1000)
                        {
                            if ($longer_extension_for_repeat eq "")
							{
								$longer_extension_for_repeat = $length_extension+1200
							}
							else
							{
								$longer_extension_for_repeat += 1000;
							}
							
                            print {$filehandle{$seed_id2}} $longer_extension_for_repeat." LONGER_EXTENSIONS1a\n";
                            $best_extension = "";
                            #$high_quality = "yes";
                            undef %quality_scores_tmp;
                            goto SELECT_LENGTH_PB;
                        }
                        elsif (length($best_extension) > $h2+$h3+250 && $h2 > 15)
                        {
                            substr $best_extension, -$h2-$h3-100, $h2+$h3+100, "";
                            $cut_repeat_seq{$seed_id} = undef;
                            $cut_repeat_seq = "yes";
                            print {$filehandle{$seed_id2}} $best_extension." CUT_REPEAT_SEQ1\n";
                            if (length($best_extension) > 150)
                            {
                                goto CUT_AGAIN_PB;
                            }                  
                        }
                        elsif ($check_rep15_full eq "yes2")
                        {
                            my $tmpie = length($check_rep15_full[0])-250;
                            if ($tmpie < 100)
                            {
                                $tmpie = '100';
                            }
                            substr $best_extension, $tmpie, length($best_extension)-$tmpie, "";
                            $cut_repeat_seq{$seed_id} = undef;
                            $cut_repeat_seq = "yes";
                            print {$filehandle{$seed_id2}} $best_extension." CUT_REPEAT_SEQ2\n";                 
                        }
                        elsif ($longer_extension_for_repeat eq "" && $best_extension_original < 3000)
                        {
                            $longer_extension_for_repeat = $best_extension_original+2000;
                            print {$filehandle{$seed_id2}} $length_extension." LONGER_EXTENSIONS1\n";
                            $best_extension = "";
                            #$high_quality = "yes";
                            undef %quality_scores_tmp;
                            goto SELECT_LENGTH_PB;
                        }
                    }
                    elsif ($N_check > 0)
                    {
                        $h3 += 5;
                        $h3_limit += 5;
                        goto CUT_AGAIN_PB2;
                    }
                    elsif ($h3 < $h3_limit)
                    {
                        $h3 += 5;
                        goto CUT_AGAIN_PB2;
                    }
                }
                if ($first_split_pos > 500 && $post_pattern_match eq "yes3" && $unresolvable_PB eq "")
                {            
                    my $ext_new_tmp = substr $best_extension, 0, $first_split_pos-100;
                    my $h = '70';
                    my $last_70 = substr $ext_new_tmp, -$h, 70;
                    my $AT_rich_tmp = AT_rich_test ($last_70, '10');
                    
                    if ($AT_rich_tmp eq "yes")
                    {
                        $best_extension = $ext_new_tmp;
                        print {$filehandle{$seed_id2}} $best_extension." EXT0a\n";
                    }
                }
END_PB:              
              
                my $time_CONSENSUS = time;
                my $time11 = $time_CONSENSUS - $time_BLAST3b;
                print {$filehandle{$seed_id2}} $time11." TIME_CONSENSUS\n";
				
				if ($NP_reads_support ne "" && $NP_reads_support ne "yes" && $best_extension ne "" && $clipped_ext eq "yes")
                {
                    $NP_reads_support = "yes";
					$NP_reads_support_SNR = "";
                    print {$filehandle{$seed_id2}} $best_extension." RESET_NP_SUPPORT\n";
                }
                
                if ($cut_repeat_seq eq "")
                {
                    delete $cut_repeat_seq{$seed_id};
                }
                
                if ($clipped_ext eq "yes" && $best_extension ne "")
                {
                    foreach my $pos_tmp (sort {$a <=> $b} keys %quality_scores_tmp)
                    {
                        if ($pos_tmp <= length($best_extension))
                        {
                            $quality_scores{$id}{$position+$pos_tmp} = $quality_scores_tmp{$pos_tmp};
                        }   
                    }
                }     
                close INPUT_BLAST3;

#Store alignment data for the next iteration---------------------------------------------------------------------------------------------------

                if ($find_haps_in_seed eq "" && $unresolvable_PB eq "")
                {
                    foreach my $seed_id_tmp5 (keys %save_alignment_data_PB)
                    {
                        if ($seed_id_tmp5 eq $seed_id)
                        {
                            foreach my $id_tmp4 (keys %{$save_alignment_data_PB{$seed_id_tmp5}})
                            {
                                my @alignment_data = split /_/, $save_alignment_data_PB{$seed_id_tmp5}{$id_tmp4};
                                if ($alignment_data[0] eq "yes" || (($alignment_data[3]+$alignment_data[10]) < $position))
                                {
                                    delete $save_alignment_data_PB{$seed_id_tmp5}{$id_tmp4};
                                }
                                elsif ($alignment_data[0] eq "no" && (($alignment_data[3]+9000 < $position) || (($alignment_data[4]+$alignment_data[3]+5000) < $position)))
                                {
                                    delete $save_alignment_data_PB{$seed_id_tmp5}{$id_tmp4};
                                }
                            }
                        }
                    }
					delete $rejected_alignment_data_PB{$id};
                    foreach my $id_tmp5 (keys %long_read_end_pos_save)
                    {
                        my $assembled = "no";
                        my $reverse_tmp = "no";
                        my $alignment_length_tmp = '0';
                        my $score_matches_tmp = "___";
                        if (exists($save_reads_for_next{$id_tmp5}))
                        {
                            $assembled = "yes";
                        }
                        if (exists($reverse_list{$id_tmp5}))
                        {
                            $reverse_tmp = "yes";
                        }
                        if (exists($double_matches{$id_tmp5}))
                        {
                            delete $save_alignment_data_PB{$seed_id}{$id_tmp5};
							delete $rejected_alignment_data_PB{$seed_id}{$id_tmp5};
							delete $rejected_reads_save{$id_tmp5};
							next;
                        }
                        if (exists($alignment_length_save{$id_tmp5}))
                        {
                            $alignment_length_tmp += $alignment_length_save{$id_tmp5};
                        }
                        if (exists($score_matches_save{$id_tmp5}))
                        {
                            $score_matches_tmp = $score_matches_save{$id_tmp5};
                        }
                        $save_alignment_data_PB{$seed_id}{$id_tmp5} = $assembled."_".$reverse_tmp."_".$long_read_end_pos_save{$id_tmp5}."_".$position."_".$alignment_length_tmp
                        ."_".$score_matches_tmp."_".$accuracy{$id_tmp5}."_".$length_ext_all{$id_tmp5}."_".$read_start_pos_rej{$id_tmp5}."_".$hash_PB_reads_tmp{$id_tmp5};
    
                        #print {$filehandle{$seed_id2}} $id_tmp5." ".$save_alignment_data_PB{$seed_id}{$id_tmp5}." SAVVEEEE\n";
                    }
					foreach my $id_tmp5 (keys %rejected_reads_save)
					{
						$rejected_alignment_data_PB{$seed_id}{$id_tmp5} = undef;
					}
                }
#Post error correction -------------------------------------------------------------------------------------------------------------------------------------------------------------------------				
				if ($split_contigs_PB eq "yes")
				{	
					my $count_tmp = '0';
					
					foreach my $contig_number_tmp (sort {$a <=> $b} keys %split_contigs_num)
					{
						my $new_contig_seed = "";
						my $new_contig_seed_original = "";
						my $new_nuc_original = "";
						my $pos_assem_tmp = $position-1;
						my $pos_assem_tmp2 = "";
						my $pos_assem_tmp3 = "";
						my $change_check = "";
						my %N_mismatches_tmp;
						undef %N_mismatches_tmp;
	
						my %extensions2_tmp_split;
						undef %extensions2_tmp_split;
						print {$filehandle{$seed_id2}} $contig_number_tmp." CONTIG_NUM\n";
						
						foreach my $id_tmp0 (keys %{$split_contigs_reads{$contig_number_tmp}})
						{
							foreach my $new_contig_seed_tmp (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp0}})
							{
								$new_contig_seed = $new_contig_seed_tmp;
								$new_contig_seed_original = $new_contig_seed_tmp;
								$pos_assem_tmp2 = length($new_contig_seed)-1;
								$pos_assem_tmp3 = $position-length($new_contig_seed);
								print {$filehandle{$seed_id2}} length($new_contig_seed)." LENGTH_CONTIG_SEED\n";
								foreach my $new_nuc_tmp (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp0}{$new_contig_seed_tmp}})
								{
									$new_nuc_original = $new_nuc_tmp;
									foreach my $id_tmp2 (sort {$a <=> $b} keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp0}{$new_contig_seed_tmp}{$new_nuc_tmp}})
									{
										$extensions2_tmp_split{$id_tmp2} = $split_contigs_reads{$contig_number_tmp}{$id_tmp0}{$new_contig_seed_tmp}{$new_nuc_tmp}{$id_tmp2};
										
										print {$filehandle{$seed_id2}} $id_tmp2." ID_TMP2\n";
										foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_N_PB{$id_tmp2}})
										{
											my @store_mismatches_N_PB = split /,/, $store_mismatches_N_PB{$id_tmp2}{$pos_snp_tmp};
											$N_mismatches_tmp{$pos_snp_tmp}{$store_mismatches_N_PB[1]} += 1;
										} 
									}
								}
							}
						}

POST_ERROR_CORR_PB: 	while ($pos_assem_tmp > $position-$pos_assem_tmp2)
						{
							my $count_cov = '0';
							my $mismatch_count_tmp = '0';
							my $match_count_tmp = '0';
							my $N_count_tmp = '0';
							my %id_list_tmp;
							undef %id_list_tmp;
							my $corrected_check = "";
							
							foreach my $id_tmp15 (keys %extensions2_tmp_split)
							{
								my $overlap_pos_tmp = $position - $alignment_length_save{$id_tmp15};
								if ($pos_assem_tmp > $overlap_pos_tmp)
								{
									$count_cov++;
									if (exists($store_mismatches_PB{$id_tmp15}{$pos_assem_tmp}))
									{
										$mismatch_count_tmp++;
									}
									elsif (exists($store_mismatches_N_PB{$id_tmp15}{$pos_assem_tmp}))
									{
										$N_count_tmp++;
									}
									else
									{
										$match_count_tmp++;
									}
									$id_list_tmp{$id_tmp15} = undef;
								}
							}
							my $total_count_tmp = $mismatch_count_tmp+$N_count_tmp+$match_count_tmp;
							if ($total_count_tmp > 1)
							{
								if ($mismatch_count_tmp > 1 && $mismatch_count_tmp > 0.9*$total_count_tmp)
								{
									my %all_mismatches_tmp;
									undef %all_mismatches_tmp;
									foreach my $id_tmp15 (keys %id_list_tmp)
									{
										if (exists($store_mismatches_PB{$id_tmp15}{$pos_assem_tmp}))
										{
											my @store_mismatches_PB = split /,/, $store_mismatches_PB{$id_tmp15}{$pos_assem_tmp};
											$all_mismatches_tmp{$store_mismatches_PB[1]} += 1;
											#print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$store_mismatches_all_NP{$id_tmp15}{$pos_assem_tmp}." ALL_CORRECTED_TEST0\n";
										}
									}
	
									foreach my $nuc_tmp15 (keys %all_mismatches_tmp)
									{
										print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." ".$all_mismatches_tmp{$nuc_tmp15}." ALL_CORRECTED_TEST0\n";
										if ($all_mismatches_tmp{$nuc_tmp15} > 1 && $all_mismatches_tmp{$nuc_tmp15} > 0.89*$total_count_tmp)
										{#ADDED $nuc_tmp15 ne "-" && 
											print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." ALL_CORRECTED\n";
											$corrected_check = "yes";
											print {$filehandle{$seed_id2}} $all_mismatches_tmp{$nuc_tmp15}/$total_count_tmp." Nucie_Per\n";
											
											my $posie_tmp = $pos_assem_tmp-$pos_assem_tmp3-1;
											if ($nuc_tmp15 eq "-")
											{
												$nuc_tmp15 = "";
												$pos_assem_tmp3--;
												$posie_tmp--;
											}
											substr $new_contig_seed, $posie_tmp, 1, $nuc_tmp15;
											$change_check = "yes";
										}
									}
									print {$filehandle{$seed_id2}} $total_count_tmp." ".$pos_assem_tmp." MISMATCH_CHECK\n";
								}
								elsif ($N_count_tmp > 1)
								{
									foreach my $nuc_tmp15 (keys %{$N_mismatches_tmp{$pos_assem_tmp}})
									{
										print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." ".$N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}." ".$total_count_tmp." N_CHECK\n";
										if ($N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > 1 && $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > 0.89*$total_count_tmp)
										{#ADDED $nuc_tmp15 ne "-" &&
											my $posie_tmp = $pos_assem_tmp-$pos_assem_tmp3-1;
											print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." N_CORRECTED\n";
											
											if ($nuc_tmp15 eq "-")
											{
												$posie_tmp--;
											}
											my $nuci_test = substr $new_contig_seed, $posie_tmp, 1;
											
											my $nuci_test2 = substr $new_contig_seed, $posie_tmp-10, 20;
											print {$filehandle{$seed_id2}} $nuci_test2." Nucie_test\n";
											
											$corrected_check = "yes";								
											
											if ($nuci_test eq "N")
											{												
												print {$filehandle{$seed_id2}} $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}/$total_count_tmp." Nucie_Per\n";
												if ($nuc_tmp15 eq "-")
												{
													$nuc_tmp15 = "";
													$pos_assem_tmp3--;
												}
												substr $new_contig_seed, $posie_tmp, 1, $nuc_tmp15;
												$change_check = "yes";
											}
											else
											{
												print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." N_CORRECTED_ERROR\n";
											}
										}	
									}								
								}
							}
							else
							{
								last POST_ERROR_CORR_PB;
							}
							$pos_assem_tmp--;
						}
						if ($change_check eq "yes")
						{
							foreach my $id_tmp15 (keys %extensions2_tmp_split)
							{
								$split_contigs_reads{$contig_number_tmp}{$id}{$new_contig_seed}{$new_nuc_original}{$id_tmp15} = $extensions2_tmp_split{$id_tmp15};
							}
							delete $split_contigs_reads{$contig_number_tmp}{$id}{$new_contig_seed_original}{$new_nuc_original};
							$count_tmp++;
						}
						if ($count_tmp > 1)
						{
							delete $split_contigs_reads{$contig_number_tmp}{$id}{$new_contig_seed_original};
							delete $split_contigs_reads{$contig_number_tmp-1}{$id}{$new_contig_seed_original};
						}
						
						my $output_file31  = $output_path."Sequence_new_contig_".$id.".fasta";			
						open(OUTPUT31, ">".$output_file31) or die "Can't open file $output_file31, $!\n";
						OUTPUT31->autoflush(1);
						print OUTPUT31 ">".$id."\n";
						print OUTPUT31 $new_contig_seed."\n";
						close OUTPUT31;
						
						if (-s $final_assembly_file && -s $output_file31)
						{			
							my $file_tmp = $output_path."blast_seed_test_".$id.".txt";
							my $command = "blastn -query ".$output_file31." -subject ".$final_assembly_file." -out ".$file_tmp." -outfmt 7 -qcov_hsp_perc 99";
							syscmd($command);
							my $count_tmp2 = '0';
NEXT_SEED_ACCEPT0:									
							if (-s $file_tmp)
							{
								open(SEED_TEST2, $file_tmp) or die "\nCan't open file $file_tmp, $!\n";
								
								my $count_lines_tmp = '1';
								while (my $line_tmp = <SEED_TEST2>)
								{
									chomp($line_tmp);
									if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
									{
										close SEED_TEST2;
										goto NEXT_SEED_ACCEPT0b;
									}
									elsif ($count_lines_tmp eq '5' && $line_tmp eq "# BLAST processed 1 queries")
									{
										close SEED_TEST2;
										$count_tmp2++;
										goto NEXT_SEED_ACCEPT0;
									}
									elsif ($count_lines_tmp > 5)
									{
										my @line_tmp = split /\t/, $line_tmp;
										my $accuracy_tmp = $line_tmp[2];
			
										if ($accuracy_tmp > 99.9)
										{
											close SEED_TEST;
											print {$filehandle{$seed_id2}} $line_tmp." CONTIG_BREAK_MATCH\n";
											delete $split_contigs_reads{$contig_number_tmp}{$id}{$new_contig_seed};
											goto NEXT_SEED_ACCEPT0b;
										}  
									}
									$count_lines_tmp++;
								}
								close SEED_TEST2;
							}
							elsif ($count_tmp2 < 100000)
							{
								$count_tmp2++;
								goto NEXT_SEED_ACCEPT0;
							}
						}
NEXT_SEED_ACCEPT0b:					
					}
				}	
            }
			if ($NP_reads_support ne "" && $NP_reads_support ne "yes")
			{
				$NP_reads_support = "yes";
				$NP_reads_support_SNR = "";
				print {$filehandle{$seed_id2}} $best_extension." RESET_NP_SUPPORT2\n";
			}
     
NP_READS:
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Check NP reads----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            if (($NP_reads ne "" || $input_reads_DB_folder_NP ne "") && length($read) > 300 && (($NP_reads_support ne "yes" && $NP_reads_support ne "") || ($PB_reads eq "" && $input_reads_DB_folder_PB eq "")))
            {     
                my $first_length_back = '900';
				my $flexible_seed = "";

                if ($first_length_back > length($read))
                {
                    $first_length_back = length($read)-50;
                }
                
                if ($find_haps_in_seed eq "yes")
                {
                    $first_length_back = length($read);
					if ($assembly_length_max eq "WG" && $first_length_back > 5100 && $first_back_assembly eq "")
					{
						$read = substr $read, 100, 5000;
						$seed{$id} = $read;
						$first_length_back = 5000;
					}
                }
				my $full_reset_time = "";
				if (exists($full_reset_time_stop{$seed_id}))
				{
					if ($position < $full_reset_time_stop{$seed_id})
					{
						$full_reset_time = "";
						delete $full_reset_time{$seed_id};
					}
				}
				if (exists($full_reset_time{$seed_id}))
				{
					$full_reset_time = $full_reset_time{$seed_id};
					if ($position > $full_reset_time)
					{
						delete $full_reset_time{$seed_id};
						$full_reset_time = "";
					}
					else
					{
						delete $exclude_reads_NP{$seed_id};
						delete $save_alignment_data_NP{$seed_id};
						delete $rejected_alignment_data_NP{$seed_id};
					}
				}
				
                my $discontiguous_blast = "";
                my $last_hap_pos = "";
				my $last_hap_pos_DUP = "";
                my %hash_NP_reads_tmp;
                undef %hash_NP_reads_tmp;
				my %hash_NP_reads_tmp_back;
				undef %hash_NP_reads_tmp_back;
				my $query_coverage = '90';
				my $query_accuracy = '70';
				my $full_reset_NP_tmp = "";
				my $skipped_matches = '0';
				
				if ($full_reset_NP ne "")
				{
					$discontiguous_blast = "yes";
				}
				
SKIP_CONFIRMED_NP:
                               
                my %id_matches;
                undef %id_matches;
                my %double_matches;
				undef %double_matches;
                my %reverse_list;
                undef %reverse_list;
				my $no_go_back_sort_matches = "";

				my $only_saved_reads = "";
				my $new_contig_check = "";
				
				if ($y eq "1")
				{
					foreach my $id_read (keys %{$split_contigs_reads2{$id}})
					{
						$id_matches{$id_read} = undef;
						if ($split_contigs_reads2{$id}{$id_read} eq "yes")
						{
							$reverse_list{$id_read} = "yes";
						}
						$new_contig_check = "yes";
					}
				}

#Find matches in hash against last 600 bp--------------------------------------------------------------                           
	
LONGER_LAST_600_NP:

				my $last_600 = substr $read, -$first_length_back;
				my %first_pos_read;
				undef %first_pos_read;
                my $time_NP_find_matches = time;
				
				my %output_files_DB;
				undef %output_files_DB;
                my %output_files_DB2;
				undef %output_files_DB2;
				
				if ($new_contig_check eq "yes")
				{
					goto SKIP_TO_CONFIRMED_NP;
				}
                
                my $query_file_DB = $TMP_directory."query_NP_".$project.".fasta";
                open(INPUT_QUERY_NP, ">" .$query_file_DB) or die "\nCan't open file $query_file_DB, $!\n";
                #print INPUT_QUERY_NP ">ref\n";
                print INPUT_QUERY_NP $last_600;        
                close INPUT_QUERY_NP;       
                
                foreach my $pid_tmp (keys %ret_data_NP)
                {
                    my $file_tmp = $TMP_directory."blast_tmp_DB_NP_".$id."_".$y."_".$pid_tmp.".txt";
                    my $command_DB = "blastn -query ".$query_file_DB." -db ".$ret_data_NP{$pid_tmp}." -out ".$file_tmp." -outfmt 7 -qcov_hsp_perc 90 &";
                    syscmd($command_DB);             
                    $output_files_DB{$file_tmp} = undef;
                    $output_files_DB2{$file_tmp} = undef;
                }
								
#Add saved reads--------------------------------------------------------------                           						
                #my $time1a = time;
                #my $time1a_tmp = $time1a - $time_START;
                #print {$filehandle{$seed_id2}} $time1a_tmp." TIME1a\n";
SKIP_TO_CONFIRMED_NP:
				my %extensions;
				undef %extensions;
                my %extensions2;
				undef %extensions2;
				my %extensions2_VIP;
				undef %extensions2_VIP;
                my %extensions2b;
				undef %extensions2b;
                my %extensions_nomatch;
                undef %extensions_nomatch;
                my %extensions_unknown;
				undef %extensions_unknown;
                my %extensions_nomatch2;
                undef %extensions_nomatch2;
                my %extensions_nomatch2b;
				undef %extensions_nomatch2b;
                my %extensions_unknown2;
                undef %extensions_unknown2;
                my %store_mismatches_NP;
				undef %store_mismatches_NP;
                my %store_mismatches_all_NP;
                undef %store_mismatches_all_NP;
				my %store_mismatches_N_NP;
				undef %store_mismatches_N_NP;
				my $added_unknown = "";
				
				my $extensions_nomatch2b_count = '0';
                my $extensions_nomatch2b_count_saved = '0';
                my $total_matches_extra = '0';
                my %position_prev;
				undef %position_prev;
                my %alignment_length_saved;
                undef %alignment_length_saved;
				my %score_match_saved;
				undef %score_match_saved;
                my %score_no_match_saved;
                undef %score_no_match_saved;
                my %score_match_DUP_saved;
				undef %score_match_DUP_saved;
                my %score_no_match_DUP_saved;
                undef %score_no_match_DUP_saved;
				my %score_match_VIP_saved;
				undef %score_match_VIP_saved;
                my %score_no_match_VIP_saved;
                undef %score_no_match_VIP_saved;
                my %accuracy_saved;
				undef %accuracy_saved;
                my %read_start_pos_rej;
                undef %read_start_pos_rej;
                my %read_start_pos_rej_saved;
				undef %read_start_pos_rej_saved;
                my %extensions_nomatch2b_saved;
                undef %extensions_nomatch2b_saved;
                
                foreach my $seed_id_tmp0 (keys %save_alignment_data_NP)
                {
                    if ($seed_id_tmp0 eq $seed_id)
                    {
                        foreach my $id_tmp7 (keys %{$save_alignment_data_NP{$seed_id_tmp0}})
                        {
                            if ($id_tmp7 eq "101a27009a3" || $id_tmp7 eq "65a29618a3")
							{
								#print {$filehandle{$seed_id2}} $save_alignment_data_NP{$seed_id_tmp0}{$id_tmp7}." 78a3762a1_CHECKKKKK\n\n";
								print {$filehandle{$seed_id2}} $id_tmp7." READ_CHECKKKKK\n\n";
							}
							my @alignment_data = split /_/, $save_alignment_data_NP{$seed_id_tmp0}{$id_tmp7};

                            if ($alignment_data[0] eq "yes" || $alignment_data[13] eq "")
                            { 
                                $alignment_length_saved{$id_tmp7} = $alignment_data[4];
                                $first_pos_read{$id_tmp7} = $alignment_data[2];
                                $position_prev{$id_tmp7} = $alignment_data[3];
                                $score_match_saved{$id_tmp7} = $alignment_data[5];
                                $score_no_match_saved{$id_tmp7} = $alignment_data[6];
                                $score_match_DUP_saved{$id_tmp7} = $alignment_data[7];
                                $score_no_match_DUP_saved{$id_tmp7} = $alignment_data[8];
								$score_match_VIP_saved{$id_tmp7} = $alignment_data[9];
                                $score_no_match_VIP_saved{$id_tmp7} = $alignment_data[10];
                                $accuracy_saved{$id_tmp7} = $alignment_data[11];
                            }
                           
                            if ((($alignment_data[6] > $alignment_data[5] && $alignment_data[6] > 1) || ($alignment_data[10] > $alignment_data[9]) || ($alignment_data[8] > $alignment_data[7] && ($alignment_data[8] > 3
								|| $alignment_data[6]+$alignment_data[8] > $alignment_data[5]+$alignment_data[7])) || (exists($exclude_reads_NP{$id}{$id_tmp7})) || $alignment_data[15] eq "yes") && $full_reset_NP eq "")
                            {
								$extensions_nomatch2b_saved{$id_tmp7}{$alignment_data[5]+$alignment_data[9]}{$alignment_data[6]+$alignment_data[10]}{$alignment_data[4]}{$alignment_data[3]} = $alignment_data[12]; #CHECK tthis 12 for HiFi
								$extensions_nomatch2b_count_saved++;
								if ($alignment_data[1] eq "yes")
                                {
                                    $reverse_list{$id_tmp7} = undef;
                                }
								if ($id_tmp7 eq "101a27009a3" || $id_tmp7 eq "65a29618a3")
								{
									#print {$filehandle{$seed_id2}} $save_alignment_data_NP{$seed_id_tmp0}{$id_tmp7}." 78a3762a1_CHECKKKKK\n\n";
									print {$filehandle{$seed_id2}} $id_tmp7." READ_CHECKKKKK1\n\n";
								}
                            }
							elsif ($alignment_data[0] ne "yes" && $alignment_data[13] ne "" && $full_reset_NP eq "")
                            {
                                $read_start_pos_rej{$id_tmp7} = $alignment_data[13]+$position-$alignment_data[3];
                                $read_start_pos_rej_saved{$id_tmp7} = undef;
                                if ($alignment_data[1] eq "yes")
                                {
                                    $reverse_list{$id_tmp7} = undef;
                                }
								if ($id_tmp7 eq "101a27009a3" || $id_tmp7 eq "65a29618a3")
								{
									#print {$filehandle{$seed_id2}} $save_alignment_data_NP{$seed_id_tmp0}{$id_tmp7}." 78a3762a1_CHECKKKKK\n\n";
									print {$filehandle{$seed_id2}} $id_tmp7." READ_CHECKKKKK2\n\n";
								}
                            }
                            else
                            {
								if ($id_tmp7 eq "101a27009a3" || $id_tmp7 eq "65a29618a3")
								{
									#print {$filehandle{$seed_id2}} $save_alignment_data_NP{$seed_id_tmp0}{$id_tmp7}." 78a3762a1_CHECKKKKK\n\n";
									print {$filehandle{$seed_id2}} $id_tmp7." READ_CHECKKKKK3\n\n";
								}
								$id_matches{$id_tmp7} = undef;
                                $total_matches_extra++;
                                if ($alignment_data[1] eq "yes")
                                {
                                    $reverse_list{$id_tmp7} = undef;
                                }
								if ($alignment_data[14] ne "")
								{
									$hash_NP_reads_tmp{$id_tmp7} = $alignment_data[14];
								}
                            }				
                        }
                    }
                }                                          
                print {$filehandle{$seed_id2}} $total_matches_extra." LAST_1000_matches_EXTRA\n\n";
				
				#my $time1b = time;
                #my $time1b_tmp = $time1b - $time_START;
                #print {$filehandle{$seed_id2}} $time1b_tmp." TIME1b\n";
				
				my $database_count_tmp = '0';
DB_RESULTS_NP:  foreach my $blast_db_results_tmp (keys %output_files_DB)
                {
                    if (-s $blast_db_results_tmp)
                    {
						my $file_complete = "";
DB_RESULTS_NP1:                       
						open(BLAST_RESULTS_DB_NP, $blast_db_results_tmp) or die "\nCan't open DB file $blast_db_results_tmp, $!\n";
                        my $count_lines_tmp = '1';
						
                        while (my $line_tmp = <BLAST_RESULTS_DB_NP>)
                        {
                            chomp($line_tmp);
							if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
                            {
                                delete $output_files_DB{$blast_db_results_tmp};
								close BLAST_RESULTS_DB_NP;
                                next DB_RESULTS_NP;
                            }
							elsif ($count_lines_tmp eq '5' && $line_tmp eq "# BLAST processed 1 queries")
                            {
                                delete $output_files_DB{$blast_db_results_tmp};
								close BLAST_RESULTS_DB_NP;
                                next DB_RESULTS_NP;
                            }
                            elsif ($count_lines_tmp > 5 && $line_tmp eq "# BLAST processed 1 queries" && $file_complete eq "")
                            {
								$file_complete = "yes";
								delete $output_files_DB{$blast_db_results_tmp};
								close BLAST_RESULTS_DB_NP;
								goto DB_RESULTS_NP1;
                            }
                            elsif ($count_lines_tmp > 5 && $file_complete eq "yes")
                            {
                                my @line_tmp = split /\t/, $line_tmp;
                                my $id_tmp = $line_tmp[1];
                                my $accuracy_tmp = $line_tmp[2];
								my $alignment_length = $line_tmp[3];
                                my $read_pos_start_tmp = $line_tmp[8];
                                my $read_pos_end_tmp = $line_tmp[9];

                                if ($alignment_length < 0.8*$first_length_back && $first_length_back < 1100)
                                {
									next;
                                }
								if (exists($exclude_reads_NP{$id}{$id_tmp}))
                                {
								    next;
                                }
								if (exists($rejected_alignment_data_NP{$seed_id}{$id_tmp}))
                                {
									next;
                                }
                                if (exists($save_alignment_data_NP{$seed_id}{$id_tmp}))
                                {
									next;
                                }
                                if ($accuracy_tmp > $query_accuracy)
                                {
									if (exists($id_matches{$id_tmp}))
                                    {
                                        if ($read_pos_end_tmp < $read_pos_start_tmp) 
                                        {
                                            if (exists($reverse_list{$id_tmp}))
											{			
											}
											else
											{
												$double_matches{$id_tmp} = undef;
											}
											$reverse_list{$id_tmp} = undef;	
                                        }
										delete $first_pos_read{$id_tmp};
                                    }
                                    else
                                    {
                                        $id_matches{$id_tmp} = undef;
										
										if ($assembly_length_max eq "WG")
										{
											$reads_as_seeds{$id_tmp} = undef;
											print OUTPUT19 $id_tmp."\n";
										}
						
                                        if ($read_pos_end_tmp < $read_pos_start_tmp) 
                                        {
                                            $reverse_list{$id_tmp} = undef;
                                            $first_pos_read{$id_tmp} = $read_pos_start_tmp;
                                        }
                                        else
                                        {
                                            $first_pos_read{$id_tmp} = $read_pos_end_tmp;
                                        }
                                    }        
                                }
                            }
                            $count_lines_tmp++;
                        }
                        close BLAST_RESULTS_DB_NP;
                    }
                }
                if (keys %output_files_DB > 0)
                {
                    goto DB_RESULTS_NP;
                }

                my $time_kmers = time;
                my $time1 = $time_kmers - $time_START;
                print {$filehandle{$seed_id2}} $time1." TIME1\n";
				
				my $total_matches = keys %id_matches;
				print {$filehandle{$seed_id2}} "\n".$total_matches." LAST_1000_matches\n";
				
				if ($assembly_length_max eq "WG" && $y eq "1" && ($total_matches > $sequencing_depth_NP*1.7 || ($total_matches < 10 && $total_matches < $sequencing_depth_NP*0.35)) && ($first_back_assembly eq "" || length($read) < 5000))
				{
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
						delete $output_files_DB2{$blast_db_results_tmp};
					}
					unlink $output_file5;
					unlink $output_file13;
					foreach my $seed_id_tmp (keys %seed)
					{
						my $contig_tmp_file = $output_path."contigs_tmp_".$seed_id_tmp."_".$project.".fasta";
						unlink $contig_tmp_file;
					}
					#print $total_matches." READ_REJECTED1\n";
					print {$filehandle{$seed_id2}} $total_matches." READ_REJECTED1\n";
					if ($total_matches < $sequencing_depth_NP*2.5 && $total_matches > 5)
					{
						$WG_rejected_reads{$id} = undef;
					}
					$first_back_assembly = "yes";
					goto END1;
				}
				
				if ($total_matches < 5 && $y eq "1" && $flexible_seed eq "" && $new_contig_check eq "")
                {
					$query_coverage = '70';
					$query_accuracy = '60';
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_NP_reads_tmp;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
					$flexible_seed = "yes";
                    goto SKIP_CONFIRMED_NP;
                }
				if ($total_matches > 900 && $total_matches > $sequencing_depth_NP*4 && $first_length_back < 6000 && $new_contig_check eq "")
				{
					$first_length_back += 1500;
					if ($total_matches > 5000)
					{
						$first_length_back += 1500;
					}
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_NP_reads_tmp;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
					goto LONGER_LAST_600_NP;
				}
				if ($repetitive_detect2 ne "" && $repetitive_detect2 > $first_length_back && $total_matches > 1000 && $total_matches_extra > 9 && $only_saved_reads eq "")
				{
					$only_saved_reads = "yes";
					undef %id_matches;
					undef %double_matches;
					undef %reverse_list;
					undef %hash_NP_reads_tmp;
					undef %output_files_DB;
					undef %output_files_DB2;
					foreach my $blast_db_results_tmp (keys %output_files_DB2)
					{
						unlink $blast_db_results_tmp;
					}
					goto SKIP_TO_CONFIRMED_NP;
				}
				
				if ($total_matches < 3 && $position > 15000 && $clip_read < $position-12000 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "")
				{
					$clip_read = $position;
					substr $read, -11000, 11000, "";
					$position = length($read);
					$position{$id} = $position;
					$seed{$id} = $read;

					delete $exclude_reads_NP{$seed_id};
					delete $save_alignment_data_NP{$seed_id};
					delete $rejected_alignment_data_NP{$seed_id};
					$y++;
					$y{$id} = $y;
					
					foreach my $pos_split (keys %{$split_positions{$id}})
					{
						if (exists($split_positions_VIP{$id}{$pos_split}))
						{}
						elsif ($pos_split > $position+length($best_extension)+150)
						{
							delete $split_positions{$id}{$pos_split};
						}
					}
					foreach my $pos_split (keys %{$split_positions_DUP{$id}})
					{
						if (exists($split_positions_VIP{$id}{$pos_split}))
						{}
						elsif ($pos_split > $position+length($best_extension)+150)
						{
							delete $split_positions_DUP{$id}{$pos_split};
							delete $split_positions_DUP2{$id}{$pos_split};
						}
					}
					
					if ($hap_compare_pos{$id} > $position)
					{
						$hap_compare_pos{$id} = $position;
					}
					print {$filehandle{$seed_id2}} $clip_read." CLIP_READ\n";
					goto NP_READS;
				}
				
				if (exists($track_coverage{$id}{$position}))
				{
					delete $track_coverage{$id}{$position};
				}
				
				my $add_no_match_reads_stop = "";
				my $add_rejected_reads_stop = "";  
#--------------------------------------------------------------------------------------------------------------------------------------------------               
#Sort matches by alignment length------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------------------------------------
SORT_MATCHES_NP:		
                my $count_matches_with_high_scores = '0';
                my $longest_read = '0';              
                my %check_prev_splits;
                undef %check_prev_splits;
                my %accuracy;
				undef %accuracy;
                my $count_limit1 = '0';         
               
                my %ref_part;
                undef %ref_part;
                my %var_matches;
				undef %var_matches;
                my %var_matches_DUP;
                undef %var_matches_DUP;
                my %alignment_length_save;
				undef %alignment_length_save;
				my %alignment_length_save2;
				undef %alignment_length_save2;
                my %long_read_end_pos_save;
                undef %long_read_end_pos_save;
				my %rejected_reads_save;
				undef %rejected_reads_save;
                my %multi_match;
                undef %multi_match;
                my %multi_match_pos;
				undef %multi_match_pos;
                my %length_ext_all;
				undef %length_ext_all;

                my $count_limit2 = '0';
                my $count_attempts = '0';
                
                my $ref_end_rejection = '0';
                my $read_start_pos_rejection = '0';
                my $no_hit_rejection = '0';
                my $almost_no_hit_rejection = '0';
                my $ext_too_short = '0';
                my $match_too_short = '0';
                my $overlap_too_short = '0';
                my $accuracy_rejection = '0';
                my $multi_match_rejection = '0';
                my $ref_end_rejection_threshold = '150';
                if ($discontiguous_blast ne "")
                {
                    $ref_end_rejection_threshold = '400';
                }
                my %score_matches_save;
                undef %score_matches_save;
                my $add_rejected_reads = "";
				my $add_rejected_reads_pos = "";
				my $add_rejected_reads_low_longest = "";
                my $add_no_match_reads = "";
				my $add_no_match_reads_pos = "";
				my $add_rejected_and_no_match_reads = "";
                my %save_reads_for_next;
                undef %save_reads_for_next;
				my %SNP_matches;
				undef %SNP_matches;
				my %SNP_no_matches;
				undef %SNP_no_matches;
ADD_REJ_POS_NP:
                my %id_by_length;
                undef %id_by_length;
                my %printed_refs;
				undef %printed_refs;
                my %printed_refs2;
                undef %printed_refs2;
                my %printed_blast;
				undef %printed_blast;
                my %add_rej_reads_extra;
                undef %add_rej_reads_extra;
				my %input_files_blast;
				undef %input_files_blast;
				my $count_total_matches = '0';
				my %input_length_done;
				undef %input_length_done;
				my %input_BLAST_done;
				undef %input_BLAST_done;
				my %double_match_check;
				undef %double_match_check;
				my %double_match_reject;
				undef %double_match_reject;
               
                foreach my $id_tmp (keys %id_matches)
                {        
					my $length_tmp = "";
					if (exists($first_pos_read{$id_tmp}))
					{
						$length_tmp = $first_pos_read{$id_tmp};
						if (exists($alignment_length_saved{$id_tmp}))
						{
							$length_tmp = $alignment_length_saved{$id_tmp}+$position-$position_prev{$id_tmp};
						}
						elsif (exists($reverse_list{$id_tmp}) && exists($hash_NP_reads_tmp{$id_tmp}))
						{
							$length_tmp = length($hash_NP_reads_tmp{$id_tmp})-$first_pos_read{$id_tmp};
						}
					}
					elsif (exists($hash_NP_reads_tmp{$id_tmp}))
					{
						$length_tmp = length($hash_NP_reads_tmp{$id_tmp});
					}
					else
					{
						$length_tmp = 1;
					}
										
					if (exists($id_by_length{$length_tmp}))
					{
						while (exists($id_by_length{$length_tmp}))
						{
							$length_tmp += 1;
						}
						$id_by_length{$length_tmp} = $id_tmp;
					}
					else
					{
						$id_by_length{$length_tmp} = $id_tmp;
					}
                }
#BLAST--------------------------------------------------------------------------------------------------------------------------
				my $time_tmp1 = '0';
				my $time_tmp2 = '0';
                foreach my $length_tmp (sort {$b <=> $a} keys %id_by_length)
                {                
                    my $time_tmp0 = time;
					my $id_tmp2 = $id_by_length{$length_tmp};
					if (exists($save_alignment_data_NP{$seed_id}{$id_tmp2}))
					{}
					elsif (exists($first_pos_read{$id_tmp2}))
					{}
					elsif ($count_total_matches > 100 && $count_total_matches > $sequencing_depth_NP*10 && $skipped_matches ne "no" && $total_matches_extra > 5)
					{
						$skipped_matches++;
						next;
					}
					else
					{
						$count_total_matches++;
					}
					if (exists($input_length_done{$length_tmp}))
					{
						next;
					}

					my $length_tmp2 = $length_tmp;
					
					if (exists($hash_NP_reads_tmp{$id_tmp2}))
					{}
					else
					{
						my @split_tmp = split /a/, $id_tmp2;
						my $output_file_NP1  = $tmp_sequences_directory_NP.$output_path_test.$split_tmp[0]."a".$output_path_test.$split_tmp[2].$output_path_test."sequence_tmp_NP_".$id_tmp2.".fasta";
						open(OUTPUT_LONG_NP4, $output_file_NP1) or die "\nCan't open file $output_file_NP1, $!\n";
						my $firstLine = <OUTPUT_LONG_NP4>;
						close OUTPUT_LONG_NP4;
						$hash_NP_reads_tmp{$id_tmp2} = $firstLine;
						$length_tmp2 = length($firstLine);
					}
					
					
                    my $double_match_tmp = "";                   
DOUBLE_MATCH1:                   
                    my $reverse_check = "";
                    my @split_tmp = split /a/, $id_tmp2;
                    my $output_file1  = $tmp_sequences_directory_NP.$output_path_test.$split_tmp[0]."a".$output_path_test.$split_tmp[2].$output_path_test."sequence_tmp_NP_".$id_tmp2.".fasta";
                    
                    if (exists($reverse_list{$id_tmp2}) && $double_match_tmp eq "")
                    {
                        $output_file1  = $tmp_sequences_directory_NP.$output_path_test.$split_tmp[0]."a".$output_path_test.$split_tmp[2].$output_path_test."sequence_tmp_NP_".$id_tmp2."_rev.fasta";
                        $reverse_check = "_rev";
                    }

                    if (exists($printed_reads_NP{$id_tmp2.$reverse_check}))
                    {
                    }
                    elsif (exists($reverse_list{$id_tmp2}) && $double_match_tmp eq "")
                    {                      
                        my $long_read_tmp = reverse($hash_NP_reads_tmp{$id_tmp2});
                        $long_read_tmp =~ tr/ACTG/TGAC/;
                        open(OUTPUT_LONG1, ">" .$output_file1) or die "\nCan't open file $output_file1, $!\n";
						OUTPUT_LONG1->autoflush(1);
                        #print OUTPUT_LONG1 ">".$id_tmp2."\n";
                        print OUTPUT_LONG1 $long_read_tmp;
                        close OUTPUT_LONG1;
                        $printed_reads_NP{$id_tmp2.$reverse_check} = undef;
                    }                               
                    
                    my $ref_part = "";
                    my $ref_file = "";                  
                    my $length_tmp_final = int(($length_tmp2*1.1)+50);
                    if ($length_tmp_final > length($read))
                    {
                        $length_tmp_final = length($read);
                    }
                    if (exists($printed_refs{$length_tmp_final}))
                    {
                        $ref_file = $printed_refs{$length_tmp_final};
                    }                
                    else
                    {
                        my $ref_part_found = "";
                        
                        if ($add_rejected_reads eq "" && $add_rejected_and_no_match_reads eq "")
                        {
                            foreach my $length_tmp3 (sort {$a <=> $b} keys %printed_refs)
                            {
                                if ($length_tmp3 >= $length_tmp_final-50 && ($length_tmp3 < $length_tmp_final+800 || $length_tmp3-$length_tmp_final < $length_tmp_final*0.1))
                                {
                                    $ref_file = $printed_refs{$length_tmp3};
                                    $ref_part_found = "yes";
                                    $length_tmp_final = $length_tmp3;
                                    last;
                                }
                            }
                        }
                        
                        if ($ref_part_found eq "")
                        {
                            $ref_part = substr $read, -$length_tmp_final;
                            $ref_file = $TMP_directory."ref_tmp_".$id_tmp2."_".$y.".fasta";
                            $printed_refs{$length_tmp_final} = $ref_file;
                            $printed_refs2{$id_tmp2} = undef;
                            open(OUTPUT_LONG2, ">" .$ref_file) or die "\nCan't open file $ref_file, $!\n";
							OUTPUT_LONG2->autoflush(1);
                            #print OUTPUT_LONG2 ">ref\n";
                            print OUTPUT_LONG2 $ref_part;							
                            close OUTPUT_LONG2;
                        }
                    }

                    $ref_part{$id_tmp2} = $length_tmp_final;
                    $printed_blast{$id_tmp2} = $ref_file; 
                
                    chomp($output_file1);
                    chomp($ref_file);
										
					$input_files_blast{$length_tmp}{$output_file1}{$ref_file}{$length_tmp_final} = $double_match_tmp;
					$input_length_done{$length_tmp} = undef;
					
					if (-s $output_file1)
					{
					}
					else
					{
						print "the file ".$output_file1." does not exist!\n";
					}
					if (-s $ref_file)
					{
					}
					else
					{
						print "the file ".$ref_file." does not exist!\n";
					}
					
					my $time_tmp0b = time;
					$time_tmp1 += ($time_tmp0b-$time_tmp0);

					my $command = "blastn -query ".$ref_file." -subject ".$output_file1." -out ".$TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp2.".txt -outfmt 5 -strand plus -culling_limit 1 &";
					#my $command = "blastn -task dc-megablast -query ".$ref_file." -subject ".$output_file1." -out ".$output_path."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp2.".txt -outfmt 5 -strand plus -evalue 1e-50 -culling_limit 1 &";
					if ($discontiguous_blast eq "yes")
					{
						$command = "blastn -task dc-megablast -query ".$ref_file." -subject ".$output_file1." -out ".$TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp2.".txt -outfmt 5 -strand plus -culling_limit 1 &";
					}
					elsif ($find_haps_in_seed ne "")
					{
						$command = "blastn -query ".$ref_file." -subject ".$output_file1." -out ".$TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp2.".txt -outfmt 5 -strand plus -reward 2 -penalty -3 -evalue 1e-50 -culling_limit 1 &";
					}

					#my $command = sprintf("blastn -query %s -subject %s -out blast_tmp_".$id_tmp.".txt -outfmt 10 -gapextend 1 -gapopen 2", $output_file1, $ref_file);
					#my $command = "blastn -query ".$output_file1." -subject ".$ref_file." -out blast_tmp_".$id_tmp.$double_match_tmp.".txt -outfmt 10 -gapextend 1 -gapopen 2 -best_hit_score_edge 0.03 -best_hit_overhang 0.4 -evalue 1e-50";
					#my $command2 = 'cp sequence_tmp.fasta sequence_tmp_THIS_WORKS.fasta';
					#my $system_result = qx/$command2/;               
					syscmd($command);

					if ($save_reads eq "yes")
					{
						if (exists($assembled_reads{$id_tmp2}))
						{}
						else
						{
							$assembled_reads{$id_tmp2} = undef;
							if ($save_reads eq "yes")
							{
								print OUTPUT11 ">".$id_tmp2."_".$id."\n";
								print OUTPUT11 $hash_NP_reads_tmp{$id_tmp2}."\n";
							}  
						}
					}
					$input_BLAST_done{$length_tmp} = undef;
					
					$time_tmp2 += (time-$time_tmp0b);
                    
                    if (exists($double_matches{$id_tmp2}) && $double_match_tmp eq "")
                    {
                        $double_match_tmp = "yes";
                        goto DOUBLE_MATCH1;
                    }
                }
				
				my $time_id_by_length = time;
                my $time_sort_matches = $time_id_by_length - $time_kmers;
                print {$filehandle{$seed_id2}} $time_sort_matches." TIME_SORT_MATCHES\n";
				 print {$filehandle{$seed_id2}} $time_tmp1." TIME_SORT_MATCHES1\n";
				  print {$filehandle{$seed_id2}} $time_tmp2." TIME_SORT_MATCHES2\n";
				
				my $double_matches_running = '0';

                my $count_BLAST_runnng = keys %input_BLAST_done;

#Read BLAST--------------------------------------------------------------------------------------------------------------------------

                foreach my $blast_db_results_tmp (keys %output_files_DB2)
                {
                    unlink $blast_db_results_tmp;
					delete $output_files_DB2{$blast_db_results_tmp};
                }
BLAST_RUN_NP:	
BLAST1_NP:      foreach my $length_tmp (sort {$a <=> $b} keys %input_files_blast)
                {                
                    my $id_tmp3 = $id_by_length{$length_tmp};
                    
                    foreach my $read_file_tmp (keys %{$input_files_blast{$length_tmp}})
                    {
						foreach my $ref_file_tmp (keys %{$input_files_blast{$length_tmp}{$read_file_tmp}})
						{
							foreach my $length_final_tmp (keys %{$input_files_blast{$length_tmp}{$read_file_tmp}{$ref_file_tmp}})
							{	
								my $double_match_tmp = $input_files_blast{$length_tmp}{$read_file_tmp}{$ref_file_tmp}{$length_final_tmp};              
								my $input_BLAST  =  $TMP_directory."blast_tmp_".$id."_".$y."_".$double_match_tmp."_".$id_tmp3.".txt";

								if (-s $input_BLAST)
								{
									my $prev_line = "";
									my $prev_line2 = "";
									open(INPUT_BLAST, $input_BLAST);
									while (my $line_tmp = <INPUT_BLAST>)
									{              
										$prev_line2 = $prev_line;
										$prev_line = $line_tmp;
									}
									close INPUT_BLAST;
									chomp($prev_line2);
									if ($prev_line2 eq "</BlastOutput>")
									{
										open(INPUT_BLAST, $input_BLAST);
									}
									else
									{
										next BLAST1_NP;
									}
								}
								else
								{
									next BLAST1_NP;
								}

								my $length_long_read_tmp = length($hash_NP_reads_tmp{$id_tmp3});
								#my $ref_part = substr $read, -$ref_part{$id_tmp3};
								#my $N_count_ref = $ref_part =~ tr/N/N/;
								if ($ref_part{$id_tmp3} eq '0' || $ref_part{$id_tmp3} eq "")
								{
									print {$filehandle{$seed_id2}} $length_tmp." 0ERROR\n";
									print {$filehandle{$seed_id2}} $id_tmp3." 0ERRORbbb\n";
									goto END1;
								}
								#my $N_correction = ($N_count_ref/$ref_part{$id_tmp3})*100;
								if (exists($double_matches{$id_tmp3}))
								{
									if (exists($double_match_check{$id_tmp3}))
									{
										$double_match_check{$id_tmp3} = "yes2";
									}
									else
									{
										$double_match_check{$id_tmp3} = "yes";
									}
								}							
								
#BLAST1&2-----------------------------------------------------------------------------------------------------
						
								my $j = '0';
								my $ref_pos = '0';
								my $score_match = '0';
								my $score_no_match = '0';
								my $score_match_DUP = '0';
								my $score_no_match_DUP = '0';
								my $no_match_region = '0';
								my $no_match_region_high = '0';
								my $score_match_VIP = '0';
								my $score_no_match_VIP = '0';
								my $bit_score_start = "";
								my $assembly_start_pos_start = "";
								my $assembly_end_pos_start = "";
								my $read_start_pos_start = "";
								my $read_end_pos_start = "";
								my $query_start = "";
								my $subject_start = "";
								my $mismatch_start = "";
								my $alignment_length2_start = "";
								my $pos_matches_start = "";
								my $query = "";
								my $subject = "";
								my $mismatch = "";
								my %query;
								undef %query;
								my %subject;
								undef %subject;
								my %mismatch;
								undef %mismatch;
								my $bit_score = "";
								my $multiple_matches = "";
								my $multi_gap = '250';
			   
								my $alignment_length = "";
								my $alignment_length2 = '0';
								my $pos_matches = '0';
								my $long_read_start_pos = "";
								my $long_read_end_pos = "";
								my $assembly_end_pos = "";
								my $assembly_start_pos = "";
								my %long_read_start_pos;
								undef %long_read_start_pos;
								my %long_read_end_pos;
								undef %long_read_end_pos;
								my %assembly_end_pos;
								undef %assembly_end_pos;
								my %assembly_start_pos;
								undef %assembly_start_pos;
								my %multi_match_pos_tmp;
								undef %multi_match_pos_tmp;
								my $maybe_match_VIP = '0';
								
								my $read_pass = "";
								my $accuracy = "";
				  
								my $largest_prev_split = "";
								my $largest_prev_split_ext = "";
								my $skip_id = "";
								my $count_multimatch = '1';
								
								my $assembly_start_pos_low = "1";
								my $long_read_start_pos_high = "1";
								my $assembly_end_pos_high = "1";
								my $long_read_end_pos_high = "1";
								my $match_confirmed = "";
			
INPUT_BLAST_NP:                 while (my $line2 = <INPUT_BLAST>)
								{                                                     
									chomp($line2);
	
									if ($j > 26)
									{
										my @blast_result_tmp;
										undef @blast_result_tmp;
										if ($j < $assembly_start_pos_start || $assembly_start_pos_start eq "")
										{
											@blast_result_tmp = split /\s+/, $line2;
										}
										
										if ($j eq '27' && $blast_result_tmp[0] ne "<Hit>")
										{
											#print {$filehandle{$seed_id2}} "\n".$id_tmp3." ID\n";
											#print {$filehandle{$seed_id2}} $blast_result_tmp[0] ." NO_HIT_REJECTION\n";
											$no_hit_rejection++;
											$skip_id = "no_hit_rejection";
											goto SKIP_BLAST1_NP;
										}
										elsif ($j eq '27')
										{
											#print {$filehandle{$seed_id2}} "\n".$id_tmp3." ID\n";
										}
										 
										if ($blast_result_tmp[0] eq "</BlastOutput>")
										{
											print {$filehandle{$seed_id2}} $assembly_start_pos." REF_START_POS  ".$long_read_start_pos." READ_START_POS  ".$long_read_end_pos." READ_END_POS\n";
											#if ($ref_pos < length($check_prev_splits2{$check_prev_splits_id}))
											#{
												#$read_pos += (length($check_prev_splits2{$check_prev_splits_id}) - $ref_pos);
											   # print {$filehandle{$seed_id2}} length($check_prev_splits2{$check_prev_splits_id}) - $ref_pos." READ_POS_CORRECTION\n";
										   # }
											last INPUT_BLAST_NP;
										}
										elsif ($bit_score_start ne "" && $bit_score_start eq $j)
										{
										}
										elsif ($assembly_start_pos_start ne "" && $assembly_start_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$assembly_start_pos = substr $blast_result_tmp2[1], 15;
											$assembly_start_pos{$count_multimatch} = $assembly_start_pos;
										}
										elsif ($assembly_end_pos_start ne "" && $assembly_end_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$assembly_end_pos = substr $blast_result_tmp2[1], 13;
											$assembly_end_pos{$count_multimatch} = $assembly_end_pos;
										}
										elsif ($read_start_pos_start ne "" && $read_start_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$long_read_start_pos = substr $blast_result_tmp2[1], 13;
											$long_read_start_pos{$count_multimatch} = $long_read_start_pos;     
										}
										elsif ($read_end_pos_start ne "" && $read_end_pos_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$long_read_end_pos = substr $blast_result_tmp2[1], 11;
											$long_read_end_pos{$count_multimatch} = $long_read_end_pos;
										}
										elsif ($pos_matches_start ne "" && $pos_matches_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											my $pos_matches_tmp = substr $blast_result_tmp2[1], 13;
											$pos_matches += $pos_matches_tmp;
										}
										elsif ($alignment_length2_start ne "" && $alignment_length2_start eq $j)
										{   
											my @blast_result_tmp2 = split /</, $line2;
											my $alignment_length2_tmp = substr $blast_result_tmp2[1], 14;
											$alignment_length2 += $alignment_length2_tmp;
											
											#if ($multiple_matches eq "" && $alignment_length2_tmp < 0.3*$length_tmp && $alignment_length2_tmp < 0.3*length($ref_part))
											#{
												#$almost_no_hit_rejection++;
												#$skip_id = "yes";
												#close INPUT_BLAST;
												#goto SKIP_BLAST1_NP;
											#}
											
											if ($accuracy eq "")
											{
												$accuracy = $pos_matches/$alignment_length2;
											}
											else
											{
												my $accuracy_tmp = $pos_matches/$alignment_length2;
												my $accuracy_tmp2 = $accuracy;
												$accuracy = ($accuracy_tmp+$accuracy_tmp2)/2   
											}
											
											if ($accuracy < 0.7)
											{
												#print {$filehandle{$seed_id2}} $accuracy." ACCURACY_REJECTION\n";
												$accuracy_rejection++;
												$skip_id = "accuracy_rejection";
												goto SKIP_BLAST1_NP;
											}    
										}
										elsif ($query_start ne "" && $query_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$query = substr $blast_result_tmp2[1], 9;
											$query{$count_multimatch} = $query;
											#print {$filehandle{$seed_id2}} $query." QUERY\n";    
										}
										elsif ($subject_start ne "" && $subject_start eq $j)
										{
											my @blast_result_tmp2 = split /</, $line2;
											$subject = substr $blast_result_tmp2[1], 9;
											$subject{$count_multimatch} = $subject;
											#print {$filehandle{$seed_id2}} $subject." SUBJECT\n";
										}
										elsif ($mismatch_start ne "" && $mismatch_start eq $j && $find_haps_in_seed eq "")
										{
											my @blast_result_tmp2 = split /</, $line2;
											$mismatch = substr $blast_result_tmp2[1], 12;
											$mismatch{$count_multimatch} = $mismatch;
											#print {$filehandle{$seed_id2}} $mismatch." MISMATCH\n";
										}
										elsif ($mismatch_start ne "" && $j eq $mismatch_start+2)
										{
											@blast_result_tmp = split /\s+/, $line2;
											my $multi_match_length_check = $assembly_end_pos-$assembly_start_pos;
											
											if (($blast_result_tmp[1] ne "<Hsp>" || (($long_read_start_pos <= 150 || $assembly_start_pos < 150) && $assembly_end_pos >= $ref_part{$id_tmp3}-200
												&& $long_read_end_pos <= $length_long_read_tmp-200)) && ($multiple_matches eq "" || ($multi_match_length_check > 1000 && $assembly_end_pos > $ref_part{$id_tmp3}-$ref_end_rejection_threshold && $long_read_end_pos > 400
												&& (($long_read_start_pos <= 150 || $assembly_start_pos < 150) && $assembly_end_pos >= $ref_part{$id_tmp3}-200 && $long_read_end_pos <= $length_long_read_tmp-200))))
											{                                                                            
												if ($assembly_end_pos < $ref_part{$id_tmp3}-$ref_end_rejection_threshold)
												{
													#print {$filehandle{$seed_id2}} $assembly_end_pos." REF_END_REJECTION\n";                                     
													$ref_end_rejection++;
													delete $save_alignment_data_NP{$seed_id}{$id_tmp3};
													$skip_id = "ref_end_rejection";
													goto SKIP_BLAST1_NP;
												}                                
												elsif ($long_read_end_pos < 400)
												{
													$match_too_short++;
													$skip_id = "match_too_short";
													goto SKIP_BLAST1_NP;
												}
												elsif ($long_read_start_pos > 220 && $assembly_start_pos > 150)
												{
													#print {$filehandle{$seed_id2}} $assembly_start_pos." REF ".$long_read_start_pos." READ_START_POS_REJECTION\n";
													$read_start_pos_rejection++; 
													my $alignment_length_tmp = $assembly_end_pos - $assembly_start_pos + 1; 
													$read_start_pos_rej{$id_tmp3} = $alignment_length_tmp;
													$long_read_end_pos_save{$id_tmp3} = $long_read_end_pos;
													$accuracy{$id_tmp3} = $accuracy;
													$skip_id = "read_start_pos_rejection";
													if ($add_rejected_reads eq "" && $add_rejected_and_no_match_reads eq "")
													{
														goto SKIP_BLAST1_NP;
													}
												}
												elsif ($long_read_end_pos > $length_long_read_tmp-350)
												{
													#print {$filehandle{$seed_id2}} $long_read_end_pos." EXT_TOO_SHORT\n";
													$ext_too_short++;
													$skip_id = "ext_too_short";
													delete $save_alignment_data_NP{$seed_id}{$id_tmp3};
													goto SKIP_BLAST1_NP;
												}
												elsif (exists($alignment_length_save{$id_tmp3}) && $assembly_end_pos - $assembly_start_pos + 1 < $alignment_length_save{$id_tmp3} && (exists($extensions2{$id_tmp3}) || exists($extensions_unknown2{$id_tmp3})))
												{
													print {$filehandle{$seed_id2}} $id_tmp3." ".$assembly_end_pos - $assembly_start_pos." REMOVE_DUPLICATE2\n";
													$skip_id = "remove_duplicate";
													goto SKIP_BLAST1_NP;
												}
												elsif (exists($alignment_length_save{$id_tmp3}))
												{					
													print {$filehandle{$seed_id2}} $id_tmp3." ".$assembly_end_pos - $assembly_start_pos." REMOVE_DUPLICATE1\n";
													foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions{$id}})
													{
														delete $SNP_matches{$prev_splits}{$id_tmp3};
														delete $SNP_no_matches{$prev_splits}{$id_tmp3};
													}
													foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions_DUP{$id}})
													{
														delete $SNP_matches{$prev_splits}{$id_tmp3};
														delete $SNP_no_matches{$prev_splits}{$id_tmp3};
													}
													delete $store_mismatches_NP{$id_tmp3};
													delete $store_mismatches_all_NP{$id_tmp3};
													$double_match_reject{$id_tmp3} = undef;
													$count_matches_with_high_scores--;
													delete $extensions2{$id_tmp3};
													delete $extensions2b{$id_tmp3};				
													delete $var_matches{$id_tmp3};
													delete $var_matches_DUP{$id_tmp3};
													delete $extensions_nomatch2{$id_tmp3};
													delete $extensions_nomatch2b{$id_tmp3};
													delete $extensions_unknown2{$id_tmp3};
													delete $exclude_reads_NP{$id}{$id_tmp3};
												}
												
												$alignment_length = $assembly_end_pos - $assembly_start_pos + 1;                                  
												$alignment_length_save{$id_tmp3} = $alignment_length;
												$alignment_length_save2{$alignment_length}{$id_tmp3} = undef;
												$match_confirmed = "yes";
											}
#Verify multiple matches--------------------------------------------------------------------------                          
											elsif ($multiple_matches ne "")
											{                                                      
												my $last_multi_match = "";
												if ($multi_match_length_check < 400 && $multi_match_length_check > -400)
												{
													delete $assembly_start_pos{$count_multimatch};
													delete $assembly_end_pos{$count_multimatch};
													delete $long_read_start_pos{$count_multimatch};
													delete $long_read_end_pos{$count_multimatch};
													delete $mismatch{$count_multimatch};
													$last_multi_match = "yes";
												}
												
												my $end_pos_check = "";
												my $start_pos_check = "";
												my $rejection_tmp = "";
												my %end_pos_check;
												undef %end_pos_check;
												my %start_pos_check;
												undef %start_pos_check;

												foreach my $count_tmp (keys %assembly_end_pos)
												{
													if ($assembly_end_pos{$count_tmp} > $ref_part{$id_tmp3}-$ref_end_rejection_threshold && $long_read_end_pos{$count_tmp} > 400)
													{
														$end_pos_check = "yes";
														$end_pos_check{$count_tmp} = undef;
													}
												}
												if ($end_pos_check eq "yes")
												{
													foreach my $count_tmp (keys %assembly_start_pos)
													{
														if ($assembly_start_pos{$count_tmp} < 220 || $long_read_start_pos{$count_tmp} < 120)
														{
															$start_pos_check = "yes";
															$start_pos_check{$count_tmp} = undef;
														}
													}
													if ($start_pos_check ne "yes")
													{
														$rejection_tmp = "read_start";
													}
												}
												else
												{
													$rejection_tmp = "ref_end";
												}
												
												my $match_found_tmp = "";
												
												if ($rejection_tmp eq "")
												{
													my @alignment_order_assembly;                                    
													
ALIGNMENT_ORDER_NP0:                                foreach my $count_tmp (keys %start_pos_check)
													{
														undef @alignment_order_assembly;
														push @alignment_order_assembly, $count_tmp;
ALIGNMENT_ORDER_NP:                                           
														foreach my $count_tmp2 (keys %assembly_start_pos)
														{
															if ($assembly_start_pos{$count_tmp2} > $assembly_end_pos{$count_tmp}-$multi_gap && $assembly_start_pos{$count_tmp2} < $assembly_end_pos{$count_tmp}+$multi_gap
																&& $long_read_start_pos{$count_tmp2} > $long_read_end_pos{$count_tmp}-$multi_gap && $long_read_start_pos{$count_tmp2} < $long_read_end_pos{$count_tmp}+$multi_gap)
															{
																my $assembly_end_pos_tmp2 = $ref_part{$id_tmp3} - $assembly_end_pos{$count_tmp};
																while (exists($multi_match_pos{$assembly_end_pos_tmp2}))
																{
																	$assembly_end_pos_tmp2++;
																}
																$multi_match_pos_tmp{$assembly_end_pos_tmp2} = $id_tmp3;
																
																push @alignment_order_assembly, $count_tmp2;
																if (exists($end_pos_check{$count_tmp2}))
																{
																	$match_found_tmp = "yes";
																	$long_read_end_pos_high = $count_tmp2;
																	$assembly_end_pos_high = $count_tmp2;
																	$assembly_start_pos_low = $alignment_order_assembly[0];																
																	last ALIGNMENT_ORDER_NP0;
																}
																else
																{
																	$count_tmp = $count_tmp2;
																	goto ALIGNMENT_ORDER_NP;
																}
															}
														}
													}
												}
			  
												if (($blast_result_tmp[1] ne "<Hsp>" || $count_multimatch >= 30 || $last_multi_match ne "") && $match_found_tmp eq "")
												{
													if ($end_pos_check eq "yes")
													{
														my $end_pos_rej_tmp = "";
														my $start_pos_rej_tmp = "";
														my $read_end_pos_rej_tmp = "";
														my $count_contigs = '0';
														foreach my $count_tmp (keys %end_pos_check)
														{
															my $lowest_count_tmp = $count_tmp;
															my $count_contigs_tmp = '1';
CHECK_MULTI_MATCH_REJ:																		
															foreach my $count_tmp2 (keys %assembly_start_pos)
															{
																if ($count_tmp2 ne $lowest_count_tmp && $assembly_end_pos{$count_tmp2} > $assembly_start_pos{$lowest_count_tmp}-$multi_gap && $assembly_end_pos{$count_tmp2} < $assembly_start_pos{$lowest_count_tmp}+$multi_gap
																	&& $long_read_end_pos{$count_tmp2} > $long_read_start_pos{$lowest_count_tmp}-$multi_gap && $long_read_end_pos{$count_tmp2} < $long_read_start_pos{$lowest_count_tmp}+$multi_gap
																	&& $assembly_start_pos{$count_tmp2} < $assembly_start_pos{$lowest_count_tmp})
																{
																	$lowest_count_tmp = $count_tmp2;
																	$count_contigs_tmp++;
																	goto CHECK_MULTI_MATCH_REJ;
																}
															}
															if ($end_pos_rej_tmp eq "" || (($assembly_end_pos{$count_tmp}-$assembly_start_pos{$lowest_count_tmp}) > ($end_pos_rej_tmp-$start_pos_rej_tmp)))
															{
																$end_pos_rej_tmp = $assembly_end_pos{$count_tmp};
																$start_pos_rej_tmp = $assembly_start_pos{$lowest_count_tmp};
																$read_end_pos_rej_tmp = $long_read_end_pos{$count_tmp};
																$count_contigs = $count_contigs_tmp;
															}
														}
														
														if ($end_pos_rej_tmp ne "" && $start_pos_rej_tmp ne "")
														{
															$assembly_end_pos = $end_pos_rej_tmp;
															$assembly_start_pos = $start_pos_rej_tmp;
															my $alignment_length_tmp = $assembly_end_pos - $assembly_start_pos + 1;
															$read_start_pos_rej{$id_tmp3} = $alignment_length_tmp;
															$accuracy{$id_tmp3} = $accuracy;
															$long_read_end_pos_save{$id_tmp3} = $read_end_pos_rej_tmp;
	
															if ($count_contigs eq '1')
															{
																$read_start_pos_rejection++;
																$skip_id = "read_start_pos_rejection";
															}
															else
															{
																$skip_id = "multi_match_rejection";
																$multi_match_rejection++;
																if ($count_multimatch >= 30)
																{
																	print {$filehandle{$seed_id2}} $id_tmp3." ".$assembly_end_pos." ".$assembly_start_pos." ASS_END_POS_REJ2\n";
																}
															}
															if ($add_rejected_reads eq "" && $add_rejected_and_no_match_reads eq "")
															{
																goto SKIP_BLAST1_NP;
															}
														}
													}
													else
													{
														$skip_id = "ref_end_rejection";
														delete $save_alignment_data_NP{$seed_id}{$id_tmp3};
														$ref_end_rejection++;
													}
													goto SKIP_BLAST1_NP;
												}
												elsif ($blast_result_tmp[1] eq "<Hsp>" && $count_multimatch < 30 && $match_found_tmp eq "")
												{
													$j++;
													$bit_score_start = $j+1;
													$assembly_start_pos_start = $j+4;
													$assembly_end_pos_start = $j+5;
													$read_start_pos_start = $j+6;
													$read_end_pos_start = $j+7;
													$pos_matches_start = $j+11;
													$alignment_length2_start = $j+13;
													$query_start = $j+14;
													$subject_start = $j+15;
													$mismatch_start = $j+16;
													$multiple_matches = "yes";
													$count_multimatch++;
													next INPUT_BLAST_NP;
												}
												elsif ($match_found_tmp ne "")
												{
													if ($long_read_end_pos{$assembly_end_pos_high} > $length_long_read_tmp-350)
													{
														$ext_too_short++;
														delete $save_alignment_data_NP{$seed_id}{$id_tmp3};
														$skip_id = "ext_too_short";
														goto SKIP_BLAST1_NP;
													}
													elsif ($long_read_end_pos{$assembly_end_pos_high} < 500)
													{
														$match_too_short++;
														$skip_id = "match_too_short";
														goto SKIP_BLAST1_NP;
													}     
													
													foreach my $count_tmp3 (keys %mismatch)
													{
														if ($assembly_start_pos{$count_tmp3} < $assembly_start_pos{$assembly_start_pos_low}-100)
														{
															delete $mismatch{$count_tmp3};
														}
													}
																	
													$alignment_length = $assembly_end_pos{$assembly_end_pos_high} - $assembly_start_pos{$assembly_start_pos_low};
													$long_read_end_pos = $long_read_end_pos{$assembly_end_pos_high};
													print {$filehandle{$seed_id2}} "\n".$id_tmp3." MULTI_MATCH\n";
													$alignment_length_save{$id_tmp3} = $alignment_length;
													$alignment_length_save2{$alignment_length}{$id_tmp3} = undef;
													foreach my $multi_match_pos_tmp (keys %multi_match_pos_tmp)
													{
														$multi_match_pos{$multi_match_pos_tmp} = $multi_match_pos_tmp{$multi_match_pos_tmp};
														$multi_match{$id_tmp3}{$multi_match_pos_tmp} = undef;
													}
													$match_confirmed = "yes";
												}
												else
												{
													print {$filehandle{$seed_id2}} "\n".$id_tmp3." MULTI_MATCH_CHECK\n";
												}
											}
											elsif ($allow_multi_match eq "yes")
											{
												#print {$filehandle{$seed_id2}} "\n".$id_tmp3." MULTIPLE_MATCHES\n";
												$j++;
												$bit_score_start = $j+1;
												$assembly_start_pos_start = $j+4;
												$assembly_end_pos_start = $j+5;
												$read_start_pos_start = $j+6;
												$read_end_pos_start = $j+7;
												$pos_matches_start = $j+11;
												$alignment_length2_start = $j+13;
												$query_start = $j+14;
												$subject_start = $j+15;
												$mismatch_start = $j+16;
												$multiple_matches = "yes";
												$count_multimatch++;
												next INPUT_BLAST_NP;
											}
											else
											{
												$multi_match_rejection++;
												$skip_id = "multi_match_rejection";
												print {$filehandle{$seed_id2}} $assembly_end_pos." ".$ref_part{$id_tmp3}." ASS_END_POS_REJ\n";
												print {$filehandle{$seed_id2}} $assembly_end_pos." ".$assembly_start_pos." ASS_END_POS_REJ2\n";
												if ($assembly_end_pos > $ref_part{$id_tmp3}-$ref_end_rejection_threshold)
												{
													my $alignment_length_tmp = $assembly_end_pos - $assembly_start_pos + 1;
													$read_start_pos_rej{$id_tmp3} = $alignment_length_tmp;
													$accuracy{$id_tmp3} = $accuracy;
													$long_read_end_pos_save{$id_tmp3} = $long_read_end_pos;
												}
												goto SKIP_BLAST1_NP;
											}
											
											if ($alignment_length < 550 && length($read) > 600)
											{
												#print {$filehandle{$seed_id2}} $alignment_length." OVERLAP_TOO_SHORT\n";
												$overlap_too_short++;
												$skip_id = "overlap_too_short";           
												goto SKIP_BLAST1_NP;
											}
											if ($add_rejected_reads eq "" && $add_rejected_and_no_match_reads eq "")
											{
												$count_matches_with_high_scores++;
											}
											$long_read_end_pos_save{$id_tmp3} = $long_read_end_pos;
											
											my $pos_tmp = $assembly_start_pos-50;
											if ($pos_tmp < 0)
											{
												$pos_tmp = '0';
											}
											#my $ref_part_tmp = substr $ref_part, $pos_tmp;
											
											my $long_read_tmp = "";
			
											if (exists($reverse_list{$id_tmp3}) && $double_match_tmp eq "")
											{
												$long_read_tmp = reverse($hash_NP_reads_tmp{$id_tmp3});
												$long_read_tmp =~ tr/ACTG/TGAC/;
											}
											else
											{
												$long_read_tmp = $hash_NP_reads_tmp{$id_tmp3};
											}
											$check_prev_splits{$id_tmp3} = $long_read_tmp;
											
											$accuracy{$id_tmp3} = $accuracy;
								  
											my $track_length = '-1';
											
											if ($find_haps_in_seed eq "")
											{
												foreach my $id_split (keys %split_positions)
												{
													if ($id_split eq $id)
													{
SPLIT_NP:                                   		   	foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions{$id_split}})
														{
															if ($last_hap_pos eq "")
															{
																$last_hap_pos = $position - $prev_splits;
															}
															$track_length = '-1';
			
															if ($alignment_length > $position - $prev_splits)
															{
																foreach my $count_mismatch_tmp (keys %mismatch)
																{ 
																	if ($ref_part{$id_tmp3}-$assembly_end_pos{$count_mismatch_tmp} < ($position - $prev_splits) &&
																		($ref_part{$id_tmp3}-$assembly_start_pos{$count_mismatch_tmp}) > ($position - $prev_splits))
																	{
																		$largest_prev_split = $ref_part{$id_tmp3}-$assembly_start_pos{$count_mismatch_tmp} - ($position - $prev_splits)+1; 
																		$largest_prev_split_ext = $split_positions{$id_split}{$prev_splits};
			
																		my $b = '0';
																		my $last12 = "";
																		my $last12_match = "";
																
																		while ($b < length($query{$count_mismatch_tmp}))
																		{
																			my $nuc_query = substr $query{$count_mismatch_tmp}, $b, 1;
																			if ($nuc_query ne "-")
																			{
																				$track_length += 1;
																				if ($track_length > $largest_prev_split-15 && $track_length < $largest_prev_split+5)
																				{
																					$last12 .= $nuc_query;
																					if (length($last12) > 12)
																					{
																						substr $last12, 0, 1, "";
																					}
																					if (length($last12) > 11)
																					{
																						my @largest_prev_split_ext = split /,/, $largest_prev_split_ext;
																						
																						if ($last12 eq $largest_prev_split_ext[0])
																						{
																							$last12_match = "yes";
																							$b++;
																							next;
																						}
																						if ($last12_match eq "yes")
																						{
																							$last12_match = "";
																							my $nuc_subject = substr $subject{$count_mismatch_tmp}, $b, 1;
																							my $nuc_mismatch_prev = substr $mismatch{$count_mismatch_tmp}, $b-1, 1;
																							my $nuc_mismatch_post = substr $mismatch{$count_mismatch_tmp}, $b+1, 1;
			
																							if ($nuc_query ne $largest_prev_split_ext[1])
																							{
																								print {$filehandle{$seed_id2}} $prev_splits." SPLIT_POS\n";
																				print {$filehandle{$seed_id2}} $largest_prev_split." SPLIT_POS2\n";
																				print {$filehandle{$seed_id2}} $largest_prev_split_ext." SPLIT_POS_ECT\n";
																				print {$filehandle{$seed_id2}} $assembly_start_pos{$count_mismatch_tmp}." START_POS\n";
																				print {$filehandle{$seed_id2}} $ref_part{$id_tmp3}." REF_PART\n";
																				#print {$filehandle{$seed_id2}} $query{$count_mismatch_tmp}." QUERY\n";
																								print {$filehandle{$seed_id2}} $nuc_query." NUC_QUERY\n";
																								print {$filehandle{$seed_id2}} $nuc_subject." NUC_SUBJECT\n\n";
																								my $test_seq = substr $query{$count_mismatch_tmp}, $b-15, 30;
																								print {$filehandle{$seed_id2}} $test_seq." TEST_SEQ\n";
																							}
																							if ($nuc_mismatch_prev ne "|" && $nuc_mismatch_post ne "|")
																							{
																							}
																							elsif ($nuc_query eq $nuc_subject)
																							{
																								$score_match++;
																								$SNP_matches{$prev_splits}{$id_tmp3} = undef;
																							}
																							elsif ($nuc_subject ne "-" && $nuc_query ne "N"
																							      && ($add_rejected_reads_low_longest eq "" || $add_rejected_reads_low_longest > $position - $prev_splits))
																							{
																								$score_no_match++;
																								$SNP_no_matches{$prev_splits}{$id_tmp3} = undef;
																							}
																							next SPLIT_NP;
																						}
																					}
																				}
																			}
																			$b++;
																		}
																	}
																}
															}
														}
													}
												}
												
#Store mismatches of the aligned reads to split reads---------------------------------------------------------------------                              
												foreach my $count_mismatch_tmp (keys %mismatch)
												{
													if ($multiple_matches eq "yessss")
													{
									print {$filehandle{$seed_id2}} $id_tmp3." ".$ref_part{$id_tmp3}." ".$position." ".$assembly_start_pos{$count_mismatch_tmp}." ".$assembly_end_pos{$count_mismatch_tmp}." COUNT_MISMATCH\n";
									print {$filehandle{$seed_id2}} $query{$count_mismatch_tmp}." QUERY\n";
									print {$filehandle{$seed_id2}} $subject{$count_mismatch_tmp}." SUBJECT\n";
									print {$filehandle{$seed_id2}} $mismatch{$count_mismatch_tmp}." MISMATCH\n";
													}
													$track_length = '-1';
													my $track_query = $ref_part{$id_tmp3}-$assembly_start_pos{$count_mismatch_tmp}+1;
													my $track_query_full = $assembly_start_pos{$count_mismatch_tmp}+$position-$ref_part{$id_tmp3};
													my @blast_result_tmp3 = split /\s+/, $mismatch{$count_mismatch_tmp};
													
													foreach my $blast_tmp (@blast_result_tmp3)
													{
														$track_length += length($blast_tmp);
														$track_query -= length($blast_tmp);
														$track_query_full += length($blast_tmp);
						if ($multiple_matches eq "yesss")
													{
														print {$filehandle{$seed_id2}} $blast_tmp." BLAST_TMP ".$track_length." TRACK_LENGTH\n";
													}
														my $track_length_adjust = '0';
														my $nuc_query = substr $query{$count_mismatch_tmp}, $track_length+1, 1;
														my $nuc_query_prev = substr $query{$count_mismatch_tmp}, $track_length, 1;
														my $nuc_query_post = substr $query{$count_mismatch_tmp}, $track_length+2, 1;
														my $nuc_subject = substr $subject{$count_mismatch_tmp}, $track_length+1, 1;
														my $nuc_subject_prev = substr $subject{$count_mismatch_tmp}, $track_length, 1;
														my $nuc_subject_post = substr $subject{$count_mismatch_tmp}, $track_length+2, 1;
														while ($nuc_query ne $nuc_subject)
														{
															$track_length_adjust++;                                       
															if ($track_length < length($query{$count_mismatch_tmp})-1)
															{
																my $one = $track_query_full-1;
																my $two = $track_query_full+1;
																if (exists($quality_scores{$seed_id}{$track_query_full}))
																{
																	my @q_score_tmp = split / /, $quality_scores{$seed_id}{$track_query_full}; 
																	if ($q_score_tmp[0] < 0.85)
																	{
																		goto SKIP_STORE_MISMATCH_NP;
																	}												
																	my @q_score_gap_tmp = split / /, $quality_scores_gap{$seed_id}{$track_query_full}; 
																	if (exists($quality_scores_gap{$seed_id}{$track_query_full}) && $q_score_gap_tmp[0] < 0.7)
																	{
																		goto SKIP_STORE_MISMATCH_NP;
																	}
																	my @q_score_gap1_tmp = split / /, $quality_scores_gap{$seed_id}{$one}; 
																	if (exists($quality_scores_gap{$seed_id}{$one}) && $q_score_gap1_tmp[0] < 0.7)
																	{
																		goto SKIP_STORE_MISMATCH_NP;
																	}
																	my @q_score_gap2_tmp = split / /, $quality_scores_gap{$seed_id}{$two}; 
																	if (exists($quality_scores_gap{$seed_id}{$two}) && $q_score_gap2_tmp[0] < 0.7)
																	{
																		goto SKIP_STORE_MISMATCH_NP;
																	}
																}
																elsif ($PB_reads eq "" && $input_reads_DB_folder_PB eq "")
																{
																	if ($track_query_full > $original_seed_length{$id} && $assembly_length_max ne "WG")
																	{
																	print {$filehandle{$seed_id2}} $track_query_full." QS!!!\n";
																	}
																	goto SKIP_STORE_MISMATCH_NP;
																}
																if ($nuc_query eq "a")
																{
																	print {$filehandle{$seed_id2}} $nuc_query." CAP_ERROR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
																}
																if ($nuc_query ne "-" && $nuc_subject ne "-" && $nuc_query ne "N" && $nuc_query_prev ne "N" && $nuc_query_post ne "N"
																	&& $nuc_query_prev ne "-" && $nuc_query_post ne "-" && $nuc_subject_prev ne "-" && $nuc_subject_post ne "-")
																{
																	my $track_length_tmp = $track_length+$track_length_adjust;
																	my $seq_tmp = substr $read, -$track_query-30, 31;
																	
										if ($multiple_matches eq "yessssss")
													{
																	#print {$filehandle{$seed_id2}} $id_tmp3." ID\n";
																	print {$filehandle{$seed_id2}} $quality_scores{$seed_id}{$track_query_full}." QS\n";
																		print {$filehandle{$seed_id2}} $nuc_query." NQ\n";
														print {$filehandle{$seed_id2}} $nuc_subject." NS\n";
																		print {$filehandle{$seed_id2}} $track_query_full." TRACK_QUERY\n";
																		my $nuc_query_seq = substr $query{$count_mismatch_tmp}, $track_length_tmp-30, 31;
																		my $nuc_read_seq = substr $read, $track_query_full-31, 31;
																		print {$filehandle{$seed_id2}} $nuc_query_seq." SEQ1\n";
																	   print {$filehandle{$seed_id2}} $seq_tmp." SEQ2\n";
																	   print {$filehandle{$seed_id2}} $nuc_read_seq." READ_SEQ\n";
													}
													
																	$store_mismatches_NP{$id_tmp3}{$track_query_full} = $nuc_query.",".$nuc_subject.",".$seq_tmp;
																}																
SKIP_STORE_MISMATCH_NP:                                                    
																my $track_length_tmp = $track_length+$track_length_adjust;
																my $seq_tmp = substr $read, -$track_query-30, 31;
																if ($nuc_query ne "N")
																{
																	$store_mismatches_all_NP{$id_tmp3}{$track_query_full} = $nuc_query.",".$nuc_subject.",".$seq_tmp;
																}
																if ($nuc_query eq "N")
																{
																	$store_mismatches_N_NP{$id_tmp3}{$track_query_full} = $nuc_query.",".$nuc_subject.",".$seq_tmp;
																}
																if ($multiple_matches eq "yessssss")
													{
																print {$filehandle{$seed_id2}} $track_query_full." TRACK_QUERY_FULL\n";
													}
																#print {$filehandle{$seed_id2}} $track_length_adjust." TRACK_LENGTH_ADJUST\n";
																#print {$filehandle{$seed_id2}} $nuc_query." NUC_QUERY\n";
																#print {$filehandle{$seed_id2}} $nuc_subject." NUC_SUBJECT\n";
																
																if ($nuc_query ne "-")
																{
																	$track_query--;
																	$track_query_full++;
																}													
															}
															
															$nuc_query = substr $query{$count_mismatch_tmp}, $track_length+$track_length_adjust+1, 1;
															$nuc_subject = substr $subject{$count_mismatch_tmp}, $track_length+$track_length_adjust+1, 1;
														}                                                    
														$track_length += $track_length_adjust;  
													}
												}
												
#Check split positions derived from duplicated regions--------------------------------------------------------------------------------------------------------------------------
												foreach my $id_split (keys %split_positions_DUP)
												{
													if ($id_split eq $id)
													{
SPLIT_NP_DUP:                               	        foreach my $prev_splits (sort {$a <=> $b} keys %{$split_positions_DUP{$id_split}})
														{
															if ($last_hap_pos_DUP eq "")
															{
																$last_hap_pos_DUP = $position - $prev_splits;
															}
															$track_length = '-1';
															
															if ($y < 3)
															{
																print {$filehandle{$seed_id2}} $prev_splits." PREV_SPLIT_TEST\n";
															}
			
															if ($alignment_length > $position - $prev_splits)
															{
																foreach my $count_mismatch_tmp (keys %mismatch)
																{ 
																	if ($ref_part{$id_tmp3}-$assembly_end_pos{$count_mismatch_tmp} < ($position - $prev_splits) &&
																		($ref_part{$id_tmp3}-$assembly_start_pos{$count_mismatch_tmp}) > ($position - $prev_splits))
																	{
																		$largest_prev_split = $ref_part{$id_tmp3}-$assembly_start_pos{$count_mismatch_tmp} - ($position - $prev_splits)+1; 
																		my $read_end_tmp = $split_positions_DUP{$id_split}{$prev_splits};
																		my $nuc_DUP_tmp = $split_positions_DUP2{$id_split}{$prev_splits};
			
																		my $b = '0';
																		my $last12 = "";
																		my $last12_match = "";
																
																		while ($b < length($query{$count_mismatch_tmp}))
																		{
																			my $nuc_query = substr $query{$count_mismatch_tmp}, $b, 1;
																			if ($nuc_query ne "-")
																			{
																				$track_length += 1;
																				if ($track_length > $largest_prev_split-15 && $track_length < $largest_prev_split+5)
																				{
																					$last12 .= $nuc_query;
																					if (length($last12) > 12)
																					{
																						substr $last12, 0, 1, "";
																					}
																					if (length($last12) > 11)
																					{
																						if ($y < 3)
																						{
																							print {$filehandle{$seed_id2}} $last12." ".$read_end_tmp." LAST12_TEST\n";
																						}
																						
																						if ($last12 eq $read_end_tmp)
																						{
																							$last12_match = "yes";
																							$b++;
																							next;
																						}
																						
																						if ($last12_match eq "yes")
																						{
																							$last12_match = "";
																							my $nuc_subject = substr $subject{$count_mismatch_tmp}, $b, 1;
																							my $nuc_mismatch_prev = substr $mismatch{$count_mismatch_tmp}, $b-1, 1;
																							my $nuc_mismatch_post = substr $mismatch{$count_mismatch_tmp}, $b+1, 1;
			
																							if ($nuc_query ne $nuc_DUP_tmp && $nuc_query ne $nuc_subject && $nuc_subject ne "-")
																							{
																								if ($nuc_query eq "N")
																								{
																									delete $split_positions_DUP{$id_split}{$prev_splits};
																									delete $split_positions_DUP2{$id_split}{$prev_splits};
																								}
																								print {$filehandle{$seed_id2}} $prev_splits." SPLIT_POS_DUP\n";
																				print {$filehandle{$seed_id2}} $largest_prev_split." SPLIT_POS2_DUP\n";
																				print {$filehandle{$seed_id2}} $assembly_start_pos{$count_mismatch_tmp}." START_POS_DUP\n";
																				print {$filehandle{$seed_id2}} $ref_part{$id_tmp3}." REF_PART_DUP\n";
																				#print {$filehandle{$seed_id2}} $query{$count_mismatch_tmp}." QUERY_DUP\n";
																								print {$filehandle{$seed_id2}} $nuc_query." NUC_QUERY_DUP\n";
																								print {$filehandle{$seed_id2}} $nuc_subject." NUC_SUBJECT_DUP\n";
																								print {$filehandle{$seed_id2}} $read_end_tmp." ".$nuc_DUP_tmp." NUC_DUP\n";
																								my $test_seq = substr $query{$count_mismatch_tmp}, $b-15, 30;
																								print {$filehandle{$seed_id2}} $test_seq." TEST_QUERY_DUP\n";
																								my $test_seq1 = substr $subject{$count_mismatch_tmp}, $b-15, 30;
																								print {$filehandle{$seed_id2}} $test_seq1." TEST_SUB_DUP2\n\n";
																							}
																							if ($nuc_mismatch_prev ne "|" && $nuc_mismatch_post ne "|")
																							{
																								if ($nuc_mismatch_prev eq "ffege")
																								{
																								print {$filehandle{$seed_id2}} $largest_prev_split_ext." SPLIT_POS_ECT_DUP\n";
																								my $test_seq = substr $query{$count_mismatch_tmp}, $b-15, 30;
																								print {$filehandle{$seed_id2}} $test_seq." TEST_SEQ_DUP\n";
																								my $test_seq1 = substr $subject{$count_mismatch_tmp}, $b-15, 30;
																								print {$filehandle{$seed_id2}} $test_seq1." TEST_SUB_DUP\n";
																								my $test_seq2 = substr $mismatch{$count_mismatch_tmp}, $b-15, 30;
																								print {$filehandle{$seed_id2}} $test_seq2." TEST_MISMATCH_DUP\n";
																								}
																								if (exists($split_positions_VIP{$id_split}{$prev_splits}))
																								{
																									$maybe_match_VIP++;
																								}
																							}
																							elsif ($nuc_query eq $nuc_subject)
																							{
																								$score_match_DUP++;
																								$SNP_matches{$prev_splits}{$id_tmp3} = undef;
																								if (exists($split_positions_VIP{$id_split}{$prev_splits}))
																								{
																									$score_match_VIP++;
																								}
																								$no_match_region = '0';
																							}
																							elsif ($nuc_subject ne "-" && $nuc_query ne "N"
																								   && ($add_rejected_reads_low_longest eq "" || $add_rejected_reads_low_longest > $position - $prev_splits))
																							{
																								$score_no_match_DUP++;
																								$no_match_region++;
																								if ($no_match_region > $no_match_region_high)
																								{
																									$no_match_region_high = $no_match_region;
																								}
																								$SNP_no_matches{$prev_splits}{$id_tmp3} = undef;
																								if (exists($split_positions_VIP{$id_split}{$prev_splits}))
																								{
																									$score_no_match_VIP++;
																								}
																							}
																							else
																							{
																								print {$filehandle{$seed_id2}} $id_split." ".$prev_splits." DUP_POS_missing2\n";
																								#print {$filehandle{$seed_id2}} $read_end_tmp." SPLIT_POS_ECT_DUP2\n";
																								#my $test_seq = substr $query{$count_mismatch_tmp}, $b-15, 30;
																								#print {$filehandle{$seed_id2}} $test_seq." TEST_SEQ_DUP2\n";
																								#my $test_seq1 = substr $subject{$count_mismatch_tmp}, $b-15, 30;
																								#print {$filehandle{$seed_id2}} $test_seq1." TEST_SUB_DUP2\n";
																								#my $test_seq2 = substr $mismatch{$count_mismatch_tmp}, $b-15, 30;
																								#print {$filehandle{$seed_id2}} $test_seq2." TEST_MISMATCH_DUP2\n";
																								if (exists($split_positions_VIP{$id_split}{$prev_splits}))
																								{
																									$maybe_match_VIP++;
																								}
																							}
																							next SPLIT_NP_DUP;
																						}
																					}
																				}
																			}
																			$b++;
																		}
																	}
																}
															}
														}
													}
												}
											}
											if ($match_confirmed eq "yes")
											{
												goto SKIP_BLAST1_NP;
											}
										}
										elsif ($blast_result_tmp[1] eq "<Hsp>")
										{ 
											$j++;
											$bit_score_start = $j+1;
											$assembly_start_pos_start = $j+4;
											$assembly_end_pos_start = $j+5;
											$read_start_pos_start = $j+6;
											$read_end_pos_start = $j+7;
											$pos_matches_start = $j+11;
											$alignment_length2_start = $j+13;
											$query_start = $j+14;
											$subject_start = $j+15;
											$mismatch_start = $j+16;
											next INPUT_BLAST_NP;
										}
										else
										{
											$j++;
											next INPUT_BLAST_NP;
										}
									}
									$j++
								}
													
SKIP_BLAST1_NP:
								delete $input_files_blast{$length_tmp}{$read_file_tmp};
								if (keys %{$input_files_blast{$length_tmp}} < 1)
								{
									delete $input_files_blast{$length_tmp};
								}
								delete $input_BLAST_done{$length_tmp};
								if (exists($double_matches{$id_tmp3}) && $double_match_tmp eq "")
								{
									$double_matches_running--;
								}
								#print {$filehandle{$seed_id2}} $id_tmp3." FINISHED_IDs\n";
								#print {$filehandle{$seed_id2}} time." TIME\n";
								
								#delete $id_matches{$id_tmp3};
								#delete $id_by_length{$length_tmp};
								close INPUT_BLAST;
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
								if ($add_rejected_reads ne "" || $add_rejected_and_no_match_reads ne "")
								{
									$add_rej_reads_extra{$id_tmp3} = undef;
									delete $save_reads_for_next{$id_tmp3};
								}
#-----------------------------------------------------------------------------------------------------------------
								
								if ($skip_id ne "")
								{
									$rejected_reads_save{$id_tmp3} = undef;
									if (exists($double_match_check{$id_tmp3}))
									{
										if ($double_match_check{$id_tmp3} eq "yes")
										{
											
										}
										elsif ($double_match_check{$id_tmp3} eq "yes2")
										{
											unless (exists($double_match_reject{$id_tmp3}))
											{
												delete $read_start_pos_rej{$id_tmp3};
												delete $rejected_reads_save{$id_tmp3};
												delete $add_rej_reads_extra{$id_tmp3};
												if ($double_match_tmp eq "")
												{
													delete $reverse_list{$id_tmp3};
												}
											}										
										}
										$double_match_reject{$id_tmp3} = undef;
									}
									
#Exclude reads------------------------
									if ($skip_id eq "multi_match_rejection" || $skip_id eq "ref_end_rejection")
									{
										my $exclude_pos = $long_read_end_pos;
										if (length($read) < $long_read_end_pos)
										{
											$exclude_pos = length($read);
										}
										if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "ff")
										{
											$exclude_reads_NP{$id}{$id_tmp3} = $position+$exclude_pos;
											#print {$filehandle{$seed_id2}} $id_tmp." EXCLUDE1\n";
										}
									}
#Exclude reads------------------------        
									next BLAST1_NP;  
								}
								else
								{
									if (exists($double_match_reject{$id_tmp3}))
									{
										delete $read_start_pos_rej{$id_tmp3};
										delete $add_rej_reads_extra{$id_tmp3};
										delete $rejected_reads_save{$id_tmp3};
										delete $exclude_reads_NP{$id}{$id_tmp3};
										if ($double_match_tmp eq "yes")
										{
											delete $reverse_list{$id_tmp3};
										}
									}
									elsif ($double_match_check{$id_tmp3} eq "yes2")
									{
										print {$filehandle{$seed_id2}} $id_tmp3." DOUBLE_MATCH_ERROR\n";
									}
								}
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
								if (($add_no_match_reads ne "" || $add_rejected_and_no_match_reads ne "") && exists($extensions_nomatch2b_saved{$id_tmp3}))
								{
									$add_rej_reads_extra{$id_tmp3} = undef;
									delete $save_reads_for_next{$id_tmp3};
								}
#-----------------------------------------------------------------------------------------------------------------

							 
#Check for previous variations of the assembly in the long reads------------------------------------------------------------------------------------------                   
#---------------------------------------------------------------------------------------------------------------------------------------------------------
			
								print {$filehandle{$seed_id2}} "\n".$id_tmp3." ID\n";
								#$score_match += $score_match_saved{$id_tmp};
								#$score_no_match += $score_no_match_saved{$id_tmp};
								#$score_match_DUP += $score_match_DUP_saved{$id_tmp};
								#$score_no_match_DUP += $score_no_match_DUP_saved{$id_tmp};
								
								if ($id_tmp3 eq "101a27009a3" || $id_tmp3 eq "65a29618a3")
								{
									#print {$filehandle{$seed_id2}} $save_alignment_data_NP{$seed_id_tmp0}{$id_tmp7}." 78a3762a1_CHECKKKKK\n\n";
									print {$filehandle{$seed_id2}} $id_tmp3." READ_CHECKKKKK888\n\n";
								}
								
								if ($score_match > 0)
								{
									print {$filehandle{$seed_id2}} $score_match." EXT_MATCH\n";
								}
								if ($score_no_match > 0)
								{
									print {$filehandle{$seed_id2}} $score_no_match." EXT_NO_MATCH\n";
								}
								if ($score_match_DUP ne 0)
								{
									print {$filehandle{$seed_id2}} $score_match_DUP." EXT_MATCH_DUP\n";
								}
								if ($score_no_match_DUP ne 0)
								{
									print {$filehandle{$seed_id2}} $score_no_match_DUP." EXT_NO_MATCH_DUP\n";
								}
								if ($score_match_VIP ne 0)
								{
									print {$filehandle{$seed_id2}} $score_match_VIP." EXT_MATCH_VIP\n";
								}
								if ($score_no_match_VIP ne 0)
								{
									print {$filehandle{$seed_id2}} $score_no_match_VIP." EXT_NO_MATCH_VIP\n";
								}
								my $length_read = length($check_prev_splits{$id_tmp3});
								print {$filehandle{$seed_id2}} $alignment_length." LENGTH_MATCH\n";
								#print {$filehandle{$seed_id2}} $accuracy." ACCURACY\n";
								$score_matches_save{$id_tmp3} = $score_match."_".$score_no_match."_".$score_match_DUP."_".$score_no_match_DUP."_".$score_match_VIP."_".$score_no_match_VIP;   
			
								if (((($score_no_match > ($score_match+$score_no_match)*0.25 && ($score_no_match > 1 || $score_match_VIP eq '0')) || ($score_no_match_VIP > 0 && $score_no_match_VIP > ($score_match_VIP+$score_no_match_VIP)*0.15) ||
								   ($score_no_match_DUP > ($score_match_DUP+$score_no_match_DUP)*0.25 && ($score_no_match_DUP > 1 || ($score_match eq '0' && $score_match_VIP eq '0' && $score_match_DUP eq '0'))))
									&& (($score_no_match+$score_no_match_VIP > 1) ||($score_no_match+$score_no_match_DUP+$score_no_match_VIP) > 8 || ($score_no_match+$score_no_match_DUP+$score_no_match_VIP > ($score_match+$score_match_DUP+$score_match_VIP)*0.3)))
									|| (($no_match_region_high > 4 || ($no_match_region_high > 2 && $high_quality_ONT ne "")) && $score_no_match_DUP > ($score_match_DUP+$score_no_match_DUP)*0.04))
								{
									my $no_match_tmp = "";
									if (exists($extensions_nomatch2b_saved{$id_tmp3}))
									{
										$no_match_tmp = "yes";
									}
									if (exists($add_rej_reads_extra{$id_tmp3}) && $no_match_tmp eq "" && ($add_rejected_reads ne "" || $add_rejected_and_no_match_reads ne ""))
									{
										delete $add_rej_reads_extra{$id_tmp3};
										delete $id_matches{$id_tmp3};
										delete $save_alignment_data_NP{$seed_id}{$id_tmp3};
									}
									else
									{
										my $ext = substr $check_prev_splits{$id_tmp3}, $long_read_end_pos-90;
										$length_ext_all{$id_tmp3} = length($ext);
									print {$filehandle{$seed_id2}} length($ext)." NO_MATCH\n";	
										if (length($ext) > 200)
										{
											$extensions_nomatch{$ext} = $id_tmp3;
											$extensions_nomatch2{$id_tmp3} = $ext;
											$extensions_nomatch2b{$id_tmp3}{$ext}{$score_no_match+$score_no_match_VIP+$score_no_match_DUP} = $score_match+$score_match_VIP+$score_match_DUP;
											$extensions_nomatch2b_count++;
										}
										if ($score_no_match > $score_match && $score_no_match > 2 && $score_no_match > $score_match*2)
										{
#Exclude reads------------------------                        
											my $exclude_pos = $long_read_end_pos;
											if (length($read) < $long_read_end_pos)
											{
												$exclude_pos = length($read);
											}
											if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "dddddddd")
											{
												$exclude_reads_NP{$id}{$id_tmp3} = $position+$exclude_pos;
												#print {$filehandle{$seed_id2}} $id_tmp." EXCLUDE1\n";
											}
#Exclude reads------------------------
										}
									}
								}
								elsif ((($score_match >= ($score_no_match+$score_match)*0.92) && ($score_match_VIP >= ($score_no_match_VIP+$score_match_VIP)*0.92) && ($score_match_DUP >= ($score_match_DUP+$score_no_match_DUP)*0.92))
									   && ($score_match > 0 || $score_match_VIP > 0 || $score_match_DUP > 1) && ($maybe_match_VIP+$score_no_match < $score_match_VIP+$score_match || $maybe_match_VIP eq '0'))
								{
									if (exists($add_rej_reads_extra{$id_tmp3}) && $add_no_match_reads ne "" && $full_reset_NP eq "")
									{
										delete $add_rej_reads_extra{$id_tmp3};
										delete $id_matches{$id_tmp3};
										delete $exclude_reads_NP{$seed_id};
										delete $save_alignment_data_NP{$seed_id};
										delete $rejected_alignment_data_NP{$seed_id};
										$full_reset_NP_tmp = "A";
										print {$filehandle{$seed_id2}} $id_tmp3." FULL_RESET_NO_MATCH\n";					
									}
									else
									{
										my $ext = substr $check_prev_splits{$id_tmp3}, $long_read_end_pos-90;
										$length_ext_all{$id_tmp3} = length($ext);
										
										if (length($ext) > 200)
										{
											$extensions{$ext} = $id_tmp3;
											$extensions2{$id_tmp3} = $ext;
											$extensions2b{$id_tmp3}{$ext}{$score_match+$score_match_VIP+$score_match_DUP} = $score_no_match+$score_no_match_VIP+$score_no_match_DUP;
											if ($score_match_VIP > $score_no_match_VIP*2 && $score_match_VIP > 0)
											{
												$extensions2_VIP{$id_tmp3} = $score_match_VIP-($score_no_match_VIP*2);
											}
				
											$var_matches{$id_tmp3} = ($score_match)-($score_no_match*1.7);
											$var_matches_DUP{$id_tmp3} = $score_match_DUP-($score_no_match_DUP*1.5);
											$track_coverage{$id}{$position}{$id_tmp3} = undef;	
										}
										else
										{
											print {$filehandle{$seed_id2}} length($ext)." LENGTH TOO SHORT\n";
										}
									}										
								}
								else
								{
									my $ext = substr $check_prev_splits{$id_tmp3}, $long_read_end_pos-90;
									$length_ext_all{$id_tmp3} = length($ext);
									
									if ($find_haps_in_seed eq "yes")
									{
										$ext = substr $check_prev_splits{$id_tmp3}, $long_read_start_pos, $long_read_end_pos-$long_read_start_pos;
									}
									if ($add_no_match_reads ne "" && $score_no_match eq '0' && $score_no_match_VIP eq '0' && $score_no_match_DUP eq '0')
									{
										delete $exclude_reads_NP{$seed_id};
										delete $save_alignment_data_NP{$seed_id};
										delete $rejected_alignment_data_NP{$seed_id};
										$full_reset_NP = "A";
										print {$filehandle{$seed_id2}} $full_reset_NP." FULL_RESET_NO_MATCH\n";
										$best_extension = "";
										$seed_id = $id;	
										$y++;
										$y{$id} = $y;
										goto FULL_RESET;
									}
									
									if (length($ext) > 200)
									{                         
										$extensions_unknown{$ext} = $id_tmp3;
										$extensions_unknown2{$id_tmp3} = $ext;
										$extensions2b{$id_tmp3}{$ext}{$score_match+$score_match_VIP+$score_match_DUP} = $score_no_match+$score_no_match_VIP+$score_no_match_DUP;
										
										$var_matches{$id_tmp3} = ($score_match)-($score_no_match*1.7);
										$var_matches_DUP{$id_tmp3} = $score_match_DUP-($score_no_match_DUP*1.5);
										$track_coverage{$id}{$position}{$id_tmp3} = undef;	
									}
								}
								my $input_files_blast_tmp = keys %input_files_blast;
								if ($count_BLAST_runnng < $input_files_blast_tmp)
								{
									goto BLAST_RUN_NP;
								}
							}
						}
					}
                }
				
				if ($full_reset_NP_tmp ne "")
				{
					$best_extension = "";
					$seed_id = $id;	
					$y++;
					$y{$id} = $y;
					$full_reset_NP = $full_reset_NP_tmp;
					goto FULL_RESET;
				}
				my $count_remaining_ids = '0';
				foreach my $length_tmp (keys %input_files_blast)
				{
					my $count_remaining_ids2 = keys %{$input_files_blast{$length_tmp}};
					if ($count_remaining_ids2 > 0)
					{
						$count_remaining_ids++;
					}
					else
					{
						delete $input_files_blast{$length_tmp};
						delete $id_by_length{$length_tmp};
					}
				}

                my $limi = '1200';
                if ($count_remaining_ids > 0 && $count_limit1 < $limi)
                {
                    $count_limit1++;
					if ($count_limit1 > 1000)
					{
						sleep(0.5);
					}
                    goto BLAST_RUN_NP;
                }
                else
                {
                    foreach my $length_tmp (keys %input_files_blast)
					{
                        my $id_tmp3 = $id_by_length{$length_tmp};
						print {$filehandle{$seed_id2}} $id_tmp3." SKIPPED_IDs\n";
                    }
                }

                print {$filehandle{$seed_id2}} "\n".$ref_end_rejection." REF_END_REJECTION\n";
                print {$filehandle{$seed_id2}} $read_start_pos_rejection." READ_START_POS_REJECTION\n";
                print {$filehandle{$seed_id2}} $no_hit_rejection." NO_HIT_REJECTION\n";
                print {$filehandle{$seed_id2}} $almost_no_hit_rejection." ALMOST_NO_HIT_REJECTION\n";
                print {$filehandle{$seed_id2}} $accuracy_rejection." ACCURACY_REJECTION\n";
                print {$filehandle{$seed_id2}} $ext_too_short." EXT_TOO_SHORT\n";
                print {$filehandle{$seed_id2}} $overlap_too_short." OVERLAP_TOO_SHORT\n";
                print {$filehandle{$seed_id2}} $multi_match_rejection." MULTI_MATCH_REJECTION\n";
    
                print {$filehandle{$seed_id2}} "\n".$longest_read." LONGEST_READ\n";
                print {$filehandle{$seed_id2}} $count_matches_with_high_scores." HIGH_SCORE_matches\n\n";
		 
				if ($assembly_length_max eq "WG" && $y eq "1" && ($count_matches_with_high_scores > $sequencing_depth_NP*2 || ($total_matches < 10 && $total_matches < $sequencing_depth_NP*0.7)) && ($first_back_assembly eq "" || length($read) < 5000))
				{
					print $count_matches_with_high_scores." READ_REJECTED2\n";
					print {$filehandle{$seed_id2}} $count_matches_with_high_scores." READ_REJECTED2\n";
					foreach my $id_tmp (keys %printed_refs2)
					{
						unlink $TMP_directory."ref_tmp_".$id_tmp."_".$y.".fasta";
					}
					foreach my $id_tmp (keys %printed_blast)
					{
						unlink $TMP_directory."blast_tmp_".$id."_".$y."__".$id_tmp.".txt";
						
						if (exists($double_matches{$id_tmp}))
						{
							unlink $TMP_directory."blast_tmp_".$id."_".$y."_yes_".$id_tmp.".txt";
						}
					}
					$first_back_assembly = "yes";
					goto END1;
				}  

                if ($count_remaining_ids > 0)
                {
                    foreach my $length_tmp (sort {$a <=> $b} keys %input_files_blast)
					{                
						my $id_tmp3 = $id_by_length{$length_tmp};
                        print {$filehandle{$seed_id2}} $id_tmp3." SKIPPED_IDs2\n";
                    }
                }

                foreach my $id_tmp (keys %printed_refs2)
                {
                    unlink $TMP_directory."ref_tmp_".$id_tmp."_".$y.".fasta";
                }
                foreach my $id_tmp (keys %printed_blast)
                {
                    unlink $TMP_directory."blast_tmp_".$id."_".$y."__".$id_tmp.".txt";
                    
                    if (exists($double_matches{$id_tmp}))
                    {
                        unlink $TMP_directory."blast_tmp_".$id."_".$y."_yes_".$id_tmp.".txt";
                    }
                }
				
				if ($assembly_length_max eq "WG" && $y eq "1" && $read_start_pos_rejection > $count_matches_with_high_scores && ($first_back_assembly eq "" || length($read) < 5000))
				{
					print $read_start_pos_rejection." READ_REJECTED3\n";
					print {$filehandle{$seed_id2}} $read_start_pos_rejection." READ_REJECTED3\n";
					$first_back_assembly = "yes";
					goto END1;
				}
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
                if ($add_rejected_reads ne "" || $add_no_match_reads ne "" || $add_rejected_and_no_match_reads ne "")
                {
                    goto SELECT_LENGTH_NP2a;
                }        
#Remove multi match patterns-----------------------------------------------------------------------------------------------------------------                  
                my $gap_pos_prev = "";
                my $gap_id_prev = "";
                my $count_gap_pattern = '1';
                my $count_extra = '0';
                my %multi_match_remove;
                undef %multi_match_remove;

                foreach my $gap_pos_tmp (sort {$a <=> $b} keys %multi_match_pos)
                {             
                    foreach my $id_tmp (keys %alignment_length_save)
                    {
                        if (exists($multi_match{$id_tmp}))
						{}
						elsif ($alignment_length_save{$id_tmp} > $gap_pos_tmp+500)
                        {
                            $count_extra++;
                        }
                    }
                    if ($gap_pos_prev ne "" && $gap_pos_tmp < $gap_pos_prev+150 && $count_extra > 2)
                    {
                        $count_gap_pattern++;
                        $multi_match_remove{$gap_id_prev} = $gap_pos_tmp;
                        $multi_match_remove{$multi_match_pos{$gap_pos_tmp}} = $gap_pos_tmp;
                    }
                    elsif ($count_gap_pattern > 1 && $count_extra > $count_gap_pattern+1)
                    {
                        if ($count_gap_pattern eq '2')
						{
							foreach my $id_tmp2 (keys %multi_match_remove)
							{
								if (exists($extensions2{$id_tmp2}))
								{
									undef %multi_match_remove;
								}
							}
						}
						foreach my $id_tmp2 (keys %multi_match_remove)
                        {               
                            $extensions_nomatch{$extensions2{$id_tmp2}} = $id_tmp2;
							$extensions_nomatch2{$id_tmp2} = $extensions2{$id_tmp2};
							delete $extensions{$extensions2{$id_tmp2}};
                            delete $extensions2{$id_tmp2};
							delete $extensions2b{$id_tmp2};
							delete $extensions2_VIP{$id_tmp2};
							delete $extensions_unknown{$extensions2{$id_tmp2}};
							delete $extensions_unknown2{$id_tmp2};
                            delete $save_reads_for_next{$id_tmp2};
							$read_start_pos_rej{$id_tmp2} = $multi_match_remove{$id_tmp2};
							print {$filehandle{$seed_id2}} $id_tmp2." ".$multi_match_remove{$id_tmp2}." REMOVE_MULTI_MATCH\n";
							
                        }
                        print {$filehandle{$seed_id2}} $count_gap_pattern." REMOVE_MULTI_MATCH\n";
                        undef %multi_match_remove;
                        $count_gap_pattern = '1';
                        $count_extra = '0';
                    }
                    else
                    {
                        undef %multi_match_remove;
                        $count_gap_pattern = '1';
                        $count_extra = '0';
                    }

                    $gap_pos_prev = $gap_pos_tmp;
                    $gap_id_prev = $multi_match_pos{$gap_pos_tmp};
                }
                if ($count_gap_pattern > 1 && $count_extra > $count_gap_pattern+1)
                {
                    foreach my $id_tmp2 (keys %multi_match_remove)
                    {               
						$extensions_nomatch{$extensions2{$id_tmp2}} = $id_tmp2;
						$extensions_nomatch2{$id_tmp2} = $extensions2{$id_tmp2};
						delete $extensions{$extensions2{$id_tmp2}};
						delete $extensions2{$id_tmp2};
						delete $extensions2b{$id_tmp2};
						delete $extensions2_VIP{$id_tmp2};
						delete $extensions_unknown{$extensions2{$id_tmp2}};
						delete $extensions_unknown2{$id_tmp2};
						delete $save_reads_for_next{$id_tmp2};
                    }
                     print {$filehandle{$seed_id2}} $count_gap_pattern." REMOVE_MULTI_MATCH1\n";
                }

#-----------------------------------------------------------------------------------------------------------------  
                my $time_BLAST2 = time;
                my $time8 = $time_BLAST2 - $time_id_by_length;
                print {$filehandle{$seed_id2}} $time8." TIME_BLAST2\n\n";
                
                #if ($confirmed_reads_count_NP > 4 && $skip_confirmed eq "" && ($count_matches_with_high_scores < 4 || $count_matches_with_high_scores < $sequencing_depth_NP/4)
                    #&& $find_haps_in_seed eq "" && $only_confirmed eq "yes")
                #{
                    #$skip_confirmed = "yes";
                    #undef %id_matches;
                    #undef %reverse_list;
                    #undef %double_matches;
                   # goto SKIP_CONFIRMED_NP;
                #}
				my $average_match_length = "";
				if (keys %alignment_length_save > 3)
				{
					my $total_length_tmp = '0';
					my $total_count_tmp = '0';
					foreach my $length_tmp7 (sort {$b <=> $a} keys %alignment_length_save2)
					{
						foreach my $id_tmp7 (keys %{$alignment_length_save2{$length_tmp7}})
						{
							$total_count_tmp++;
							$total_length_tmp += $length_tmp7;
							if ($total_count_tmp > $sequencing_depth_NP)
							{
								last;
							}
						}
					}
					$average_match_length = $total_length_tmp/$total_count_tmp;
					print {$filehandle{$seed_id2}} $average_match_length." AVERAGE_LENGTH\n";
				}
				if (((($count_matches_with_high_scores < 12 || $count_matches_with_high_scores < $sequencing_depth_NP) && $total_matches_extra < 8)
					|| ($average_match_length ne "" && $average_match_length < $average_length_NP/4)) && $skipped_matches > 0 && $skipped_matches ne "no")
				{
					print {$filehandle{$seed_id2}} $skipped_matches." NO_SKIP\n";
					$skipped_matches = "no";
					undef %id_matches;
                    undef %reverse_list;
                    undef %double_matches;
					if ($total_matches > 1000)
					{
						$first_length_back += 1000;
					}
                    goto SKIP_CONFIRMED_NP;
				}
				if (($count_matches_with_high_scores < 10 || ($average_match_length ne "" && $average_match_length < $average_length_NP/6) || ($multi_match_rejection > 10 && $count_matches_with_high_scores < 20)
					 || ($multi_match_rejection > 10 && $average_match_length < $average_length_NP/5)) && $discontiguous_blast eq "" && $find_haps_in_seed eq ""
					&& $count_matches_with_high_scores+$multi_match_rejection > $count_matches_with_high_scores*1.25 && $new_contig_check eq "")
                {
                    print {$filehandle{$seed_id2}} $average_match_length." DISCONTIGUOUS_BLAST\n";
                    $discontiguous_blast = "yes";
                    undef %id_matches;
                    undef %reverse_list;
                    undef %double_matches;
                    goto SKIP_CONFIRMED_NP;
                }
				if ($count_matches_with_high_scores < 5  && $full_reset_NP eq "" && $new_contig_check eq "")
				{
					delete $exclude_reads_NP{$seed_id};
					delete $save_alignment_data_NP{$seed_id};
					delete $rejected_alignment_data_NP{$seed_id};
					$full_reset_NP = "A";
					print {$filehandle{$seed_id2}} $full_reset_NP." FULL_RESET0\n";
					$best_extension = "";
					$seed_id = $id;	
					$y++;
					$y{$id} = $y;
					goto FULL_RESET;
				}
				
				if ($count_matches_with_high_scores < $sequencing_depth_NP*1.5 && $position > 2000)
                {
                    $last_non_complex_region{$seed_id} = $position-2000;
                }
				
				if ($count_matches_with_high_scores < 5 && $count_matches_with_high_scores < $sequencing_depth_NP/2 && ($retry_NP eq "" || $retry_NP < $position-20000)
					&& $position > 20000 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $new_contig_check eq "")
                {
                    $retry_NP = $position;
					delete $exclude_reads_NP{$seed_id};
					delete $save_alignment_data_NP{$seed_id};
					delete $rejected_alignment_data_NP{$seed_id};			
					$seed_id = $id;
					substr $read, -15000, 15000, "";
					$position -= 15000;
					$position{$id} = $position;
					$seed{$seed_id} = $read;
					$y++;
					$y{$id} = $y;
					
					foreach my $pos_split (keys %{$split_positions{$id}})
					{
						if (exists($split_positions_VIP{$id}{$pos_split}))
						{}
						elsif ($pos_split > $position+length($best_extension)+150)
						{
							delete $split_positions{$id}{$pos_split};
						}
					}
					foreach my $pos_split (keys %{$split_positions_DUP{$id}})
					{
						if (exists($split_positions_VIP{$id}{$pos_split}))
						{}
						elsif ($pos_split > $position+length($best_extension)+150)
						{
							delete $split_positions_DUP{$id}{$pos_split};
							delete $split_positions_DUP2{$id}{$pos_split};
						}
					}
					$best_extension = "";
					if ($hap_compare_pos{$id} > $position)
					{
						$hap_compare_pos{$id} = $position;
					}
					
					print {$filehandle{$seed_id2}} "RETRY_NP\n";
					goto FULL_RESET;
                }				
                
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
#START reverse assembly----------------------------------------------------------------------------------------------------------------------------------------------------------                               
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
				
				if ($assembly_length_max eq "WdGsfs" && ($position_back > 0 || $position > $original_seed_length{$id}+10000))
				{
					if ($first_back_assembly eq "")
					{
						substr $read, 0, $original_seed_length{$id}, "";
						$first_back_assembly = "yes";
						$read_back = reverse($read);
						$read_back =~ tr/ACTG/TGAC/;
					}
		
					my $first_length_back = '900';
	
					if ($first_length_back > length($read_back))
					{
						$first_length_back = length($read_back)-50;
					}
	
					my $skip_confirmed_back = "";
					my $discontiguous_blast_back = "";
					my $last_hap_pos_back = "";
					my $last_hap_pos_DUP_back = "";
					my %hash_NP_reads_back_tmp;
					undef %hash_NP_reads_back_tmp;
					
SKIP_CONFIRMED_NP_BACK:                
					my %id_matches_back;
					undef %id_matches_back;
					my %double_matches_back;
					undef %double_matches_back;
					my %reverse_list_back;
					undef %reverse_list_back;
			  
	
#Find matches in hash against last 600 bp back--------------------------------------------------------------                           
						
					my $query_coverage_back = 90;
						
LONGER_LAST_600_NP_BACK:
	
					my $last_600 = substr $read_back, -$first_length_back;

					my %first_pos_read_back;
					undef %first_pos_read_back;
					
					my $query_file_DB = $TMP_directory."query_NP_back_".$project.".fasta";
					open(INPUT_QUERY_NP, ">" .$query_file_DB) or die "\nCan't open file $query_file_DB, $!\n";
					#print INPUT_QUERY_NP ">ref\n";
					print INPUT_QUERY_NP $last_600;        
					close INPUT_QUERY_NP;
					
					my %output_files_DB_back;
					undef %output_files_DB_back;
					my %output_files_DB2_back;
					undef %output_files_DB2_back;
					
					foreach my $pid_tmp (keys %ret_data_NP)
					{
						my $file_tmp = $TMP_directory."blast_tmp_DB_NP_back_".$id."_".$y."_".$pid_tmp.".txt";
						my $command_DB = "blastn -query ".$query_file_DB." -db ".$ret_data_NP{$pid_tmp}." -out ".$file_tmp." -outfmt 7 -qcov_hsp_perc ".$query_coverage_back." -num_threads 2 &";
						syscmd($command_DB);             
						$output_files_DB_back{$file_tmp} = undef;
						$output_files_DB2_back{$file_tmp} = undef;
					}
		
#Add saved reads--------------------------------------------------------------                           						

SKIP_TO_CONFIRMED_NP_BACK:
					my %extensions_back;
					undef %extensions_back;
					my %extensions2_back;
					undef %extensions2_back;
					my %extensions2b_back;
					undef %extensions2b_back;
					my %extensions_nomatch_back;
					undef %extensions_nomatch_back;
					my %extensions_unknown_back;
					undef %extensions_unknown_back;
					my %extensions_nomatch2_back;
					undef %extensions_nomatch2_back;
					my %extensions_nomatch2b_back;
					undef %extensions_nomatch2b_back;
					my %extensions_unknown2_back;
					undef %extensions_unknown2_back;
					my %store_mismatches_NP_back;
					undef %store_mismatches_NP_back;
					my %store_mismatches_all_NP_back;
					undef %store_mismatches_all_NP_back;
					my %store_mismatches_N_NP_back;
					undef %store_mismatches_N_NP_back;
					
					my $extensions_nomatch2b_count_back = '0';
					my $extensions_nomatch2b_count_saved_back = '0';
					my $total_matches_extra_back = '0';
					my $position_prev_back = "";
					my %alignment_length_saved_back;
					undef %alignment_length_saved_back;
					my %score_match_saved_back;
					undef %score_match_saved_back;
					my %score_no_match_saved_back;
					undef %score_no_match_saved_back;
					my %score_match_DUP_saved_back;
					undef %score_match_DUP_saved_back;
					my %score_no_match_DUP_saved_back;
					undef %score_no_match_DUP_saved_back;
					my %accuracy_saved_back;
					undef %accuracy_saved_back;
					my %read_start_pos_rej_back;
					undef %read_start_pos_rej_back;
					my %read_start_pos_rej_saved_back;
					undef %read_start_pos_rej_saved_back;
					my %extensions_nomatch2b_saved_back;
					undef %extensions_nomatch2b_saved_back;
					
					foreach my $seed_id_tmp0 (keys %save_alignment_data_NP_back)
					{
						if ($seed_id_tmp0 eq $seed_id)
						{
							foreach my $id_tmp7 (keys %{$save_alignment_data_NP_back{$seed_id_tmp0}})
							{
								my @alignment_data = split /_/, $save_alignment_data_NP_back{$seed_id_tmp0}{$id_tmp7};
	
								if ($alignment_data[0] eq "yes" || $alignment_data[11] eq "")
								{ 
									$alignment_length_saved_back{$id_tmp7} = $alignment_data[4];
									$first_pos_read_back{$id_tmp7} = $alignment_data[2];
									$position_prev_back = $alignment_data[3];
									$score_match_saved_back{$id_tmp7} = $alignment_data[5];
									$score_no_match_saved_back{$id_tmp7} = $alignment_data[6];
									$score_match_DUP_saved_back{$id_tmp7} = $alignment_data[7];
									$score_no_match_DUP_saved_back{$id_tmp7} = $alignment_data[8];
									$accuracy_saved_back{$id_tmp7} = $alignment_data[9];
								}
							   
								if (($alignment_data[6] > $alignment_data[5] && $alignment_data[6] > 1) || ($alignment_data[8] > $alignment_data[7] && ($alignment_data[8] > 3
									|| $alignment_data[6]+$alignment_data[8] > $alignment_data[5]+$alignment_data[7])))
								{
									$extensions_nomatch2b_saved_back{$id_tmp7}{$alignment_data[5]}{$alignment_data[6]} = $alignment_data[3]+$alignment_data[10];
									$extensions_nomatch2b_count_saved_back++;
									if ($alignment_data[1] eq "yes")
									{
										$reverse_list_back{$id_tmp7} = undef;
									}
								}
								elsif ($alignment_data[0] ne "yes" && $alignment_data[11] ne "")
								{
									$read_start_pos_rej_back{$id_tmp7} = $alignment_data[11]+$position_back-$alignment_data[3];
									$read_start_pos_rej_saved_back{$id_tmp7} = undef;
									if ($alignment_data[1] eq "yes")
									{
										$reverse_list_back{$id_tmp7} = undef;
									}
								}
								else
								{
									$id_matches_back{$id_tmp7} = undef;
									$total_matches_extra_back++;
									if ($alignment_data[1] eq "yes")
									{
										$reverse_list_back{$id_tmp7} = undef;
									}
									elsif ($alignment_data[1] eq "yes2")
									{
										$reverse_list_back{$id_tmp7} = undef;
										$double_matches_back{$id_tmp7} = undef;
									}
									if ($alignment_data[12] ne "")
									{
										$hash_NP_reads_tmp_back{$id_tmp7} = $alignment_data[12];
									}
								}				
							}
						}
					}                                          
					print {$filehandle{$seed_id2}} $total_matches_extra_back." LAST_1000_matches_EXTRA_BACK\n\n";	
				}              
                                         
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
#Make consensus of extensions long reads NP-----------------------------------------------------------------------------------------------------------------------------------------                               
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
                my $mismatch_retry = '0';
                my $high_quality = "";
				my %split_positions_DUP_tmp;
                undef %split_positions_DUP_tmp;
                my %split_positions_DUP_tmp2;
                undef %split_positions_DUP_tmp2;
				my %split_positions_DUP_tmp3;
                undef %split_positions_DUP_tmp3;
                my $remove_reads_check = "";
                
MISMATCH_RETRY_NP:
                my $merged_ext = "";
                my %extensions2_tmp = %extensions2;
                my $ext2_count = keys %extensions2;
                print {$filehandle{$seed_id2}} $ext2_count." EXT_COUNT\n";
                
                #if ($skip_confirmed eq "" && ($ext2_count < 4 || $ext2_count < $sequencing_depth_NP/4)
                    #&& $find_haps_in_seed eq "" && $only_confirmed eq "yes")
                #{
                    #$skip_confirmed = "yes";
                    #undef %id_matches;
                    #undef %reverse_list;
                    #undef %double_matches;
                    #goto SKIP_CONFIRMED_NP;
                #}
                my $other_hap_read_count = keys %extensions_nomatch2;
				my $no_hap_read_count = keys %extensions_unknown2;
                if ((($ext2_count < 3 || $ext2_count < $sequencing_depth_NP/2 || ($ext2_count < $sequencing_depth_NP && $count_matches_with_high_scores > $sequencing_depth_NP*3)
                      || ($ext2_count < $sequencing_depth_NP/1.5 && $ext2_count < 7) || ($ext2_count < ($count_matches_with_high_scores-$other_hap_read_count)/2))
                    && ($no_hap_read_count > 0 || $other_hap_read_count > 0) && $ext2_count < 15) || ($last_hap_pos > 10000 && $ext2_count < $sequencing_depth_NP/2) || $full_reset_time ne "" || $added_unknown ne "")
                { 
                    if ((($ext2_count + $no_hap_read_count) < 3 || $added_unknown ne "") && $other_hap_read_count > 0)
                    {
                        %extensions = (%extensions, %extensions_unknown, %extensions_nomatch);
                        %extensions2_tmp = (%extensions2, %extensions_unknown2, %extensions_nomatch2);
                        $merged_ext = "2";
                        print {$filehandle{$seed_id2}} " MERGE2\n";
                    }
					elsif ($no_hap_read_count > 0)
					{
						%extensions = (%extensions, %extensions_unknown);
						%extensions2_tmp = (%extensions2, %extensions_unknown2);
						$merged_ext = "1";
						print {$filehandle{$seed_id2}} " MERGE1\n";
					}
                }
                #if (keys %extensions < 3 && $confirmed_reads_count_NP > 4 && $skip_confirmed eq "" && $only_confirmed eq "yes")
                #{
                    #$skip_confirmed = "yes";
                    #$best_extension = "";
                    #goto SKIP_CONFIRMED_NP;
                #}
                
                my $longer_extension_for_repeat = "";
                my $length_extension = '1500';
				my $count_hap_matches = keys %extensions2_tmp;

#Reduce extensions-------------------------------------------------------------------------------------------------                            

                my %scores;
                undef %scores;
                my %scores2;
				undef %scores2;
                
                my $acc_max = '0';
                my $acc_min = '100';
				
                foreach my $accuracy_id_tmp (sort {$a <=> $b} keys %accuracy)
                {
                    if (exists($extensions2_tmp{$accuracy_id_tmp}))
                    {
                        my $accuracy_tmp = $accuracy{$accuracy_id_tmp};
                        if ($accuracy_tmp > $acc_max)
                        {
                            $acc_max = $accuracy_tmp;
                        }
                        if ($accuracy_tmp < $acc_min)
                        {
                            $acc_min = $accuracy_tmp;
                        }
                    }
                }
                foreach my $accuracy_id_tmp (sort {$a <=> $b} keys %accuracy)
                {
                    if ((exists($extensions2_tmp{$accuracy_id_tmp})) && $acc_max-$acc_min > 0)
                    {
                        my $accuracy_tmp = $accuracy{$accuracy_id_tmp};
                        $scores{$accuracy_id_tmp} = (($accuracy_tmp-$acc_min)/($acc_max-$acc_min))/2;
                    }
                }
                
                my $overlap_max = '0';
                my $overlap_min = '0';
                foreach my $overlap_id_tmp (keys %alignment_length_save)
                {          
                    if (exists($multi_match{$overlap_id_tmp}))
                    {
                    }
                    elsif (exists($extensions2_tmp{$overlap_id_tmp}))
                    {
                        my $overlap_tmp = $alignment_length_save{$overlap_id_tmp};
                        if ($overlap_tmp > $overlap_max)
                        {
                            $overlap_max = $overlap_tmp;
                        }
                    }
                }
                foreach my $overlap_id_tmp (keys %alignment_length_save)
                {
                    if (exists($extensions2_tmp{$overlap_id_tmp}))
                    {
                        my $overlap_tmp = $alignment_length_save{$overlap_id_tmp};
						if (exists($multi_match{$overlap_id_tmp}))
                        {
                            $overlap_tmp *= 0.8;
                        }
                        my $overlap_score_tmp = '0';
                        if (($overlap_max-$overlap_min) ne '0')
                        {
                            $overlap_score_tmp = ($overlap_tmp-$overlap_min)/($overlap_max-$overlap_min);
                        }
                        my $score_tmp = $scores{$overlap_id_tmp};
                        
                        $scores{$overlap_id_tmp} = $overlap_score_tmp+$score_tmp;
                    }
                }
                
				if ($full_reset_time ne "")
				{
					my $var_max = '0';
					my $var_min = '100000000000000';
					
					foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches)
					{     
						my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
						if (exists($extensions2_tmp{$var_matches_id_tmp}))
						{
							if ($var_matches_tmp > $var_max)
							{
								$var_max = $var_matches_tmp;
							}
							if ($var_matches_tmp < $var_min)
							{
								$var_min = $var_matches_tmp;
							}
						}
					}
					foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches)
					{     
						my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
						if (exists($extensions2_tmp{$var_matches_id_tmp}))
						{
							my $var_score_tmp = '0';
							if ($var_max-$var_min > 0)
							{
								$var_score_tmp = ($var_matches_tmp-$var_min)/($var_max-$var_min);
							}
							my $score_tmp = $scores{$var_matches_id_tmp};
							$scores{$var_matches_id_tmp} = $score_tmp+$var_score_tmp;
						}
					}
					
					my $var_max_DUP = '0';
					my $var_min_DUP = '100000000000000';
					
					foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches_DUP)
					{     
						my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
						if (exists($extensions2_tmp{$var_matches_id_tmp}))
						{
							if ($var_matches_tmp > $var_max_DUP)
							{
								$var_max_DUP = $var_matches_tmp;
							}
							if ($var_matches_tmp < $var_min_DUP)
							{
								$var_min_DUP = $var_matches_tmp;
							}
						}
					}
					foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %var_matches_DUP)
					{     
						my $var_matches_tmp = $var_matches{$var_matches_id_tmp};
						if (exists($extensions2_tmp{$var_matches_id_tmp}))
						{
							my $var_score_tmp = '0';
							if ($var_max_DUP-$var_min_DUP > 0)
							{
								$var_score_tmp = ($var_matches_tmp-$var_min_DUP)/($var_max_DUP-$var_min_DUP);
							}
							my $score_tmp = $scores{$var_matches_id_tmp};
							$scores{$var_matches_id_tmp} = $score_tmp+($var_score_tmp/2);
						}
					}
					
					my $var_max_VIP = '0';
					my $var_min_VIP = '100000000000000';
					
					foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %extensions2_VIP)
					{     
						my $var_matches_tmp = $extensions2_VIP{$var_matches_id_tmp};
						if (exists($extensions2_tmp{$var_matches_id_tmp}))
						{
							if ($var_matches_tmp > $var_max_VIP)
							{
								$var_max_VIP = $var_matches_tmp;
							}
							if ($var_matches_tmp < $var_min_VIP)
							{
								$var_min_VIP = $var_matches_tmp;
							}
						}
					}
					foreach my $var_matches_id_tmp (sort {$a <=> $b} keys %extensions2_VIP)
					{     
						my $var_matches_tmp = $extensions2_VIP{$var_matches_id_tmp};
						if (exists($extensions2_tmp{$var_matches_id_tmp}))
						{
							my $var_score_tmp = '0';
							if ($var_max_VIP-$var_min_VIP > 0)
							{
								$var_score_tmp = ($var_matches_tmp-$var_min_VIP)/($var_max_VIP-$var_min_VIP);
							}
							my $score_tmp = $scores{$var_matches_id_tmp};
							$scores{$var_matches_id_tmp} = $score_tmp+($var_score_tmp*1.5);
						}
					}
				}
                      
                foreach my $score_id (keys %scores)
                {
                    if (exists($scores2{$scores{$score_id}}))
                    {
                        $scores2{$scores{$score_id}} .= ",$score_id"; 
                    }
                    else
                    {
                        $scores2{$scores{$score_id}} = $score_id;
                    }
                }

                my $c = '1';
                my $c2 = '0';
                my $limit2 = $sequencing_depth_NP;
				my $limit = 45;
				if ($assembly_length_max eq "WG" && $count_matches_with_high_scores < $sequencing_depth_NP*2.5)
				{
					$limit = 25;
				}

                my $shortest_ext = '100000000000000';
                my $max_score = "";
				my $max_score3 = "";
                my $max_score_count = '0';
                my %length_ext0;
				undef %length_ext0;
				my %length_ext_10;
				undef %length_ext_10;
                
                foreach my $score_tmp (sort {$b <=> $a} keys %scores2)
                {
                    print {$filehandle{$seed_id2}} $scores2{$score_tmp}." ".$score_tmp." SCORE\n";             
                    my @ids_tmp = split /,/, $scores2{$score_tmp};
                    foreach my $ids_tmp (@ids_tmp)
                    {
						if (exists($extensions2_tmp{$ids_tmp}))
                        {
                            $max_score_count++;
                            if ($max_score eq "")
                            {
                                $max_score = $score_tmp;
                            }
							if ($max_score_count eq '3')
                            {
                                $max_score3 = $score_tmp;
                            }
                            
                            if ($max_score_count < 3)
                            {
                                $c2++;
                                $length_ext0{length($extensions2_tmp{$ids_tmp})} = $ids_tmp;
                            }
                            elsif (($c2 > $limit || $c2 > $limit2*2) && $c2 > 2 && $find_haps_in_seed eq "")
                            {
                                delete $extensions2_tmp{$ids_tmp};
                            }
							elsif ($c2 > $limit2*0.8 && $c2 > 10 && $find_haps_in_seed eq "" && $score_tmp < $max_score/2.8 && $score_tmp < 0.55 && $score_tmp < $max_score3*0.6 && $alignment_length_save{$ids_tmp} < 12000)
                            {
                                delete $extensions2_tmp{$ids_tmp};
                            }
                            elsif ($c >= 5 && length($extensions2_tmp{$ids_tmp}) < ($shortest_ext*0.7) && length($extensions2_tmp{$ids_tmp}) < 1000 && $c2 > 2 && $find_haps_in_seed eq "")
                            {   
                                print {$filehandle{$seed_id2}} $ids_tmp." DEL\n";
                                print {$filehandle{$seed_id2}} length($extensions2_tmp{$ids_tmp})." LENGTH\n";
                                delete $extensions2_tmp{$ids_tmp};
                            }
                            elsif ($c < $limit2 || $score_tmp > 0.4*$max_score || $score_tmp > 0.6 || $c2 < 3 || ($count_matches_with_high_scores > $limit2 && $c2 < $sequencing_depth_NP*1.5) || $alignment_length_save{$ids_tmp} > 10000)
                            {
                                $c2++;
                                $length_ext0{length($extensions2_tmp{$ids_tmp})} = $ids_tmp;
                            }
                            else
                            {
                                delete $extensions2_tmp{$ids_tmp};
                            }
                            
                            if ($c < 5 && length($extensions2_tmp{$ids_tmp}) < $shortest_ext && length($extensions2_tmp{$ids_tmp}) ne "")
                            {
                                $shortest_ext = length($extensions2_tmp{$ids_tmp});
                                print {$filehandle{$seed_id2}} $ids_tmp." ID\n";
                                print {$filehandle{$seed_id2}} $shortest_ext." SHORTEST_EXT\n";
                            }
							
							if ($c <= 10)
							{
								$length_ext_10{length($extensions2_tmp{$ids_tmp})} = $ids_tmp;
							}
                            $c++; 
                        }
                    } 
                }
#Increase consensus length-----------------------------------------------------------------------------------------------------            
                
SELECT_LENGTH_NP:               
                if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
                {
                    $length_extension = '500';
                }

                if (exists($cut_repeat_seq{$seed_id}))
                {
                    $length_extension = '3900';
                }
                if ($longer_extension_for_repeat eq "" && $shortest_ext ne '100000000000000')
                {
                    $length_extension = $shortest_ext;
                }

                if ($length_extension < 800)
                {
                    $length_extension = '800';
                }			

                if ($find_haps_in_seed eq "yes")
                {
                    $length_extension = length($read)-25;
                }
                
                my %length_tmp;
                undef %length_tmp;
                foreach my $ids_tmp (keys %extensions2_tmp)
                {
                    $length_tmp{length($extensions2_tmp{$ids_tmp})} = undef;
                }
                my $count_tmp = '1';
				my $total_tmp = keys %length_tmp;
				my $fg = '0.75';
				
				if ($assembly_length_max eq "WG" && $count_matches_with_high_scores < $sequencing_depth_NP*1.2)
				{
					$fg = '0.63';
				}
				if ($count_matches_with_high_scores < 13)
				{
					$fg = '0.85';
				}

                foreach my $length_ext_tmp (sort {$b <=> $a} keys %length_tmp)
                {
                    if (($count_tmp > $fg*$total_tmp || $count_tmp > 25) && $count_tmp > 3)
                    {
                        if ($length_ext_tmp > $length_extension && $find_haps_in_seed ne "yes")
                        {
                            $length_extension = $length_ext_tmp;
                        }
                        last;
                    }
                    $count_tmp++;
                }
				my $count_tmp2 = '1';
				foreach my $length_ext_tmp (sort {$b <=> $a} keys %length_ext_10)
                {
                    if ($count_tmp2 > 6)
                    {
                        if ($length_ext_tmp > $length_extension && $find_haps_in_seed ne "yes")
                        {
                            $length_extension = $length_ext_tmp;
                        }
                        last;
                    }
                    $count_tmp2++;
                }	
				
				if ($length_extension > 7000 && ($find_haps_in_seed eq "" || $length_extension < 15000))
                {
                    $length_extension = '7000';
                }
				
                $length_extension += 450;
                    
                if ($longer_extension_for_repeat ne "")
                {
                    my $count_tmp3 = '1';
                    foreach my $length_ext_tmp (sort {$b <=> $a} keys %length_tmp)
                    {
                        if (($count_tmp3 > 0.25*$total_tmp && $count_tmp3 > 3) || $length_ext_tmp > $longer_extension_for_repeat+7000)
                        {
                            $length_extension = $length_ext_tmp;
                            last;
                        }
                        $count_tmp3++;
                    }
                    if ($length_extension > $longer_extension_for_repeat)
                    {
						$length_extension = $longer_extension_for_repeat
                    }         
                }

                print {$filehandle{$seed_id2}} $length_extension." LENGTH_EXTENSION\n";
                
SELECT_LENGTH_NP2a:
#ADD_REJ_READS-----------------------------------------------------------------------------------------------------------------               
                if (($add_rejected_reads ne "" || $add_no_match_reads ne "" || $add_rejected_and_no_match_reads ne "") && $remove_reads_check eq "")
                {
                    foreach my $id_tmp1 (keys %add_rej_reads_extra)
                    {
                        if (exists($extensions2_tmp{$id_tmp1}))
						{}
						elsif (exists($long_read_end_pos_save{$id_tmp1}))
						{
							my $long_read_tmp = "";
							if (exists($reverse_list{$id_tmp1}))
							{
								$long_read_tmp = reverse($hash_NP_reads_tmp{$id_tmp1});
								$long_read_tmp =~ tr/ACTG/TGAC/;
							}
							else
							{
								$long_read_tmp = $hash_NP_reads_tmp{$id_tmp1};
							}
							
							my $long_read_end_pos_tmp = $long_read_end_pos_save{$id_tmp1};
							print {$filehandle{$seed_id2}} $id_tmp1." IDD_ADD_REJ\n";
							print {$filehandle{$seed_id2}} $long_read_end_pos_tmp." LONG_READ_END\n";
							my $ext = substr $long_read_tmp, $long_read_end_pos_tmp-90, $length_extension;
							if (exists($scores2{'0'}))
							{
								$scores2{'0'} .= ",$id_tmp1"; 
							}
							else
							{
								$scores2{'0'} = $id_tmp1;
							}
							$extensions2_tmp{$id_tmp1} = $ext;
						}
						else
						{
							delete $add_rej_reads_extra{$id_tmp1};
							delete $id_matches{$id_tmp1};
							delete $save_alignment_data_NP{$seed_id}{$id_tmp1};

							if ($add_no_match_reads ne "" || $add_rejected_and_no_match_reads ne "")
							{
								delete $extensions_nomatch2b_saved{$id_tmp1};
							}
						}
                    }
                }        
#------------------------------------------------------------------------------------------------------------------------------

				if (keys %extensions2_tmp < 4  && $full_reset_NP eq "" && $y > 1)
				{
					delete $exclude_reads_NP{$seed_id};
					#delete $save_alignment_data_NP{$seed_id};
					delete $rejected_alignment_data_NP{$seed_id};
					$full_reset_NP = "A";
					print {$filehandle{$seed_id2}} $best_extension." FULL_RESET7\n";
					$best_extension = "";
					$seed_id = $id;
					$y++;
					$y{$id} = $y;
					goto FULL_RESET;
				}
				my $extension_part_length = '800';
SELECT_LENGTH_NP2:
				
				my $devide_extension_count = int(($length_extension/$extension_part_length)+0.5);
				#if ($devide_extension_count > $maxProcs)
				#{
					#$devide_extension_count = $maxProcs;
				#}
				if ($devide_extension_count < 1)
				{
					$devide_extension_count = '1';
				}
				my $length_extension_part = int($length_extension/$devide_extension_count);
				my $length_extension_part_extra = '100';
				
				print {$filehandle{$seed_id2}} $length_extension_part." LENGTH_EXTENSION_PART\n";
				
                my $v = '1';
                my %length_ext;
                undef %length_ext;
                my %rank_to_id;
				undef %rank_to_id;
                my %id_to_rank;
                undef %id_to_rank;
                
                foreach my $score_tmp (sort {$b <=> $a} keys %scores2)
                {
                    my @ids_tmp = split /,/, $scores2{$score_tmp};
                    foreach my $ids_tmp (@ids_tmp)
                    {
                        if (exists($extensions2_tmp{$ids_tmp}))
                        {                     
                            my $ext_tmp2 = substr $extensions2_tmp{$ids_tmp}, 0, $length_extension;
							$rank_to_id{$v} = $ids_tmp;
                            $length_ext{$v} = length($ext_tmp2);                        
							$save_reads_for_next{$ids_tmp} = undef;   
                            $id_to_rank{$ids_tmp} = $v;
                            print {$filehandle{$seed_id2}} $v." V ".$ids_tmp." ID ".length($ext_tmp2)." LENGTH\n";
                            $v++;
                        }
                    }
                }
				my $total_nuc_count_original = $v-1;
				
				my $clipped_ext = "";
				my $N = '0';
				my $N_resolved = '0';
				my $mafft_count = "1";
				my $cp_original = "";
				my %track_length_ext_total;
				undef %track_length_ext_total;
				my %SNP_patterns_prev;
				undef %SNP_patterns_prev;
				my %pos_pattern_list;
				undef %pos_pattern_list;
                my %read_patterns2;
				undef %read_patterns2;
                my %read_patterns_final;
                undef %read_patterns_final;
				my $first_split_pos = "";
                my %track_mismatch_ext;
                undef %track_mismatch_ext;
                my $track_mismatch_count = '0';
				my $post_pattern_match = "";
				my $post_pattern_match_count = '1';
				my $post_pattern_match_save = "";
				my $nuc_match = "";
                my $nuc_prev = "";
				my $total_count_prev_patterns = '0';
				my %total_count_prev_patterns;
				undef %total_count_prev_patterns;
				my %quality_scores_tmp;
				undef %quality_scores_tmp;
                my %quality_scores_gap_tmp;
                undef %quality_scores_gap_tmp;
				my %best_read_score;
				undef %best_read_score;				
				my %mismatches_tmp;
				undef %mismatches_tmp;
                my %mismatches_tmp_all;
				undef %mismatches_tmp_all;
				my %reads_mismatch;
				undef %reads_mismatch;
				my %reads_mismatchb;
				undef %reads_mismatchb;
				my %reads_mismatch2;
				undef %reads_mismatch2;
				my %reads_mismatch2_tmp;
				undef %reads_mismatch2_tmp;
				my %reads_mismatch_all;
				undef %reads_mismatch_all;
				my %reads_mismatchb_all;
				undef %reads_mismatchb_all;
				my %reads_mismatch2_all;
				undef %reads_mismatch2_all;
				my %reads_mismatch2_tmp_all;
				undef %reads_mismatch2_tmp_all;
				my $mismatch_score_all = '0';
                my $mismatches_tmp_check = "";                     
                my $pos_pattern_list_check = "";
				my $rank_count_check = "";
				my $time_BLAST3b = time;
				my %extensions_seed;
				undef %extensions_seed;
				my %haps_list;
				undef %haps_list;
                my $hap_position = "";
				my %clipped_ext_pos;
				undef %clipped_ext_pos;
MAFFT_NP:				
				my $other_seq = "";
				foreach my $rank_tmp7 (sort {$a <=> $b} keys %rank_to_id)
				{
					if (exists($extensions2_tmp{$rank_to_id{$rank_tmp7}}))
					{                     
						my $start_pos_tmp = 0;
						if ($mafft_count > 1)
						{
							$start_pos_tmp = $track_length_ext_total{$rank_tmp7};
						}
						if ($length_ext{$rank_tmp7} > $start_pos_tmp+500 || $mafft_count eq '1')
						{
							my $ext_tmp2 = substr $extensions2_tmp{$rank_to_id{$rank_tmp7}}, $start_pos_tmp, $length_extension_part+$length_extension_part_extra;
							$other_seq .= ">".$rank_tmp7."\n";
							$other_seq .= $ext_tmp2."\n";
						}
					}
				}
				my $time_mafft1 = time;
					
				my $output_file6  = $TMP_directory."sequence_tmp_".$project."_".$mafft_count.".fasta";
			
				open(OUTPUT_LONG1, ">" .$output_file6) or die "\nCan't open file $output_file6, $!\n";
				print OUTPUT_LONG1 $other_seq;
				
				close OUTPUT_LONG1;
				
				chomp($output_file6);
				
				$print_sep = $y."_".$id;
			
				#my $cmd = sprintf("blastn -query %s -subject %s -out blast_tmp3.txt -outfmt 4", $ref_file, $output_file1);
				#my $cmd = sprintf("blastn -query %s -subject %s -out blast_tmp3.txt -reward 1 -penalty -2 -gapopen 2 -gapextend 2 -outfmt 4", $ref_file, $output_file1);
				#my $cmd = sprintf("muscle -in %s -out blast_tmp3.txt -maxiters 1 -diags", $output_file1);
				my $cmd = "";
				
				if ($high_quality eq "yes")
				{
					$high_quality = "yes2";
					print {$filehandle{$seed_id2}} "HIGH_QUALITY_MAFFT\n";
					$cmd = sprintf("mafft --op 0.2 --thread 4 --quiet --clustalout --maxiterate 100 --globalpair %s > ".$TMP_directory."mafft_tmp_NP_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt", $output_file6);
				}
				elsif (keys %extensions > 2)
				{
					$cmd = sprintf("mafft --op 0.5 --thread 4 --quiet --clustalout %s > ".$TMP_directory."mafft_tmp_NP_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt", $output_file6);
				}
				else
				{
					$cmd = sprintf("mafft --op 1.01 --ep 1.2 --thread 4 --quiet --clustalout %s > ".$TMP_directory."mafft_tmp_NP_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt", $output_file6);
				}
				
				system($cmd);                         
				
				my $mafft_output_tmp = $TMP_directory."mafft_tmp_NP_".$project."_".$print_sep."_".$mismatch_retry."_".$high_quality."_".$mafft_count.".txt";
				#$mafft_output{$mafft_count} = $output_tmp;	
				$mafft_count++;
				
				my $time_maff3 = time;
                my $time_mafft = $time_maff3 - $time_mafft1;
                print {$filehandle{$seed_id2}} $time_mafft." TIME_MAFFT\n\n";
				sleep(0.05);

#merge mafft lines-------------------------------------------------------------------------------             

				my $e = '0';
                my $query_line = "";
                my %subject_list;
                undef %subject_list;
                my %subject_list_original;
				undef %subject_list_original;
                my $consensus_total = "";
                my %gaps_id;
                undef %gaps_id;
                my %length_id;
				undef %length_id;
                my $cp = '20';
               
				open(INPUT_BLAST3, $mafft_output_tmp) or print "\n\nCan't open blast file $mafft_output_tmp, $!\n";

				while (my $line2 = <INPUT_BLAST3>)
				{                                                     
					chomp($line2);
					if ($e > 2)
					{
						my @blast_result_tmp = split /\s+/, $line2;
						
						my $read_id_tmp = $blast_result_tmp[0];
						
						if (exists($subject_list{$read_id_tmp}))
						{
							my $subject_tmp = $subject_list{$read_id_tmp};
							$subject_list{$read_id_tmp} = $subject_tmp.$blast_result_tmp[1];
						}
						elsif ($read_id_tmp =~ m/\d+/)
						{                                   
							$subject_list{$read_id_tmp} = $blast_result_tmp[1];
						}
						if ($query_line eq "yes")
						{
							my $consensus = substr $line2, 16, 60;
							$consensus_total .= $consensus;
						}
						elsif ($read_id_tmp eq $total_nuc_count_original)
						{
							$query_line = "yes";
						} 
					}
					$e++
				}
				close INPUT_BLAST3;
                               
                my %gaps_align;
                undef %gaps_align;
                foreach my $subject_id (keys %subject_list)
                {
                    my $read_tmp = $subject_list{$subject_id};
                    my $o = '0';
                    my $first_nuc = substr $read_tmp, $o, 1;
                    while ($first_nuc eq "-" && $o < 120+($total_nuc_count_original*2))
                    {
                        $o++;
                        $first_nuc = substr $read_tmp, $o, 1;
                    }
                    if (exists($gaps_align{$o}))
                    {
                        my $count_tmp = $gaps_align{$o};
                        $gaps_align{$o} = $count_tmp+1;
                    }
                    else
                    {
                        $gaps_align{$o} = '1';
                    } 
                }
                my $count_align = keys %subject_list;
                my $oo = '1';
                my $cut_gap = '1';
                foreach my $gap_length (sort {$a <=> $b} keys %gaps_align)
                {
                    $oo += $gaps_align{$gap_length};
                    if ($oo > 0.45*$count_align)
                    {
                        $cut_gap = $gap_length;
                        last;
                    }                 
                }
                if ($cut_gap > $cp)
                {
                    $cp = $cut_gap;
                }
				if ($mafft_count > 2)
				{
					$cp = '0';
				}
				else
				{
					$cp_original = $cp;
				}
                print {$filehandle{$seed_id2}} $cp." SKIP_LENGTH\n";
                
                my $too_much_gaps = '0';
                foreach my $subject_id (keys %subject_list)
                {
                    my $read_tmp = $subject_list{$subject_id};
                    my $last_20 = substr $read_tmp, -20;
                    my $gaps_20 = $last_20 =~ tr/-/-/;
                    while ($gaps_20 > 15)
                    {
                        substr $read_tmp, -20, 20, "";
                        $last_20 = substr $read_tmp, -20;
                        $gaps_20 = $last_20 =~ tr/-/-/;
                    }
                    
                    my $last_nuc = substr $read_tmp, -1;
                    while ($last_nuc eq "-")
                    {
                        chop($read_tmp);
                        $last_nuc = substr $read_tmp, -1;
                    }
                    substr $read_tmp, -80, 80, "";
                    $subject_list{$subject_id} = $read_tmp;
                    
                    my $gaps_tmp = $read_tmp =~ tr/-/-/;
                    $gaps_id{$subject_id} = $gaps_tmp;
                    $length_id{$subject_id} = length($read_tmp)-5;
                    
                    #if ($gaps_tmp > 0.10*length($read_tmp))
                    #{
                        #$too_much_gaps++;
                    #}
                    #if ($too_much_gaps > 0.2*$matches_count && $mafft_extra_quality eq "")
                    #{
                        #$mafft_extra_quality = "yes";
                        #print {$filehandle{$seed_id2}} "TOO_MANY_GAPS_MAFFT_EXTRA_QUALITY\n";
                        #goto MAFFT_PB;
                    #}
                }

#check quality scores--------------------------------------------------------------------------------------------------
                my %quality_scores_reads;
                undef %quality_scores_reads;
                if ($use_quality_scores_NP ne "")
                {
					foreach my $subject_rank (keys %subject_list)
					{
						if (exists($rank_to_id{$subject_rank}))
						{
							my $id_tmpie5 = $rank_to_id{$subject_rank};
							if (exists($quality_scores_NP{$id_tmpie5}))
							{
								my @list_tmp = split /,/, $quality_scores_NP{$id_tmpie5};
								foreach my $pos_tmp (@list_tmp)
								{
									$quality_scores_reads{$subject_rank}{$pos_tmp} = undef;
								}
							}
						}
					}
				}	
#check quality scores--------------------------------------------------------------------------------------------------
				
				foreach my $subject_rank (keys %subject_list)
                {
                    $subject_list_original{$subject_rank} = $subject_list{$subject_rank};
                }
				
				unlink $mafft_output_tmp;
				unlink $output_file6;
				
                my %ignore_reads;			
                undef %ignore_reads;
IGNORE_REMOVED_READS_NP:

                my $ignored_reads_count = keys %ignore_reads;

                if (keys %ignore_reads > 0)
                {
                    undef %subject_list;
                    print {$filehandle{$seed_id2}} $ignored_reads_count." IGNORE_COUNT\n";
                    foreach my $subject_rank (keys %subject_list_original)
                    {
                        if (exists($ignore_reads{$subject_rank}))
                        {
                            print {$filehandle{$seed_id2}} $subject_rank." REMOVE_READ\n";
                            delete $subject_list_original{$subject_rank};
                        }
                        else
                        {
                            $subject_list{$subject_rank} = $subject_list_original{$subject_rank};
                        }
                    }
                    $cp = $cp_original;
					if ($mafft_count > 2)
					{
						$cp = '0';
					}
                }
                
				if ($mafft_count < 3)
				{
					$clipped_ext = "";
					$N = '0';
				}
                
				my $best_extension_part = "";
                my %nucs;
                undef %nucs;
                my %nucs_rej;
				undef %nucs_rej;

                my $total_nuc_count = '0';
                my $total_nuc_count_rej = '0';
				my $local_pattern_matches2 = '0';
                my $nuc1 = "";
				$unresolvable_NP = "";
				$split_contigs_NP = "";

                my $only_2_reads = "";
                if (keys %extensions2_tmp eq '2' && keys %subject_list eq '2')
                {
                    $only_2_reads = "yes";
                    print {$filehandle{$seed_id2}} "ONLY_2_READS\n";
                }
				
                my %track_length_ext;			
                undef %track_length_ext;
				my $end_this_mafft_part = "";
					
				if ($mafft_count < 3)
				{
					foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
					{				
						my $seq_rank1c = substr $subject_list{$subject_rank}, 0, $cp;
						$seq_rank1c =~ tr/-//d;
						$track_length_ext{$subject_rank} = length($seq_rank1c);
					}
				}
                
                my $time_BLAST3 = time;
                my $time9 = $time_BLAST3 - $time_maff3;
                print {$filehandle{$seed_id2}} $time9." TIME_pre_CONS\n\n";
				my $loop_check = "";
				my $NP_reads_support_SNR2 = "";
				my $check_N_correction = "";
			
				my $time_mafft_tmp1 = '0';
				my $time_mafft_tmp2 = '0';
				my $time_mafft_tmp2b = '0';
				my $SNR_ahead_count = '0';
				my %SNP_patterns_prev_match_for_split;
				undef %SNP_patterns_prev_match_for_split;

INPUT_MAFFT3_NP: while ((keys %subject_list > 2 || $only_2_reads eq "yes") && ((((keys %subject_list > 0.75*($total_nuc_count_original-$ignored_reads_count)) || length($best_extension) < $length_extension-500))
				        || (keys %subject_list > 0.65*($total_nuc_count_original-$ignored_reads_count) && keys %subject_list > 20 && keys %subject_list > $sequencing_depth_NP*0.6)
						|| keys %subject_list > ($total_nuc_count_original-1-$ignored_reads_count) || $clipped_ext ne "yes" 
                        || (keys %subject_list > 0.3*($total_nuc_count_original-$ignored_reads_count) && $longer_extension_for_repeat ne "" && keys %subject_list > 3))
                        && ($end_this_mafft_part eq "" || length($best_extension_part) < $length_extension_part-50))
                {
					$loop_check = "yes";
					my $time_tmp0 = time;
#clip_extension-------------------------------------------------------------------------------------------                                
                    if ($clipped_ext eq "")
					{
						$clipped_ext_pos{length($best_extension)} = $cp;
					}
					if (length($best_extension) > 14 && $clipped_ext eq "" && $find_haps_in_seed ne "yes" && $NP_reads_support_SNR2 eq "")
                    {
						my $check_start_assembly = substr $read, -length($best_extension), length($best_extension);
                        my $check_start_assembly2 = substr $read, -150;
						if ($NP_reads_support_SNR ne "")
						{
							$check_start_assembly2 = substr $read, -150, 146;
							$check_start_assembly = substr $read, -length($best_extension)-4, length($best_extension);
						}
                        my $check_start_assembly3 = $check_start_assembly2 =~ m/$check_start_assembly/;
                        if ($check_start_assembly3 > 1)
                        {
                            print {$filehandle{$seed_id2}} $check_start_assembly3." CLIP_ALERT\n";
                            goto SWITCH_CLIP_NP;
                        }
						if ($check_start_assembly eq $best_extension && $NP_reads_support_SNR ne "")
                        {
                            $NP_reads_support_SNR2 = $NP_reads_support_SNR;
							$NP_reads_support_SNR2 =~ tr/ACTGN/actgn/;
                        }
                        elsif ($check_start_assembly eq $best_extension)
                        {
                            $clipped_ext = "yes";
                        }
                        else
                        {
                            my $best_extension_tmp = $best_extension;
                            my $check_N = $best_extension_tmp =~ tr/N|\./\./;
                            my $check_N2 = $check_start_assembly =~ tr/N|\./\./;
                            if (($check_N > 0 || $check_N2 > 0) && $check_N < length($best_extension_tmp)*0.4 && $check_N2 < length($check_start_assembly)*0.4)
                            {
                                my $check_again = $check_start_assembly =~ s/$best_extension_tmp//;
                                my $check_again2 = $best_extension_tmp =~ s/$check_start_assembly//;
                                if ($check_again > 0 || $check_again2 > 0)
                                {
									if ($NP_reads_support_SNR ne "")
									{
										$NP_reads_support_SNR2 = $NP_reads_support_SNR;
										$NP_reads_support_SNR2 =~ tr/ACTGN/actgn/;
									}
									else
									{
										$clipped_ext = "yes";
									}
                                }
                            }
                        }
                        if ($clipped_ext eq "yes")
                        {
                            print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_EXACT_MATCH\n";
							$best_extension = "";
                            $N = '0';
                            undef %SNP_patterns_prev;
                            undef %extensions_seed;
                            undef %quality_scores_tmp;
                            undef %quality_scores_gap_tmp;
                            undef %extensions_seed;
                            undef %best_read_score;
							undef %total_count_prev_patterns;
                            $total_count_prev_patterns = '0';
                        }
                    }
                    if (length($best_extension) > 120 && $clipped_ext eq "" && $find_haps_in_seed ne "yes" && $NP_reads_support_SNR2 eq "")
                    {
                        my $m = '15';
						my $best_extension_tmp_length = length($best_extension);
                        while ($m < length($best_extension)-10 && $clipped_ext eq "")
                        {
                            my $check_start_assembly = substr $read, -$m, 15;
                            $check_start_assembly =~ tr/N|\./\./;
                            my $best_extension_tmp = $best_extension;
							
                            my $check_15 = $best_extension_tmp =~ s/$check_start_assembly//;
                            if ($check_15 eq 1)
                            {
                                print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_CLIP\n";
                                if ($best_extension =~ m/(.*$check_start_assembly)(.*)/)
                                {
                                    $best_extension = $2;
                                    my $best_extension_tmp = substr $best_extension, 0, $m-15+3;
                                    my $best_extension_tmp2 = substr $best_extension, $m-15+3;
                                    my $m2 = '14';
                                    my $matched = "";
                                    while ($m2 > 5 && $matched eq "" && $m > 15)
                                    {
                                        my $check_start_assembly2 = substr $read, -$m2, $m2;
										$check_start_assembly2 =~ tr/N|\./\./;
                                        if ($best_extension_tmp =~ m/(.*$check_start_assembly2)(.*)/)
                                        {
                                            $best_extension = $2;
                                            $best_extension .= $best_extension_tmp2;
                                            $matched = "yes";
                                            last
                                        }
										else
										{
											my $m3 = '0';
											while ($m3 < 8)
											{
												my $check_start_assembly3 = substr $best_extension_tmp, -$m2-$m3, $m2;
												$check_start_assembly3 =~ tr/N|\./\./;
												if ($check_start_assembly2 =~ m/$check_start_assembly3/)
												{
													$best_extension = "";
													if ($m3 > 0)
													{
														$best_extension = substr $best_extension_tmp, -$m3;
													}
													$best_extension .= $best_extension_tmp2;
													$matched = "yes";
													last
												}
												$m3++;
											}
										}
                                        $m2--;
                                    }
                                    if ($matched ne "yes" && $m > 15)
                                    {
                                        substr $best_extension, 0, $m-15, "";
										print {$filehandle{$seed_id2}} $m2." NO_EXACT_MATCH\n";
                                    }
                                    #my $M_seq = substr $best_extension, 0, $m-15, "";
                                    #$ext_remove = $1.$M_seq;
                                    #print {$filehandle{$seed_id2}} $ext_remove." EXT_REMOVE\n";   
                                }

                                print {$filehandle{$seed_id2}} $m." M\n";
                                print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_CHOPPED\n";
								my $diff_tmp = $best_extension_tmp_length-length($best_extension);
                                $clipped_ext = "yes";
								$cp = $clipped_ext_pos{$diff_tmp};
								foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
								{				
									my $seq_rank1c = substr $subject_list{$subject_rank}, 0, $cp;
									$seq_rank1c =~ tr/-//d;
									$track_length_ext{$subject_rank} = length($seq_rank1c);
								}
                            }
                            $m++;
                        }
                        if ($clipped_ext eq "yes")
                        {
                            $best_extension = "";
                            $N = '0';
                            undef %SNP_patterns_prev;
                            undef %extensions_seed;
                            undef %quality_scores_tmp;
                            undef %quality_scores_gap_tmp;
                            undef %extensions_seed;
                            undef %best_read_score;
							undef %total_count_prev_patterns;
                            $total_count_prev_patterns = '0';
							if ($find_haps_in_seed ne "")
							{
								$extensions_seed{'HAP1'} = $best_extension;
								$extensions_seed{'HAP2'} = $best_extension;
							}
                        }
                    }				
SWITCH_CLIP_NP:                     
#-------------------------------------------------------------------------------------------------------
                    undef %nucs;
                    undef %nucs_rej;
                    $total_nuc_count = '0';
                    $total_nuc_count_rej = '0';
                    $nuc1 = "";
                    my %track_mismatch_ext0;
                    undef %track_mismatch_ext0;
                    $track_mismatch_count++;
					$nucs{'a'} = '0';
					$nucs{'c'} = '0';
					$nucs{'t'} = '0';
					$nucs{'g'} = '0';
					$nucs{"-"} = '0';
					my $nuc_top10 = "";
					my %nucs_by_rank;
					undef %nucs_by_rank;
					my %split_patterns_final_score;
					undef %split_patterns_final_score;
					my $lowest_longest_match = "";
					my %longest_match;
					undef %longest_match;
					my %longest_match2;
					undef %longest_match2;
					my $VIP_position_check = "";

                    foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
                    {
                        my $nuc = substr $subject_list{$subject_rank}, $cp, 1;
						
						if ($NP_reads_support ne "yes" && $NP_reads_support ne "" && $clipped_ext eq "yes" && length($best_extension) < 1)
						{	
							if (exists($PB_split_nucs{$nuc}))
							{
							}
							elsif (exists($PB_split_nucs{'-'}))
							{
							}
							else
							{
								print {$filehandle{$seed_id2}} $subject_rank." ".$nuc." DELETE_RANK\n";
								#delete $subject_list{$subject_rank};
								#next;
							}
						}
					
						$nucs_by_rank{$subject_rank} = $nuc;
                        
                        if (($add_rejected_reads ne "" && $subject_rank > $add_rejected_reads) || ($add_no_match_reads ne "" && $subject_rank > $add_no_match_reads)
							|| ($add_rejected_and_no_match_reads ne "" && $subject_rank > $add_rejected_and_no_match_reads))
                        {
                            $nucs_rej{$nuc} += 1;
                            $total_nuc_count_rej++;
							
							if (length($best_extension) > 10)
							{
								if (exists($track_mismatch_ext0{$nuc}))
								{
									$track_mismatch_ext0{$nuc} .= ",".$subject_rank;
								}
								else
								{
									$track_mismatch_ext0{$nuc} = $subject_rank;
								}
							}
                        }
                        else
                        {
                            $nucs{$nuc} += 1;
                            $total_nuc_count++;
							if ($nuc_top10 eq "")
							{
								$nuc_top10 = $nuc;
							}
							elsif ($subject_rank < 11 && $nuc_top10 ne $nuc)
							{
								$nuc_top10 = "no";
							}
                        }
                        
                        if ($nuc ne "-")
                        {
                            $track_length_ext{$subject_rank} += 1;
                        }
						
						my $first_rank_tmp2 = "1";
						foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
						{
							$first_rank_tmp2 = $rank_tmp;
							last;
						}
                        
                        if ($subject_rank eq $first_rank_tmp2)
                        {
							$nuc1 = $nuc;
                            my $length_rank1_tmp = $track_length_ext_total{$subject_rank}+$track_length_ext{$subject_rank};
                            my $posiie = length($best_extension)+$position;
							my $read_end_tmpi = substr $best_extension, -$overlap;
							
							foreach my $length_rank1_tmp0 (keys %split_positions_DUP_tmp)
							{
								if ($length_rank1_tmp > $length_rank1_tmp0-15 && $length_rank1_tmp < $length_rank1_tmp0+15)
								{
									my $N_check = $read_end_tmpi =~ tr/N/N/;
									my $match_tmp = "";
									if ($N_check > 0)
									{
										my $read_end_tmpi_tmp = $read_end_tmpi;
										$read_end_tmpi_tmp =~ tr/N/\./;
										if ($split_positions_DUP_tmp{$length_rank1_tmp} =~ m/$read_end_tmpi_tmp/)
										{
											$match_tmp = "yes";
										}
									}
									if ($split_positions_DUP_tmp{$length_rank1_tmp} eq $read_end_tmpi || $match_tmp eq "yes")
									{
										print {$filehandle{$seed_id2}} $seed_id."\t".$posiie."\t".$length_rank1_tmp."\t".$split_positions_DUP_tmp{$length_rank1_tmp}." DUP_POS_TMP\n";				
										$split_positions_DUP{$seed_id}{$posiie} = $split_positions_DUP_tmp{$length_rank1_tmp};
										$split_positions_DUP2{$seed_id}{$posiie} = $split_positions_DUP_tmp2{$length_rank1_tmp};
										print {$filehandle{$seed_id2}} $read_end_tmpi." READ_END\n";
										my $selected_nuc_tmp = $split_positions_DUP_tmp2{$length_rank1_tmp};
										$selected_nuc_tmp =~ tr/actgn/ACTGN/;
										$split_positions_DUP{$seed_id}{$posiie} = $read_end_tmpi;
										$split_positions_DUP2{$seed_id}{$posiie} = $selected_nuc_tmp;
										if ($split_positions_DUP_tmp3{$length_rank1_tmp} eq "yes")
										{
											$split_positions{$seed_id}{$posiie} = $read_end_tmpi.",".$selected_nuc_tmp;
											$split_positions_VIP{$seed_id}{$posiie} = $read_end_tmpi.",".$selected_nuc_tmp;
											$VIP_position_check = "yes";
										}
									}
								}
							}
                        }
                        elsif ($nuc1 ne "" && (($add_rejected_reads eq "" && $add_no_match_reads eq "" && $add_rejected_and_no_match_reads eq "")
							  || (($add_rejected_reads ne "" && $subject_rank < $add_rejected_reads) || ($add_no_match_reads ne "" && $subject_rank < $add_no_match_reads)
							|| ($add_rejected_and_no_match_reads ne "" && $subject_rank < $add_rejected_and_no_match_reads))))
                        {
                            if ($nuc eq $nuc1)
                            {
                                if (exists($best_read_score{$subject_rank}))
                                {
                                    my $score_tmp = $best_read_score{$subject_rank}+2;
                                    $best_read_score{$subject_rank} = $score_tmp;
                                }
                                else
                                {
                                    $best_read_score{$subject_rank} = '2';
                                }  
                            }
                            else
                            {
                                if (exists($best_read_score{$subject_rank}))
                                {
                                    my $score_tmp = $best_read_score{$subject_rank}-1;
                                    $best_read_score{$subject_rank} = $score_tmp;
                                }
                                else
                                {
                                    $best_read_score{$subject_rank} = '-1';
                                }
                            }
                        }                        
                    }
					if ($total_nuc_count < $rank_count_check && $mismatches_tmp_check ne "")
					{
						$mismatches_tmp_check = "";                     
						$pos_pattern_list_check = "";
					}
						
					if ($NP_reads_support_SNR2 ne "" && $nucs{$NP_reads_support_SNR2}+$nucs{"-"} < 0.8*$total_nuc_count)
					{
						$N = '0';
						undef %SNP_patterns_prev;
						undef %extensions_seed;
						undef %quality_scores_tmp;
						undef %quality_scores_gap_tmp;
						undef %extensions_seed;
						undef %best_read_score;
						undef %total_count_prev_patterns;
						$total_count_prev_patterns = '0';
						$NP_reads_support_SNR2 = "";
						$clipped_ext = "yes";
						print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_NP_SUPPORT\n";
						$best_extension = "";
					}

#Remove rejected reads that don't align well----------------------------------------------------------------------------------------                    
                    if (($add_rejected_reads ne "" || $add_no_match_reads ne "" || $add_rejected_and_no_match_reads ne "") && length($best_extension) > 50)
                    #if ($add_rejected_reads eq "sghsh")
                    {
                        my $removed_reads = '0';
                        foreach my $nuc_5 (sort {$a <=> $b} keys %track_mismatch_ext0)
                        {
                            if ($nucs{$nuc_5} < $total_nuc_count*0.1)
                            {
                                my @track_mismatch_ext0 = split /,/, $track_mismatch_ext0{$nuc_5};
                                foreach my $rank_5 (@track_mismatch_ext0)
                                {
                                    #$track_mismatch_ext{$rank_5}{$track_mismatch_count} += 1;
                                    push @{ $track_mismatch_ext{$rank_5} }, $track_mismatch_count;
                                    my @rank_array = @{ $track_mismatch_ext{$rank_5} };
                                    my $array_count_tmp = @rank_array;
                                    my $threshold_tmp = 0.35*350;
                                    my $threshold_tmp_round = sprintf "%.0f", $threshold_tmp;
                                    
                                    if ($array_count_tmp > $threshold_tmp_round && $rank_array[$array_count_tmp-$threshold_tmp_round] > $track_mismatch_count-350)
                                    {
                                        foreach my $rank_6 (keys %track_mismatch_ext)
                                        {
                                            my @rank_array2 = @{ $track_mismatch_ext{$rank_6} };
                                            my $array_count_tmp2 = @rank_array2;
                                            my $threshold_tmp2 = 0.35*320;
                                            my $threshold_tmp_round2 = sprintf "%.0f", $threshold_tmp2;
                                            
                                            if ($array_count_tmp2 > $threshold_tmp_round2 && $rank_array2[$array_count_tmp2-$threshold_tmp_round2] > $track_mismatch_count-320)
                                            {
                                                print {$filehandle{$seed_id2}} $array_count_tmp2." ".$threshold_tmp_round2." ".$rank_6." REMOVE_BAD_ALIGNMENTS_REJ000\n";
												$removed_reads++;
                                                $ignore_reads{$rank_6} = undef;
                                                my $id_tmp0 = $rank_to_id{$rank_6};
                                                delete $extensions2_tmp{$id_tmp0};
                                                delete $extensions{$extensions2{$id_tmp0}};
                                                delete $extensions2{$id_tmp0};
												delete $extensions2_VIP{$id_tmp0};
                                                delete $extensions_nomatch{$extensions2{$id_tmp0}};
                                                delete $extensions_nomatch2{$id_tmp0};
                                                delete $extensions_unknown{$extensions2{$id_tmp0}};
                                                delete $extensions_unknown2{$id_tmp0};
                                                delete $save_reads_for_next{$id_tmp0};
                                                delete $add_rej_reads_extra{$id_tmp0};
                                                delete $read_start_pos_rej{$id_tmp0};
												delete $rejected_reads_save{$id_tmp0};
                                                $ext2_count = keys %extensions2_tmp;              
                                            }
                                        }
                                    }
                                }
                            }                           
                        }
                        if ($removed_reads > 0)
                        {
                            $best_extension = "";
							$best_extension_part = "";
                            $mismatch_retry++;
                            undef %quality_scores_tmp;
                            my $ignore_count_tmp = keys %ignore_reads;
                            
                            foreach my $rank_7 (keys %ignore_reads)
                            {
                                my $id_tmp0 = $rank_to_id{$rank_7};
                                delete $extensions2_tmp{$id_tmp0};
                                delete $extensions{$extensions2{$id_tmp0}};
                                delete $extensions2{$id_tmp0};
								delete $extensions2_VIP{$id_tmp0};
                                delete $extensions_nomatch{$extensions2{$id_tmp0}};
                                delete $extensions_nomatch2{$id_tmp0};
                                delete $extensions_unknown{$extensions2{$id_tmp0}};
                                delete $extensions_unknown2{$id_tmp0};
                                delete $save_reads_for_next{$id_tmp0};
                                delete $add_rej_reads_extra{$id_tmp0};
                                delete $read_start_pos_rej{$id_tmp0};
								delete $rejected_reads_save{$id_tmp0};
                                $ext2_count = keys %extensions2_tmp;
                            }
                            if ($removed_reads eq '1000000000000000000000000000000' && $ignore_count_tmp eq '1')
                            {
                                print {$filehandle{$seed_id2}} "REMOVE_BAD_ALIGNMENTS_REJ\n";                     
                                goto IGNORE_REMOVED_READS_NP;
                            }
							$remove_reads_check = "";
                            print {$filehandle{$seed_id2}} $removed_reads." REMOVE_BAD_ALIGNMENTS_REJ2\n";
                            goto SELECT_LENGTH_NP2;
                        }
                    }
#Check SNR ahead-------------------------------------------------------------------------------------------------------                   
                    $SNR_read_ahead = "";
					if ($nucs{"-"} > $total_nuc_count*0.15 && $nucs{"-"} < $total_nuc_count*0.9)
                    {                  
						my $count_SNR = '0';
						my $count_SNR2 = '0';
                        foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
                        {
                            my $p = '1';
                            my $p2 = '0';
							my %nucs_SNR;
							undef %nucs_SNR;
                            while ($p2 < 7 && $p < 30)
                            {
                                my $nuc2 = substr $subject_list{$subject_rank}, $cp+$p, 1;
                                if ($nuc2 ne "-")
                                {
                                    $nucs_SNR{$nuc2} += 1;
									$p2++;
                                }
                                $p++;
                            }
							my $check_tmp = "";
							foreach my $nuc_SNR_tmp (keys %nucs_SNR)
							{
								if ($nucs_SNR{$nuc_SNR_tmp} > 4)
								{
									$count_SNR++;
									$check_tmp = "yes";
								}
							}
							if ($check_tmp eq "" && $subject_rank < 4)
							{
								my $next_15 = "";
								my $p2b = '0';
								my $pb = '1';
								while ($p2b < 15 && $pb < 100)
								{
									my $nuc2 = substr $subject_list{$subject_rank}, $cp+$pb, 1;
									if ($nuc2 ne "-")
									{
										$next_15 .= $nuc2;
										$p2b++;
									}
									$pb++;
								}
								my $AT_rich_tmp = AT_rich_test ($next_15, '3');
								if ($AT_rich_tmp eq "yes")
								{
									$count_SNR2++;
								}
							}
                        }
                        if ($count_SNR > $total_nuc_count*0.7 || $count_SNR2 > 1)
                        {
                            $SNR_read_ahead = "yes";
							$SNR_ahead_count++;
                        }
						elsif (length($best_extension) > 25)
						{
							my $prev_25 = substr $best_extension, -25, 25;
							my $AT_rich_tmp = AT_rich_test ($prev_25, '5');
							if ($AT_rich_tmp eq "yes")
							{
								$SNR_read_ahead = "yes";
								$SNR_ahead_count++;
							}
						}
                    }
					if ($SNR_ahead_count > 10 && $extension_part_length eq '800' && length($best_extension) > 100)
					{
						my $prev_100 = substr $best_extension, -100, 100;
						my $AT_rich_tmp = AT_rich_test ($prev_100, '10');
						if ($AT_rich_tmp eq "yes")
						{
							$SNR_read_ahead = "yes";
							$extension_part_length = $length_extension;
							$mismatch_retry++;
							$best_extension = "";
							$best_extension_part = "";
							$remove_reads_check = "";
							undef %quality_scores_tmp;
							print {$filehandle{$seed_id2}} $length_extension." LONG_EXTENSION_REDO\n";
							goto SELECT_LENGTH_NP2;
						}
					}
                    if ($clipped_ext eq "yes")
                    {
                        #print {$filehandle{$seed_id2}} $nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                    }
#End NP assembly and return to PB---------------------------------------------------------------------------------------------------------------------------------------                                    
                    my $longest_seq_tmp = '0';
					foreach my $nuc_tmp (keys %PB_split_nucs)
					{
						if (length($nuc_tmp) > $longest_seq_tmp)
						{
							$longest_seq_tmp = length($nuc_tmp);
						}
					}
					
					if ($NP_reads_support ne "" && $clipped_ext eq "yes" && length($best_extension) > $longest_seq_tmp && (($nucs{"a"} < 0.8*$total_nuc_count &&
                      $nucs{"c"} < 0.8*$total_nuc_count && $nucs{"t"} < 0.8*$total_nuc_count && $nucs{"g"} < 0.8*$total_nuc_count && $nucs{"-"} < 0.8*$total_nuc_count) || ($NP_reads_support ne "yes" && $NP_reads_support ne "")))
                    {
                        my $w = '1';
                        my $low_score = "";
                        if ($repetitive_detect1 eq "yes")
                        {
                            $w = '20';
                        }
						
                        foreach my $pos_tmp (sort {$a <=> $b} keys %quality_scores_tmp)
                        {
                            my @q_score_tmp = split / /, $quality_scores_tmp{$pos_tmp};
							if ($q_score_tmp[0] < 0.8 && $w > $longest_seq_tmp)
                            {
                                $low_score = "yes";
                                last;
                            }
                            $w++;
                        }
                        if ($low_score eq "yes" || length($best_extension) <= 20)
                        {
                            my $best_extension_tmp = substr $best_extension, 0, $w;
                            $best_extension = $best_extension_tmp;
							$NP_reads_support_SNR = "";
                            print {$filehandle{$seed_id2}} $best_extension." LOW_SCORE_STOP\n";
                            my $one_match = "";
							my $first_nuc_tmp = substr $best_extension, 0, 1;
							foreach my $nuc_tmp (keys %PB_split_nucs)
                            {
								if (($nuc_tmp eq "-" || $nuc_tmp eq "") && $first_nuc_tmp ne "N" && $first_nuc_tmp ne "")
								{
									$read .= $best_extension;                                                 
									$position = length($read);
									$position{$id} = $position;
									$best_extension = "";
									$seed{$id} = $read;
									$skip_hap = "";
									$full_reset_NP = "";
									$full_reset_PB = "";
									goto AFTER_EXT2;
								}
							}
                            foreach my $nuc_tmp (keys %PB_split_nucs)
                            {
                                foreach my $seq_tmp (keys %{$PB_split_nucs{$nuc_tmp}})
								{
									print {$filehandle{$seed_id2}} $seq_tmp." SEQ_TMP\n";
									my $NP_seq = substr $best_extension, 0, length($seq_tmp);
									my $N_check = $NP_seq =~ tr/N/N/;
									if ($seq_tmp eq $NP_seq)
									{
										$one_match = "yes";
									}
									elsif ($NP_seq ne "N" && $N_check > 0)
									{
										my $NP_seq_tmp = $NP_seq;
										$NP_seq_tmp =~ tr/N/\./;
										if ($seq_tmp =~ m/$NP_seq_tmp/)
										{
											$one_match = "yes";
										}
									}
									elsif ($NP_seq ne "N" && ($N_check < 1 || $N_check eq ""))
									{
										my @ids_PB = split /,/, $PB_split_nucs{$nuc_tmp}{$seq_tmp};
										print {$filehandle{$seed_id2}} $PB_split_nucs{$nuc_tmp}{$seq_tmp}." EXCLUDE_PB\n";
										foreach my $id_PB (@ids_PB)
										{
											$exclude_reads_PB{$id}{$id_PB} = $position+7000;
											delete $PB_split_ids{$id_PB};
										}
									}
                                }
                            }
                            if ($one_match ne "yes")
                            {
                                delete $exclude_reads_PB{$seed_id};
                            }
							else
							{
								$best_extension = "";
								substr $read, -length($PB_extension), length($PB_extension), "";                                                 
								$position -= length($PB_extension);
								$position{$id} = $position;
								$seed{$id} = $read;
								goto PB_READS;
							}
                            goto END_NP;
                        } 
                    }
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					my $trace_back_check = "";
					if (keys %{$trace_back_split_NP{$id}} > 0)
					{
						my $min_pos = $position+length($best_extension)-50;
						
						foreach my $min_pos_tmp (keys %{$trace_back_split_NP{$id}})
						{
							if ($min_pos_tmp > $min_pos && $min_pos_tmp < $min_pos+100)
							{
								my $last_11 = substr $best_extension, -11, 11;
								my $last_11_prev = $trace_back_split_NP{$id}{$min_pos_tmp};
								my $N_check = $last_11_prev =~ tr/N/N/;
								my $N_check2 = $last_11 =~ tr/N/N/;
							
								if ($last_11 eq $last_11_prev)
								{			
									$trace_back_check = $min_pos_tmp;
									print {$filehandle{$seed_id2}} $trace_back_check." ".$last_11." TRACE_BACK_POSITION00!!!!!!!!!!!!!!!!\n";
								}
								elsif ($N_check > 0 || $N_check2 > 0)
								{
									$last_11_prev =~ tr/N/\./;
									if ($last_11 =~ m/$last_11_prev/)
									{
										$trace_back_check = $min_pos_tmp;
										print {$filehandle{$seed_id2}} $last_11_prev." ".$last_11." TRACE_BACK_POSITION000!!!!!!!!!!!!!!!!\n";
									}
									elsif ($last_11_prev =~ m/$last_11/)
									{
										$trace_back_check = $min_pos_tmp;
										print {$filehandle{$seed_id2}} $last_11_prev." ".$last_11." TRACE_BACK_POSITION000!!!!!!!!!!!!!!!!\n";
									}
								}
							}
						}
					}		
         
                    if ($nucs{"-"} < $total_nuc_count*0.2)
                    {
                        #$total_nuc_count -= $nucs{"-"};
                    }
					my $q_check = "";
ADD_QUALITY_NP:                  
                    if (($nucs{"a"} > $total_nuc_count*0.75 || ($nucs{"a"} > $total_nuc_count*0.49 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $only_2_reads eq "yes" && ($nuc1 eq 'a' || $nuc1 eq "-")))
                       && ($nucs{"a"} > $total_nuc_count*0.83 || $total_nuc_count < 15 || $count_matches_with_high_scores < $sequencing_depth_NP*2.4 || $nuc_top10 ne "no"
						   || ($nucs{"c"} < $total_nuc_count*0.19 && $nucs{"t"} < $total_nuc_count*0.19 && $nucs{"g"} < $total_nuc_count*0.19 && $nucs{"-"} < $total_nuc_count*0.2)))
                    {
                        $best_extension .= "A";
						$best_extension_part .= "A";
                        if ($total_nuc_count > 2)
                        {
                            $quality_scores_tmp{length($best_extension)} = ($nucs{"a"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        }
                        #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                        $nuc_match = "A";
                        goto SKIP_INPUT_BLAST3_NP;
                    }
                    elsif (($nucs{"c"} > $total_nuc_count*0.75 || ($nucs{"c"} > $total_nuc_count*0.49 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $only_2_reads eq "yes" && ($nuc1 eq 'c' || $nuc1 eq "-")))
                        && ($nucs{"c"} > $total_nuc_count*0.83 || $total_nuc_count < 15 || $count_matches_with_high_scores < $sequencing_depth_NP*2.4 || $nuc_top10 ne "no"
						|| ($nucs{"a"} < $total_nuc_count*0.19 && $nucs{"t"} < $total_nuc_count*0.19 && $nucs{"g"} < $total_nuc_count*0.19 && $nucs{"-"} < $total_nuc_count*0.2)))
                    {
                        $best_extension .= "C";
						$best_extension_part .= "C";
                        if ($total_nuc_count > 2)
                        {
                            $quality_scores_tmp{length($best_extension)} = ($nucs{"c"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        }
                        #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                        $nuc_match = "C";
                        goto SKIP_INPUT_BLAST3_NP;
                    }
                    elsif (($nucs{"t"} > $total_nuc_count*0.75 || ($nucs{"t"} > $total_nuc_count*0.49 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $only_2_reads eq "yes" && ($nuc1 eq 't' || $nuc1 eq "-")))
                          && ($nucs{"t"} > $total_nuc_count*0.83 || $total_nuc_count < 15 || $count_matches_with_high_scores < $sequencing_depth_NP*2.4 || $nuc_top10 ne "no"
						|| ($nucs{"c"} < $total_nuc_count*0.19 && $nucs{"a"} < $total_nuc_count*0.19 && $nucs{"g"} < $total_nuc_count*0.19 && $nucs{"-"} < $total_nuc_count*0.2)))
                    {
                        $best_extension .= "T";
						$best_extension_part .= "T";
                        if ($total_nuc_count > 2)
                        {
                            $quality_scores_tmp{length($best_extension)} = ($nucs{"t"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        }
                        #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                        $nuc_match = "T";
                        goto SKIP_INPUT_BLAST3_NP;
                    }
                    elsif (($nucs{"g"} > $total_nuc_count*0.75 || ($nucs{"g"} > $total_nuc_count*0.49 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $only_2_reads eq "yes" && ($nuc1 eq 'g' || $nuc1 eq "-")))
                        && ($nucs{"g"} > $total_nuc_count*0.83 || $total_nuc_count < 15 || $count_matches_with_high_scores < $sequencing_depth_NP*2.4 || $nuc_top10 ne "no"
					    || ($nucs{"c"} < $total_nuc_count*0.19 && $nucs{"t"} < $total_nuc_count*0.19 && $nucs{"a"} < $total_nuc_count*0.19 && $nucs{"-"} < $total_nuc_count*0.2)))
                    {
                        $best_extension .= "G";
						$best_extension_part .= "G";
                        if ($total_nuc_count > 2)
                        {
                            $quality_scores_tmp{length($best_extension)} = ($nucs{"g"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                        }
                        #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                        $nuc_match = "G";
                        goto SKIP_INPUT_BLAST3_NP;
                    }
                    elsif (($nucs{"-"} > $total_nuc_count*0.78 || ($nucs{"-"} > $total_nuc_count*0.49 && $nucs{"c"} < $total_nuc_count*0.25 && $nucs{"g"} < $total_nuc_count*0.25 &&
                         $nucs{"t"} < $total_nuc_count*0.25 && $nucs{"a"} < $total_nuc_count*0.25 && $PB_reads eq "" && $input_reads_DB_folder_PB eq "")) &&
						   ($nucs{"-"} > $total_nuc_count*0.83 || $total_nuc_count < 18 || $count_matches_with_high_scores < $sequencing_depth_NP*2.4 || $nuc_top10 ne "no"
						|| ($nucs{"c"} < $total_nuc_count*0.17 && $nucs{"t"} < $total_nuc_count*0.17 && $nucs{"g"} < $total_nuc_count*0.17 && $nucs{"a"} < $total_nuc_count*0.17)))
                    {
                        if ($nucs{"-"}/$total_nuc_count < 0.8)
						{
							$quality_scores_gap_tmp{length($best_extension)} = $nucs{"-"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
						}
						
                        $nuc_match = "";
                        goto SKIP_INPUT_BLAST3_NP;
                    }
					elsif ($use_quality_scores_NP ne "" && $add_rejected_reads eq "" && $add_no_match_reads eq "" && $add_rejected_and_no_match_reads eq "" && $q_check eq "")
					{
						my %nucs_original;
						undef %nucs_original;
						foreach my $nucs_tmpi (keys %nucs)
						{
							$nucs_original{$nucs_tmpi} = $nucs{$nucs_tmpi};
						}
						undef %nucs;
						$total_nuc_count = '0';
						
						foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
						{
							my $length_rank_tmp = $track_length_ext{$rank_tmp};
							if (exists($rank_to_id{$rank_tmp}))
							{
								my $id_tmp8 = $rank_to_id{$rank_tmp};
								if (exists($long_read_end_pos_save{$id_tmp8}))
								{
									my $total_length_rank_tmp = $track_length_ext{$rank_tmp}+$long_read_end_pos_save{$id_tmp8}-90;
									my $firstLine = $hash_NP_reads_tmp{$id_tmp8};
									if (exists($reverse_list{$id_tmp8}))
									{
										$total_length_rank_tmp = length($firstLine)-($track_length_ext{$rank_tmp}+$long_read_end_pos_save{$id_tmp8}-90);
									}
									my $nuc_tmp = substr $firstLine, $total_length_rank_tmp-10, 10;
									if (exists($reverse_list{$id_tmp8}))
									{
										$nuc_tmp = substr $firstLine, $total_length_rank_tmp, 10;
										my $nuc_tmp2 = reverse($nuc_tmp);
										$nuc_tmp2 =~ tr/ACTG/TGAC/;
										$nuc_tmp = $nuc_tmp2;
										#print {$filehandle{$seed_id2}} $rank_tmp." ID ".$nuc_tmp." NUC_REV\n";
									}
									else
									{
										#print {$filehandle{$seed_id2}} $rank_tmp." ID ".$nuc_tmp." NUC\n";
									}
									$total_length_rank_tmp++;
									
									if (exists($quality_scores_reads{$rank_tmp}{$total_length_rank_tmp}) || exists($quality_scores_reads{$rank_tmp}{$total_length_rank_tmp-1}) || exists($quality_scores_reads{$rank_tmp}{$total_length_rank_tmp+1}))
									{
										#print {$filehandle{$seed_id2}} $rank_tmp." ID ".$total_length_rank_tmp." POS\n";
										$q_check = "yes";
									}
									else
									{
										my $nuc_tmp2 = substr $subject_list{$rank_tmp}, $cp, 1;
										$nucs{$nuc_tmp2} += 1;
										$total_nuc_count++;
									}
								}
							}
						}
						my $check_error_pattern = "";
						foreach my $nucs_tmpi (keys %nucs)
						{
							if (exists($nucs_original{$nucs_tmpi}))
							{
								if ($nucs_original{$nucs_tmpi} > $total_nuc_count*0.3 && $nucs{$nucs_tmpi} > $nucs_original{$nucs_tmpi}*0.69)
								{
									$check_error_pattern = "yes";
								}
							}
						}
						if ($total_nuc_count < 5 || $check_error_pattern eq "")
						{
							undef %nucs;
							$total_nuc_count = '0';
							$q_check = "yes";
							
							foreach my $nucs_tmpi (keys %nucs_original)
							{
								$nucs{$nucs_tmpi} = $nucs_original{$nucs_tmpi};
								$total_nuc_count += $nucs_original{$nucs_tmpi};
							}
							goto ADD_QUALITY_NP;
						}
						if ($q_check eq "yes")
						{
							goto ADD_QUALITY_NP;
						}
					}
					
					if ($trace_back_check ne "" && $nucs{"-"} < $total_nuc_count*0.5)
					{
						my $count_SNR = '0';
						my $last_11_prev = $trace_back_split_NP{$id}{$trace_back_check};
						my $N_check = $last_11_prev =~ tr/N/N/;
                        foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
                        {
							my $p = '0';
							my $k = $trace_back_check-($position+length($best_extension));
                            while ($p < $k+65)
                            {
                                my $next_11 = "";
								my $p2b = '0';
								my $pb = '1';
								while ($p2b < 11 && $pb < 100)
								{
									my $nuc2 = substr $subject_list{$subject_rank}, $cp+$pb+$p, 1;
									if ($nuc2 ne "-")
									{
										$next_11 .= $nuc2;
										$p2b++;
									}
									$pb++;
								}
								
                                if ($next_11 eq $last_11_prev)
								{			
									$count_SNR++
								}
								elsif ($N_check > 0)
								{
									$last_11_prev =~ tr/N/\./;
									if ($next_11 =~ m/$last_11_prev/)
									{
										$count_SNR++
									}
								}
                                $p++;
                            }
						}
						if ($count_SNR < $total_nuc_count*0.2)
						{
							my $min_pos = $position+length($best_extension);
							if ($trace_back_check ne $min_pos)
							{
								my $diff = $min_pos-$trace_back_check;
								$trace_back_check += $diff;
								print {$filehandle{$seed_id2}} $diff." MAKE_POS_COR0\n";
								foreach my $pos_tmp (keys %{$trace_back_split_NP{$id}})
								{
									if ($pos_tmp >= $trace_back_check)
									{
										my $new_pos_tmp = $pos_tmp+$diff;
										$trace_back_split_NP{$id}{$new_pos_tmp} = $trace_back_split_NP{$id}{$pos_tmp};
										delete $trace_back_split_NP{$id}{$pos_tmp};
									}
								}
							}
						}
					}
#Remove_by_prev_split-----------------------------------------------------------------------------------------------                                                           					
					my $posiie0 = length($best_extension)+$position;
					my $first_rank_tmp2 = "1";
					foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
					{
						$first_rank_tmp2 = $rank_tmp;
						last;
					}
					my $pos_tmp2c = $track_length_ext_total{$first_rank_tmp2}+$track_length_ext{$first_rank_tmp2};
					
					if ((exists($split_positions_DUP{$seed_id}{$posiie0}) || exists($split_positions_DUP_tmp{$pos_tmp2c}))
						&& $add_rejected_reads eq "" && $add_no_match_reads eq "" && $add_rejected_and_no_match_reads eq "")
					{
						my $selected_nuc_tmp = "";
						if (exists($split_positions_DUP2{$posiie0}))
						{
							$selected_nuc_tmp = $split_positions_DUP2{$posiie0};
						}
						elsif (exists($split_positions_DUP_tmp2{$pos_tmp2c}))
						{
							$selected_nuc_tmp = $split_positions_DUP_tmp2{$pos_tmp2c};
						}
						print {$filehandle{$seed_id2}}  $selected_nuc_tmp." REMOVE_BY_DUP_POS00\n";
						
						if ($nucs{$selected_nuc_tmp} > 0.25*$total_nuc_count && ($nucs{'-'} > $total_nuc_count*0.3 || ($nucs{'-'}+$nucs{$selected_nuc_tmp}) < $total_nuc_count*0.84))
						{
							foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
							{
								my $nuc_tmp = $nucs_by_rank{$rank_tmp};
								if ($nuc_tmp ne $selected_nuc_tmp)
								{
									my $id_tmp0 = $rank_to_id{$rank_tmp};
									delete $extensions{$extensions2{$id_tmp0}};
									delete $extensions2{$id_tmp0};
									delete $extensions2b{$id_tmp0};
									delete $extensions2_tmp{$id_tmp0};
									delete $extensions_nomatch{$extensions2{$id_tmp0}};
									delete $extensions_nomatch2{$id_tmp0};
									delete $extensions_nomatch2b{$id_tmp0};
									delete $extensions_unknown{$extensions2{$id_tmp0}};
									delete $extensions_unknown2{$id_tmp0};
									delete $save_reads_for_next{$id_tmp0};
									delete $add_rej_reads_extra{$id_tmp0};
									delete $read_start_pos_rej{$id_tmp0};
									$ext2_count = keys %extensions2_tmp;
								}
							}
							print {$filehandle{$seed_id2}} $nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP ".$total_nuc_count." TOTAL0\n"; 
							 print {$filehandle{$seed_id2}} $best_extension."\nREMOVE_BY_DUP_POS\n";
													
							$mismatch_retry++;
							$best_extension = "";
							$best_extension_part = "";
							undef %quality_scores_tmp;
							goto MISMATCH_RETRY_NP;
						}
					}
                    
#Resolve ambigious positions through other haplotype----------------------------------------------------------------------------------------------                                   
                    if ($find_haps_in_seed eq "" && $ext2_count > 10000000 && $merged_ext ne "")
                    {
                        my $nuc_highest_tmp = "";
                        my $count_highest_tmp = '0';
						my $count_highest_VIP_tmp = '0';
						my $count_VIP = '0';
                        my $count_total_tmp = '0';
						my $count_total_VIP_tmp = '0';
						my $nuc_highest_VIP_tmp = "";
                        my %nuc_tmp2;
                        undef %nuc_tmp2;
						my %nuc_tmp2_VIP;
						undef %nuc_tmp2_VIP;

                        foreach my $ranki_tmp (sort {$a <=> $b} keys %subject_list)
                        {
                            if (exists($rank_to_id{$ranki_tmp}))
                            {
                                if (exists($extensions2{$rank_to_id{$ranki_tmp}}))
                                {
                                    my $nuc_tmp = $nucs_by_rank{$ranki_tmp};
                                    $nuc_tmp2{$nuc_tmp} += 1;
                                    if ($nuc_tmp2{$nuc_tmp} > $count_highest_tmp)
                                    {
                                        $count_highest_tmp = $nuc_tmp2{$nuc_tmp};
                                        $nuc_highest_tmp = $nuc_tmp;
                                    }
                                    $count_total_tmp++;
									if (exists($extensions2_VIP{$rank_to_id{$ranki_tmp}}))
									{
										$count_VIP++;
										$nuc_tmp2_VIP{$nuc_tmp} += 1;
										if ($nuc_tmp2_VIP{$nuc_tmp} > $count_highest_VIP_tmp)
										{
											$count_highest_VIP_tmp = $nuc_tmp2_VIP{$nuc_tmp};
											$nuc_highest_VIP_tmp = $nuc_tmp;
										}
										$count_total_VIP_tmp++;
									}
                                }
                            }
                        }
                        if (($nuc_highest_tmp ne "" && $count_highest_tmp > $count_total_tmp-2 && $count_highest_tmp > $count_total_tmp*0.9 && $count_highest_tmp > $total_nuc_count*0.3 && $count_highest_tmp > 4
							 && (($total_nuc_count > 12 && $total_nuc_count > $sequencing_depth_NP/1.8) || $count_highest_tmp > $total_nuc_count*0.68))
								|| ($trace_back_check ne "" && $count_highest_VIP_tmp > 2 && $count_VIP > 2 && $nuc_highest_VIP_tmp ne "" && $count_highest_VIP_tmp > $count_total_VIP_tmp*0.9))
                        {
                            $nuc_match = $nuc_highest_tmp;
							my $q_score = $count_highest_tmp/$count_total_tmp;
							if ($trace_back_check ne "" && $count_highest_VIP_tmp > 2 && $count_VIP > 2 && $nuc_highest_VIP_tmp ne "" && $count_highest_VIP_tmp > $count_total_VIP_tmp*0.85)
							{
								$nuc_match = $nuc_highest_VIP_tmp;
								$q_score = '1';
							}
	
                            $nuc_match =~ tr/actgn/ACTGN/;
                            if ($nuc_highest_tmp eq "-")
                            {
                                $nuc_match = "";
                            }
                            $best_extension .= $nuc_match;
							$best_extension_part .= $nuc_match;
							
							if ($nuc_match eq "" && $nucs{"-"} > 0)
                            {
								if ($nucs{"-"}/$count_total_tmp < 0.8)
								{
									$quality_scores_gap_tmp{length($best_extension)} = $nucs{"-"}/$count_total_tmp." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
								}
                            }
                            else
                            {
                                $quality_scores_tmp{length($best_extension)} = $q_score." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            
                            print {$filehandle{$seed_id2}} $total_nuc_count." TOTAL ".length($best_extension)." POS ".$nuc_match." N_CORRECTION\n";
							$total_count_prev_patterns{length($best_extension)} = undef;
							$check_N_correction = "yes";
                            goto SKIP_INPUT_BLAST3_NP
                        }
                    }     

					my $find_haps_in_seed_check = "";
					if ($find_haps_in_seed ne "" && ($nucs{"a"}+$nucs{"-"} > $total_nuc_count*0.7 || $nucs{"c"}+$nucs{"-"} > $total_nuc_count*0.7 || $nucs{"t"}+$nucs{"-"} > $total_nuc_count*0.7
						|| $nucs{"g"}+$nucs{"-"} > $total_nuc_count*0.7) && ($nucs{"-"} < $total_nuc_count*0.4 || $nucs{"-"} > $total_nuc_count*0.75))
					{
						$find_haps_in_seed_check = "no";
					}
					my $post_pattern_match_average_save = "";
					my $SNP_save = "";
					
					my $time_tmp0b = time;
					$time_mafft_tmp1 += ($time_tmp0b-$time_tmp0);
                                               
                    if (($clipped_ext ne "yes" || $best_extension eq "" || length($best_extension) < 1000 || $N < 5 || $N < length($best_extension)*0.08 ||
						 ($longer_extension_for_repeat ne "" && $N < length($best_extension)*0.1)) && $total_nuc_count > 5 && $find_haps_in_seed_check eq "" && $found_haps_in_seed eq "")
                    {
#Split into haplotype groups----------------------------------------------------------------------                                                           
						my $time_split = time;		
                        my %separate_haps_NP;
                        undef %separate_haps_NP;

print {$filehandle{$seed_id2}} "\n".length($best_extension)." SEP_HAP\n";
print {$filehandle{$seed_id2}} $nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP ".$total_nuc_count." TOTAL\n";                                    
                        my %SNP_patterns_now;
                        undef %SNP_patterns_now;
                        my %SNP_patterns_prev2;
						undef %SNP_patterns_prev2;
						my %SNP_patterns_prev_match;
						undef %SNP_patterns_prev_match;
						undef %SNP_patterns_prev_match_for_split;
						
                        my $current_pos_tmp = $position+length($best_extension);
                        my $selected_nuc = "";
						$total_count_prev_patterns{length($best_extension)} = undef;
						my $count_dup_pos_halle2 = '0';

                        my $first_rank = "";
                        foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
                        {
                            my $nuc_tmp = $nucs_by_rank{$rank_tmp};
                            $SNP_patterns_prev{$current_pos_tmp}{$nuc_tmp}{$rank_tmp} = undef;
                            $SNP_patterns_now{$nuc_tmp}{$rank_tmp} = undef;
                            if ($first_rank eq "")
                            {
                                $first_rank = $nuc_tmp;
                            }
                            #print {$filehandle{$seed_id2}} $rank_tmp." ".$nuc_tmp."\n";
                            
                            if (exists($separate_haps_NP{$nuc_tmp}))
                            {                  
                                my $c_tmp = $separate_haps_NP{$nuc_tmp};
                                $separate_haps_NP{$nuc_tmp} = $c_tmp+1;      
                            }
                            else
                            {
                                $separate_haps_NP{$nuc_tmp} = 1;                          
                            }  
                        }
                        my $SNP_check = "";
                        if ($nucs{"-"} < $total_nuc_count*0.18 || ($NP_reads_support ne "yes" && $NP_reads_support ne "" && $nucs{"-"} < $total_nuc_count*0.35))
                        {
                            $SNP_check = "yes";
                            my $count_nucs = '0';
                            foreach my $nuc_tmp1 (keys %nucs)
                            {
                                if ($nuc_tmp1 ne "-" && $nucs{$nuc_tmp1} > 3 && $nucs{$nuc_tmp1} > $total_nuc_count*0.26)
                                {
                                    $count_nucs++;
                                }
                            }
                            if ($count_nucs > 1)
                            {
                                $SNP_check = "yes2";
                            }
                        }
						$SNP_save = $SNP_check;
						
						if ($SNR_read_ahead ne "")
						{
							print {$filehandle{$seed_id2}} "\n".$SNR_read_ahead." SNR_READ_AHEAD\n";
						}

#Compare previous split positions of this extension-----------------------------------------------------------------------------------------------------------------------                        
     
                        my %post_SNP_patterns;  
                        undef %post_SNP_patterns;
						my %find_haps_SNPs;
						undef %find_haps_SNPs;
                        my $prev_pos_count = '0';
						my $local_pattern_matches = '0';
						$local_pattern_matches2 = '0';
                        
POST_SNP_PATTERNS_TMP_NP: foreach my $pos_tmp (sort {$a <=> $b} keys %SNP_patterns_prev)
                        {
                            my $fv = '0';
							if ($find_haps_in_seed ne "")
							{
								$fv = '5';
							}
							if ($pos_tmp ne $current_pos_tmp && $pos_tmp < $current_pos_tmp-$fv)
                            { 
                                my %post_SNP_patterns_tmp;
                                undef %post_SNP_patterns_tmp;
					#print {$filehandle{$seed_id2}} "\n".$pos_tmp." POS\n";
								my $total_prev_count = '0';
                                foreach my $nuc_tmp (keys %{$SNP_patterns_prev{$pos_tmp}})
                                {
								    foreach my $rank_tmp (keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_tmp}})
                                    {
										$total_prev_count++;
										foreach my $nuc_now_tmp2 (keys %SNP_patterns_now)
                                        {              
                                            if (exists($SNP_patterns_now{$nuc_now_tmp2}{$rank_tmp}))
                                            {   
												if (exists($post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp}))
                                                {
                                                    my $count_tmp = $post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp}+1;
                                                    $post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp} = $count_tmp;
                                                }
                                                else
                                                {
                                                    $post_SNP_patterns_tmp{$nuc_now_tmp2}{$nuc_tmp} = '1';
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                my $verified_tmp = "";
                                my %tmp_check_list;
                                undef %tmp_check_list;
								my $gap_count_tmp = keys %{$SNP_patterns_prev{$pos_tmp}{"-"}};
								
                               foreach my $nuc_now_tmp3 (keys %post_SNP_patterns_tmp)
                                {      
                                    my $count_nuc_now_tmp = '0';
									
									foreach my $nuc_prev_tmp3a (keys %{$post_SNP_patterns_tmp{$nuc_now_tmp3}})
                                    {
										if ($nuc_prev_tmp3a ne "-" || $gap_count_tmp > $total_prev_count*0.15)
										{
											$count_nuc_now_tmp += $post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3a}
										}
									}
									
                #print {$filehandle{$seed_id2}} $nuc_now_tmp3." NUC_NOW\n";
				
                                    if (($count_nuc_now_tmp > 2 || $total_nuc_count < 11) && $count_nuc_now_tmp > $total_nuc_count*0.11)
                                    {
                                        my $pipi = 0.8;
										if ($count_nuc_now_tmp < 13 || $total_nuc_count-$count_nuc_now_tmp < 13)
										{
											$pipi = '0.85';
										}	
										if ($count_nuc_now_tmp < 7 || $total_nuc_count-$count_nuc_now_tmp < 7)
										{
											$pipi = '0.9';
										}	
										if ($count_nuc_now_tmp < 5 || $total_nuc_count-$count_nuc_now_tmp < 5)
										{
											$pipi = '0.95';
										}										
										
										foreach my $nuc_prev_tmp3 (keys %{$post_SNP_patterns_tmp{$nuc_now_tmp3}})
                                        {
											my $count_nuc_prev_tmp = '0';
											
											foreach my $nuc_now_tmp3b (keys %post_SNP_patterns_tmp)
											{      
												if (exists($post_SNP_patterns_tmp{$nuc_now_tmp3b}{$nuc_prev_tmp3}))
												{
													if ($nuc_now_tmp3b ne "-" || $nucs{"-"} > $total_nuc_count*0.15)
													{
														$count_nuc_prev_tmp += $post_SNP_patterns_tmp{$nuc_now_tmp3b}{$nuc_prev_tmp3}
													}
												}
											}
									#print {$filehandle{$seed_id2}} $nuc_prev_tmp3." NUC_PREV\n";
				#print {$filehandle{$seed_id2}} $count_nuc_prev_tmp." NUC_PREV_RANK_COUNT\n";
				#print {$filehandle{$seed_id2}} $count_nuc_now_tmp." NUC_NOW_RANK_COUNT\n";
				#print {$filehandle{$seed_id2}} $post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3}." MATCHES\n";  	
											if ($post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3} > $count_nuc_now_tmp*$pipi && $post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3} > $count_nuc_prev_tmp*$pipi
												&& $count_nuc_now_tmp > $count_nuc_prev_tmp*0.75 && $count_nuc_prev_tmp > $count_nuc_now_tmp*0.75)
                                            {
                                                if (exists($tmp_check_list{$nuc_prev_tmp3}))
                                                {
                                                    next POST_SNP_PATTERNS_TMP_NP;
                                                }
                                                $tmp_check_list{$nuc_prev_tmp3} = undef;
												$find_haps_SNPs{$nuc_now_tmp3}{$pos_tmp} = $nuc_prev_tmp3;
												if ($verified_tmp eq "yes")
												{
													$verified_tmp = "yes2";
												}
												else
												{
													$verified_tmp = "yes";
												}
                                            }
                                            elsif ($post_SNP_patterns_tmp{$nuc_now_tmp3}{$nuc_prev_tmp3} < $total_nuc_count*0.15)
                                            {              
                                            }
                                            else
                                            {
                                                next POST_SNP_PATTERNS_TMP_NP;
                                            }
                                        }
                                    }
                                }
                                if ($verified_tmp eq "yes2")
                                {
                                    print {$filehandle{$seed_id2}} $pos_tmp." POS_MATCH\n";
									if ($pos_tmp > $current_pos_tmp-150)
									{
										$local_pattern_matches++;
										if ($pos_tmp > $current_pos_tmp-18)
										{
											$local_pattern_matches2++;
										}	
									}		
									
									my $one_tmp = "";
									my $two_tmp = "";
									foreach my $nuc_tmp (keys %{$SNP_patterns_prev{$pos_tmp}})
									{
										foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_tmp}})
										{
											if ($rank_tmp eq '1')
											{
												$one_tmp = $nuc_tmp;
											}
											if ($rank_tmp eq '2')
											{
												$two_tmp = $nuc_tmp;
											}
											$SNP_patterns_prev_match_for_split{$pos_tmp}{$nuc_tmp}{$rank_tmp} = undef;
										}
									}
									if ($one_tmp eq $two_tmp)
									{
										$SNP_patterns_prev_match{$pos_tmp} = $one_tmp;
									}
									
                                    foreach my $nuc_now_tmp4 (keys %SNP_patterns_now)
                                    {
										foreach my $rank_now_tmp4 (keys %{$SNP_patterns_now{$nuc_now_tmp4}})
                                        {
                                            foreach my $nuc_prev_tmp4 (keys %{$SNP_patterns_prev{$pos_tmp}})
                                            {    
												foreach my $rank_prev_tmp4 (keys %{$SNP_patterns_prev{$pos_tmp}{$nuc_prev_tmp4}})
                                                {
                                                    if ($rank_prev_tmp4 eq $rank_now_tmp4)
                                                    {
                                                        my $highest_count_tmp = '0';
                                                        my $highest_nuc_tmp = "";
														
                                                        foreach my $nuc_now_tmp5 (keys %post_SNP_patterns_tmp)
                                                        {                                                          
                                                            foreach my $nuc_prev_tmp5 (keys %{$post_SNP_patterns_tmp{$nuc_now_tmp5}})
                                                            {
                                                                if ($nuc_prev_tmp5 eq $nuc_prev_tmp4)
                                                                {
                                                                    my $count_tmp = $post_SNP_patterns_tmp{$nuc_now_tmp5}{$nuc_prev_tmp5};
                                                                    if ($count_tmp > $highest_count_tmp)
                                                                    {
                                                                        $highest_count_tmp = $count_tmp;
                                                                        $highest_nuc_tmp = $nuc_now_tmp5;
                                                                    } 
                                                                }
                                                            }
                                                        }
                                                        if ($highest_nuc_tmp ne "")
                                                        {
                                                            $post_SNP_patterns{$rank_now_tmp4}{$highest_nuc_tmp}{$pos_tmp} = $nuc_prev_tmp4;
                                                        }
                                                    }
                                                }	
                                            }
                                        }
                                    }
                                    $prev_pos_count++;
                                }
                            }
                        }
						
						
						my $time_split2 = time;
						
 #-----------------------------------------------------------------------------------------------------------------------                                    
                        my %split_patterns_final;
                        undef %split_patterns_final;
                        undef %split_patterns_final_score;

                        foreach my $rank_tmp6 (keys %post_SNP_patterns)
                        {                       
                            my $highest_count_tmp = '1';
                            my $highest_nuc_tmp = "";
                            foreach my $nuc_now_tmp6 (keys %{$post_SNP_patterns{$rank_tmp6}})
                            {
                                my $count_tmp = '0';
								foreach my $pos_tmp6 (keys %{$post_SNP_patterns{$rank_tmp6}{$nuc_now_tmp6}})
								{
									if ($post_SNP_patterns{$rank_tmp6}{$nuc_now_tmp6}{$pos_tmp6} eq "-" || $nuc_now_tmp6 eq "-")
									{									
										if ($find_haps_in_seed eq "")
										{
											$count_tmp += 0.6;
										}
										else
										{
											$count_tmp += 0.4;
										}
									}
									else
									{
										$count_tmp += 1;
									}
								}
								#my $count_tmp = keys %{$post_SNP_patterns{$rank_tmp6}{$nuc_now_tmp6}};
                                if ($count_tmp > $highest_count_tmp)
                                {
                                    $highest_count_tmp = $count_tmp;
                                    $highest_nuc_tmp = $nuc_now_tmp6;
                                }
                            }
							if ($highest_nuc_tmp eq "")
							{
								$highest_nuc_tmp = $nucs_by_rank{$rank_tmp6};
							}
                            $split_patterns_final{$rank_tmp6} = $highest_nuc_tmp;
                            $split_patterns_final_score{$highest_nuc_tmp}{$rank_tmp6} = $highest_count_tmp;
                        }
                        						
						if ($trace_back_check ne "" && $SNP_check eq "")
						{
							$trace_back_check = "";
						}				

                        if (keys %split_patterns_final eq '0' && ($SNP_check ne "" || $trace_back_check ne "" ||
							($NP_reads_support ne "yes" && $NP_reads_support ne "" && $clipped_ext eq "yes" && $best_extension eq "")))
                        {
                            print {$filehandle{$seed_id2}} $SNP_check." SNP_CHECK\n";
                            foreach my $rank_tmp4 (sort {$a <=> $b} keys %subject_list)
                            {
								my $nuc_tmp = $nucs_by_rank{$rank_tmp4};
                                $split_patterns_final{$rank_tmp4} = $nuc_tmp;
                                $split_patterns_final_score{$nuc_tmp}{$rank_tmp4} = '1';
                            }
                        }				
                  
                        my %reads_to_remove;               
                        undef %reads_to_remove;
                        my $remove_reads = "";
                        my %average_rank_score;
                        undef %average_rank_score;
						my $remove_by_rejected = "";
                                
                        $post_pattern_match = "";
                        my $post_pattern_match_extra = "";
                        my $post_pattern_match_average = "";
                        my $longest_longest_match = "";
                        my $longest_longest_match_nuc = "";
						undef %longest_match;
						undef %longest_match2;
						my $count_post_pattern_match3 = '0';
						my $find_haps_found = "";
                        
                        foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
                        {
                            print {$filehandle{$seed_id2}} $rank_tmp13." ".$nucs_by_rank{$rank_tmp13}." ".$split_patterns_final{$rank_tmp13}."\n";
                        }
						
						if ($NP_reads_support ne "yes" && $NP_reads_support ne "" && $clipped_ext eq "yes" && length($best_extension) < 1 && $SNP_check ne "")
						{	
							foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								if (exists($PB_split_nucs{$nuc_tmp13}))
								{}
								else
								{
									delete $split_patterns_final_score{$nuc_tmp13};
								}
							}
						}
						
#Remove by split positions---------------------------------------------------------------------------------------------------------------------------------------------------						
						my $posiie_tmp = length($best_extension)+$position;
						if (exists($split_positions_DUP2{$seed_id}{$posiie_tmp}) && $add_rejected_and_no_match_reads eq "")
						{
							my $nuc_DUP_tmp = $split_positions_DUP2{$seed_id}{$posiie_tmp};
							
							if ($nucs{$nuc_DUP_tmp} > $total_nuc_count*0.25)
							{
								my $first_rank_tmp = "";
								foreach my $nuc_tmp17 (sort {$a <=> $b} keys %split_patterns_final_score)
								{
									if ($nuc_tmp17 ne $nuc_DUP_tmp)
									{
										foreach my $rank_tmp17 (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp17}})
										{
											if ($first_rank_tmp eq "")
											{
												$first_rank_tmp = $rank_tmp17;
											}
											if (exists($rank_to_id{$rank_tmp17}))
											{
												my $id_tmp = $rank_to_id{$rank_tmp17};
												my $exclude_pos = $alignment_length_save{$id_tmp};
												if (length($read) < $alignment_length_save{$id_tmp})
												{
													$exclude_pos = length($read);
												}
												if ($length_ext_all{$id_tmp} > $exclude_pos && $alignment_length_save{$id_tmp} > 5000)
												{
													$exclude_pos = $length_ext_all{$id_tmp}*1.1;
												}
												if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "")
												{
													$exclude_reads_NP{$id}{$id_tmp} = $position+$exclude_pos;
												}
												$reads_to_remove{$first_rank_tmp}{$rank_tmp17} = undef;
												$remove_reads = "yes";
											}
										}
									}
								}
								if ($remove_reads eq "yes")
								{
									print {$filehandle{$seed_id2}} $split_positions_DUP{$seed_id}{$posiie_tmp}." DELETE_BY_SPLIT_POS\n";
									goto REMOVE_READS_NP;
								}
							}
						}

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------						

						my $CG_check = '0';
						my $count_splits = '0';
                        foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
                        {
                            my $rank_count_tmp = '0';
                            my $total_score_count_tmp = '0';
                            my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp13}};
							
                            foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
                            {
                                if (($rank_tmp13 <= $add_no_match_reads || $add_no_match_reads eq "") && ($rank_tmp13 <= $add_rejected_reads || $add_rejected_reads eq "")
									&& ($rank_tmp13 <= $add_rejected_and_no_match_reads || $add_rejected_and_no_match_reads eq ""))
								{
									$rank_count_tmp++;
									$total_score_count_tmp += $split_patterns_final_score{$nuc_tmp13}{$rank_tmp13};

									if (exists($rank_to_id{$rank_tmp13}) && $count_ranks_tmp > 0.14*$total_nuc_count)
									{
										my $id_tmp3 = $rank_to_id{$rank_tmp13};
										#print {$filehandle{$seed_id2}} $long_read_end_pos_save{$id_tmp3}." LONG_READ_END_TMP\n";
										if (exists($read_start_pos_rej{$id_tmp3}))
										{}
										elsif (exists($longest_match{$nuc_tmp13}))
										{
											if ($alignment_length_save{$id_tmp3} > $longest_match{$nuc_tmp13})
											{
												$longest_match{$nuc_tmp13} = $alignment_length_save{$id_tmp3};
											}
											$longest_match2{$nuc_tmp13}{$alignment_length_save{$id_tmp3}}{$id_tmp3} = undef;
										}
										else
										{
											$longest_match{$nuc_tmp13} = $alignment_length_save{$id_tmp3};
											$longest_match2{$nuc_tmp13}{$alignment_length_save{$id_tmp3}}{$id_tmp3} = undef;
										}
									}
								}
                            }
							$total_score_count_tmp *= ($rank_count_tmp/$total_nuc_count)*2;
                            print {$filehandle{$seed_id2}} $nuc_tmp13." ".$total_score_count_tmp." SCORE ".$rank_count_tmp." COUNT\n";
                            
                            #if ($confirmed_reads_count_NP > 4 && $skip_confirmed eq "" && $only_confirmed eq "yes" && $total_score_count_tmp/$total_count_tmp > 2 && $total_score_count_tmp/$total_count_tmp > $total_count_prev_patterns*0.2 && $total_count_tmp > 3)
                            #{
                                #$skip_confirmed = "yes";
                                #print {$filehandle{$seed_id2}} "SKIP_CONFIRMED2\n";
                                #$best_extension = "";
                                #goto SKIP_CONFIRMED_NP;
                            #}
							if ($rank_count_tmp > 0)
							{
#Split haplotypes in intial seed--------------------------------------------------------------------------------------------------						
								if ($find_haps_in_seed ne "" && $total_score_count_tmp/$rank_count_tmp >= 1.5 && keys %find_haps_SNPs eq $ploidy)
								{
									if ($find_haps_found eq "")
									{
										$find_haps_found = "ye";
									}
									else
									{
										$found_haps_in_seed = "yes";
										my $second_hap = "";
	
										foreach my $nucie_now_tmp2 (sort {$a <=> $b} keys %find_haps_SNPs)
										{
											print {$filehandle{$seed_id2}} $nucie_now_tmp2." NUC_NOW\n";
											foreach my $pos_tmp8 (sort {$b <=> $a} keys %{$find_haps_SNPs{$nucie_now_tmp2}})
											{
												print {$filehandle{$seed_id2}} $pos_tmp8." CONNECT_POS\n";
												my $nucie_prev_tmp2 = $find_haps_SNPs{$nucie_now_tmp2}{$pos_tmp8};
												$nucie_prev_tmp2 =~ tr/actgn/ACTGN/;
												$nucie_prev_tmp2 =~ tr/-//d;
												
												if ($second_hap eq "")
												{
			print {$filehandle{$seed_id2}} $nucie_prev_tmp2." NUC_PREV\n";
													my $read_tmp = $extensions_seed{"HAP1"};
									print {$filehandle{$seed_id2}} $read_tmp." EXT\n";	
													substr $read_tmp, $pos_tmp8-$position, 1, $nucie_prev_tmp2;
										print {$filehandle{$seed_id2}} $read_tmp." EXT\n";		
													$extensions_seed{"HAP1"} = $read_tmp;
												}
												else
												{
													print {$filehandle{$seed_id2}} $nucie_prev_tmp2." NUC_PREV\n";
													my $read_tmp = $extensions_seed{"HAP2"};
									print {$filehandle{$seed_id2}} $read_tmp." EXT\n";	
													substr $read_tmp, $pos_tmp8-$position, 1, $nucie_prev_tmp2;
										print {$filehandle{$seed_id2}} $read_tmp." EXT\n";		
													$extensions_seed{"HAP2"} = $read_tmp;
												}
											}
											$nucie_now_tmp2 =~ tr/actgn/ACTGN/;
											$nucie_now_tmp2 =~ tr/-//d;
											if ($second_hap eq "")
											{
												$extensions_seed{"HAP1"} .= $nucie_now_tmp2;
											}
											else
											{
												$extensions_seed{"HAP2"} .= $nucie_now_tmp2;
											}
											
											$second_hap = "yes";
										}
	
										$hap_position = "yes";
										$best_extension .= "N";
										$best_extension_part .= "N";
										$quality_scores_tmp{length($best_extension)} = '0'." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
										$nuc_match = "N";
										goto SKIP_INPUT_BLAST3_NP;
									}
								}
	#----------------------------------------------------------------------------------------------------------------------------------------------------			
								$total_count_prev_patterns = '0';
								foreach my $posie_tmpie (sort {$b <=> $a} keys %total_count_prev_patterns)
								{
									if ($posie_tmpie > length($best_extension)-150)
									{
										$total_count_prev_patterns++;
									}
								}
								my $total_count_prev_patterns_all = keys %total_count_prev_patterns;
						
								if (((keys %split_patterns_final > 0.88*$total_nuc_count && ($total_score_count_tmp/$rank_count_tmp > 1.5) && $total_score_count_tmp > 0
									&& ($total_count_prev_patterns < 30 || ($total_count_prev_patterns < 20 && $total_nuc_count > 5) || ($total_score_count_tmp/$rank_count_tmp > 10)
									|| ($local_pattern_matches2 > 5 && $total_nuc_count > 8 ))) || $SNP_check eq "yes2" || ($trace_back_check ne "" && $nuc_tmp13 ne "-"))
									&& $rank_count_tmp > $total_nuc_count*0.14 && (length($best_extension) > 15 || $clipped_ext ne "") && $total_nuc_count > 5)
								{            
									print {$filehandle{$seed_id2}} $total_count_prev_patterns." TOTAL_COUNT_PREV_PATTERNS\n";
									print {$filehandle{$seed_id2}} $total_count_prev_patterns_all." TOTAL_COUNT_PREV_PATTERNS_ALL\n";
									$count_splits++;
									if ($post_pattern_match eq "yes")
									{
										$post_pattern_match = "yes2";
									}
									elsif ($post_pattern_match eq "")
									{
										$post_pattern_match = "yes";
									}
									my $vv = '0.3';
									my $ll = '0.15';
									if ($rank_count_tmp < 4)
									{
										$vv = '0.35';
										$ll = '0.25';
									}
									if ($total_nuc_count > 8 && $rank_count_tmp > 4)
									{
										$vv = '0.25';
										$ll = '0.1';
									}
									if ((($total_count_prev_patterns < 12 && $total_count_prev_patterns_all < 25) || ($total_score_count_tmp/$rank_count_tmp > (($total_count_prev_patterns*$vv)+(10/$total_nuc_count)) &&
										 (($local_pattern_matches > 5 && $total_nuc_count > 10 && ($rank_count_tmp > $total_nuc_count*0.35 && $rank_count_tmp < $total_nuc_count*0.65))))
										 || ($total_score_count_tmp/$rank_count_tmp > (33+((10/$total_nuc_count)*10)) && $total_score_count_tmp/$rank_count_tmp > $total_count_prev_patterns_all*$ll)
										 || ($local_pattern_matches > 0.7*$total_count_prev_patterns && $local_pattern_matches > 5 && $total_nuc_count > 10)
										 || $local_pattern_matches2 > 4 || ($local_pattern_matches > 6 && $rank_count_tmp > 3 && $total_nuc_count > 10)) && ($rank_count_tmp > 2 || $prev_pos_count > $total_count_prev_patterns_all*0.25))
									{
										if ($post_pattern_match_average eq "yes")
										{
										}
										elsif ($post_pattern_match_average eq "ye")
										{
											$post_pattern_match_average = "yes";
										}
										else
										{
											$post_pattern_match_average = "ye";
											if ($total_score_count_tmp/$rank_count_tmp > (40+((10/$total_nuc_count)*10)) && $rank_count_tmp > 10 &&
											   (($local_pattern_matches > 0.68*$total_count_prev_patterns && $local_pattern_matches > 10 && $total_nuc_count > 10) ||($rank_count_tmp > $total_nuc_count*0.35 && $rank_count_tmp < $total_nuc_count*0.65)))
											{
												$post_pattern_match_average = "yes";
											}
										}
									}
									if ((($total_score_count_tmp/$rank_count_tmp > 1.6 && $SNP_check ne "") || $total_score_count_tmp/$rank_count_tmp > 10)
										&& (($rank_count_tmp > 3 && $rank_count_tmp < $total_nuc_count-3) || $total_score_count_tmp/$rank_count_tmp > 60) || ($local_pattern_matches2 > 5 && $total_nuc_count > 10))
									{
										if ($post_pattern_match_extra eq "yes")
										{
										}
										elsif ($post_pattern_match_extra eq "ye")
										{
											$post_pattern_match_extra = "yes";
										}
										else
										{
											$post_pattern_match_extra = "ye";
											if ($total_score_count_tmp/$rank_count_tmp > (40+((10/$total_nuc_count)*10)) && $rank_count_tmp > 10 &&
											   (($local_pattern_matches > 0.68*$total_count_prev_patterns && $local_pattern_matches > 10 && $total_nuc_count > 10) ||($rank_count_tmp > $total_nuc_count*0.35 && $rank_count_tmp < $total_nuc_count*0.65)))
											{
												$post_pattern_match_extra = "yes";
											}
										}
										
										if ($first_split_pos eq "")
										{
											$first_split_pos = length($best_extension);
										}
									}
									print {$filehandle{$seed_id2}} $post_pattern_match_extra." POST_PATTERN_MATCH_EXTRA\n";
									print {$filehandle{$seed_id2}} $post_pattern_match_average." POST_PATTERN_MATCH_AVERAGE\n";
									
#Multi_match removal-------------------------------------------------------------------
									if ($total_nuc_count > 15 && $post_pattern_match_extra eq "yes" && $post_pattern_match_average eq "yes" || ($NP_reads_support ne "yes" && $NP_reads_support ne "" && $clipped_ext eq "yes" && length($best_extension) < 2 && $SNP_check ne ""))
									{
										my $count_multi_match_tmp = '0';
										my $first_no_multi_match = "";
										my %gap_list_tmp;
										undef %gap_list_tmp;
										
										foreach my $rank_tmp5 (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp13}})
										{  
											if (exists($rank_to_id{$rank_tmp5}))
											{
												my $id_tmp = $rank_to_id{$rank_tmp5};
												if (exists($multi_match{$id_tmp}))
												{
													$count_multi_match_tmp++;
													foreach my $gap_pos_tmp (sort {$a <=> $b} keys %{$multi_match{$id_tmp}})
													{
														if (exists($gap_list_tmp{$gap_pos_tmp}))
														{
															$gap_list_tmp{$gap_pos_tmp} += 1;
														}
														else
														{
															$gap_list_tmp{$gap_pos_tmp} = '1';
														}  
													}
												}
												elsif ($first_no_multi_match eq "")
												{
													$first_no_multi_match = $rank_tmp5;
												}
												else
												{
													last;
												}
											}
										}
										my $gap_pos_prev = "";
										my $count_tmp = '0';
										my $max_count_tmp = '0';
										my $max_count_pos_tmp = '0';
										foreach my $gap_pos_tmp (sort {$a <=> $b} keys %gap_list_tmp)
										{
											if ($gap_pos_prev eq "")
											{
												$count_tmp = $gap_list_tmp{$gap_pos_tmp};
											}
											elsif ($gap_pos_tmp < $gap_pos_prev+350)
											{
												$count_tmp += $gap_list_tmp{$gap_pos_tmp};
												if ($count_tmp > $max_count_tmp)
												{
													$max_count_tmp = $count_tmp;
													$max_count_pos_tmp = $gap_pos_tmp;
												}
											}
											else
											{
												$count_tmp = $gap_list_tmp{$gap_pos_tmp};
											}
											$gap_pos_prev = $gap_pos_tmp;
										}
										
										if (($first_no_multi_match eq "" || $first_no_multi_match > 10) && $max_count_tmp > 1
											&& $post_pattern_match_extra eq "yes" && $max_count_tmp > 1 && $max_count_tmp > $count_multi_match_tmp*0.8)
										{
											my $gap_region_tmp = substr $read, $max_count_pos_tmp-150, 900;
											my $N_count_tmp = $gap_region_tmp =~ tr/N/N/;
											
											my $first_rank_tmp = "";
											if ($N_count_tmp < 60)
											{
												foreach my $rank_tmp5 (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp13}})
												{
													if ($first_rank_tmp eq "")
													{
														$first_rank_tmp = $rank_tmp5;
													}
													if (exists($rank_to_id{$rank_tmp5}))
													{
														my $id_tmp = $rank_to_id{$rank_tmp5};
														my $exclude_pos = $alignment_length_save{$id_tmp};
														if (length($read) < $alignment_length_save{$id_tmp})
														{
															$exclude_pos = length($read);
														}
														if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "111")
														{
															$exclude_reads_NP{$id}{$id_tmp} = $position+$exclude_pos;
														}
														$reads_to_remove{$first_rank_tmp}{$rank_tmp5} = undef;
														$remove_reads = "yes";
													}
												}
											}
											if ($remove_reads eq "yes")
											{
												print {$filehandle{$seed_id2}} $first_no_multi_match." MULTI_MATCH_PATTERN\n";
												goto REMOVE_READS_NP;
											}
										}
									}
									print {$filehandle{$seed_id2}} $longest_match{$nuc_tmp13}." LONGEST_MATCH\n";
										
									if (($longest_longest_match eq "" || ($longest_match{$nuc_tmp13} > $longest_longest_match && $rank_count_tmp > $total_nuc_count*0.2)) && $nuc_tmp13 ne "" && $nucs{$nuc_tmp13} > $total_nuc_count*0.22)
									{
										$longest_longest_match = $longest_match{$nuc_tmp13};
										$longest_longest_match_nuc = $nuc_tmp13;
									}
#---------------------------------------------------------------------------------------------
									if ($post_pattern_match_extra ne "" && $post_pattern_match_save eq "yes" && $total_score_count_tmp/$rank_count_tmp > 3 && $post_pattern_match_average ne "" &&
										($total_score_count_tmp/$rank_count_tmp > 10 || ($SNP_check eq "yes2" && $total_count_prev_patterns < 25)))
									{
										$count_post_pattern_match3++;
									}
									if ($post_pattern_match_extra eq "yes" && $post_pattern_match_save eq "yes" && $total_score_count_tmp/$rank_count_tmp > 3 && $post_pattern_match_average eq "yes" &&
										($total_score_count_tmp/$rank_count_tmp > 10 || ($SNP_check eq "yes2" && $total_count_prev_patterns < 25)))
									{                                    
										if ($post_pattern_match_save eq "yes" && $post_pattern_match_average eq "yes" && ($total_count_prev_patterns < 20 || $rank_count_tmp > 6 || $total_score_count_tmp/$rank_count_tmp > 25))
										{
											my $best_extension_part_tmp = substr $best_extension, -1000;
											my $CG = $best_extension_part_tmp =~ tr/CGN/CGN/;
											if ($CG > 0.52*(length($best_extension_part_tmp)) && $total_score_count_tmp/$rank_count_tmp < (10+(10/$total_nuc_count)) && $total_count_prev_patterns > 15)
											{
												$post_pattern_match = "yes2";
												$CG_check++;
											}
											else
											{
												$post_pattern_match = "yes3";
											}
										}
									}
									$post_pattern_match_save = "yes";
								}
                            }
							else
							{
								delete $split_patterns_final_score{$nuc_tmp13};
							}
                        }
						if ($CG_check > 0 && $post_pattern_match ne "" && $count_post_pattern_match3-$CG_check < 2)
						{
							$post_pattern_match = "yes";
							print {$filehandle{$seed_id2}} $post_pattern_match." POST_PATTERN_MATCH_CG\n";
						}
						if ($count_post_pattern_match3 < 2 && $post_pattern_match eq "yes3")
						{
							$post_pattern_match = "yes2";
						}						
						
						
						if (($local_pattern_matches2 > 6 || ($local_pattern_matches > 15 && $total_nuc_count > 10) || ($local_pattern_matches2 > 4 && $post_pattern_match_extra eq "yes"  && $post_pattern_match_average eq "yes" && $total_nuc_count > 15))
							&& ($SNR_read_ahead eq "" || $local_pattern_matches2 > 12) && ($SNP_check ne "" || $local_pattern_matches2 > 7) && $count_splits > 1)
						{
							$post_pattern_match = "yes3";
							$post_pattern_match_average = "yes";
							$post_pattern_match_extra = "yes";
							print {$filehandle{$seed_id2}} $post_pattern_match." POST_PATTERN_MATCH2\n";
						}
						if ($post_pattern_match eq "yes3")
						{
							$post_pattern_match_count++;
						}
						
						if (($trace_back_check ne "" && ($SNP_check ne "" || $post_pattern_match_average ne "" || $post_pattern_match_extra ne ""))
							|| ($NP_reads_support ne "yes" && $NP_reads_support ne "" && $clipped_ext eq "yes" && length($best_extension) < 2 && $SNP_check ne "") && $count_splits > 1)
						{	
							$post_pattern_match = "yes3";
							$post_pattern_match_average = "yes";
							$post_pattern_match_extra = "yes";
							print {$filehandle{$seed_id2}} $post_pattern_match." POST_PATTERN_MATCH1\n";
						}
						
						if (length($best_extension) < 50 && $halle5 eq "yes" && $post_pattern_match eq "yes3")
						{
							$post_pattern_match = "yes";
						}
						
						if ($post_pattern_match ne "")
						{
							print {$filehandle{$seed_id2}} $post_pattern_match." POST_PATTERN_MATCH\n";
						}
						
						if ($post_pattern_match eq "yes3" && $total_nuc_count < 12 && $ext2_count < 12 && $merged_ext eq "" && $added_unknown eq "")
						{
							my $unknown_count = keys %extensions_unknown2;
							if ($unknown_count > 0)
							{
								$added_unknown = "yes";
							}
						}
                        
						my $min_pos = $position+length($best_extension)-30;
						my $track_check = "";
						if ($nucs{"-"} < 0.25*$total_nuc_count)
						{
							foreach my $min_pos_tmp (keys %{$track_split_NP{$id}})
							{
								if ($min_pos_tmp > $min_pos && $min_pos_tmp < $min_pos+60)
								{
									my $last_11 = substr $best_extension, -11, 11;
									my @last_11_prev = split /\+/, $track_split_NP{$id}{$min_pos_tmp};
									my $last_11_prev = $last_11_prev[0];
									my $N_check = $last_11_prev =~ tr/N/N/;
	
									print {$filehandle{$seed_id2}} $last_11_prev." ".$last_11." TRACK_POSITION!!!!!!!!!!!!!!!!\n";
									if ($last_11 eq $last_11_prev)
									{			
										$track_check = $last_11_prev[1];
									}
									elsif ($N_check > 0)
									{
										$last_11_prev =~ tr/N/\./;
										if ($last_11 =~ m/$last_11_prev/)
										{
											$track_check = $last_11_prev[1];
										}
									}
								}
							}
							if ($track_check ne "")
							{
								foreach my $nuc_tmp15 (sort {$a <=> $b} keys %split_patterns_final_score)
								{
									if ($nuc_tmp15 ne $track_check)
									{
										foreach my $rank_tmp15 (keys %{$split_patterns_final_score{$nuc_tmp15}})
										{
											if ($rank_tmp15 > 5)
											{
												$reads_to_remove{$rank_tmp15}{$rank_tmp15} = undef;
											}
										}
									}
								}
								$remove_reads = "yes";
								print {$filehandle{$seed_id2}} $track_check." REMOVE_BY_TRACK_BACK\n";
								goto REMOVE_READS_NP;
							}
						}
						
#--------------------------------------------------------------------------------------------------------------------------						
                        if ($mismatches_tmp_check eq "" && $find_haps_in_seed eq "" && ($post_pattern_match_extra eq "yes" || $SNP_check eq "yes2" || $post_pattern_match eq "yes3"))
                        {
                            $mismatches_tmp_check = "yes";
							$rank_count_check = $total_nuc_count;
                        
							foreach my $rank_tmp (keys %split_patterns_final)
							{
								if (exists($rank_to_id{$rank_tmp}))
								{
									my $id_tmp = $rank_to_id{$rank_tmp};
									if (exists($store_mismatches_NP{$id_tmp}))
									{
										foreach my $posie (keys %{$store_mismatches_NP{$id_tmp}})
										{
											if ($add_no_match_reads eq "" || $rank_tmp <= $add_no_match_reads || $position-$posie < $add_rejected_reads_low_longest)
											{
												$mismatches_tmp{$posie}{$rank_tmp} = $store_mismatches_NP{$id_tmp}{$posie};
											}
										}
									}
									if (exists($store_mismatches_all_NP{$id_tmp}))
									{
										#foreach my $posie (keys %{$store_mismatches_all_NP{$id_tmp}})
										#{
											#if ($posie > 70)
											#{
												#$mismatches_tmp_all{$posie}{$rank_tmp} = $store_mismatches_all_NP{$id_tmp}{$posie};
											#}
										#}
									}
								}
							}   

							foreach my $posie (sort {$a <=> $b} keys %mismatches_tmp)
							{          
								my $count_mm_tmp = keys %{$mismatches_tmp{$posie}};
	
								if (($count_mm_tmp > 2 || ($total_nuc_count < 10 && $count_mm_tmp > 1)) && $count_mm_tmp > $total_nuc_count*0.07)
								{                                    
									my $count_below_10 = '0';
									my $ii = '1';
									while ($ii < 10)
									{
										if (exists($mismatches_tmp{$posie}{$ii}))
										{
											$count_below_10++;
										}
										$ii++;
									}
									
									if ($count_below_10 < 10)
									{
										foreach my $rank_tmp (keys %{$mismatches_tmp{$posie}})
										{
											$reads_mismatch{$rank_tmp}{$posie} = undef;
											$reads_mismatchb{$posie}{$rank_tmp} = undef;
										}
									}
								}
							}
                        
							foreach my $posie (sort {$a <=> $b} keys %mismatches_tmp_all)
							{          
								my $count_mm_tmp = keys %{$mismatches_tmp_all{$posie}};
	
								if (($count_mm_tmp > 2 || ($total_nuc_count < 10 && $count_mm_tmp > 1)) && $count_mm_tmp > $total_nuc_count*0.07)
								{                                    
									my $count_below_8 = '0';
									my $ii = '1';
									while ($ii < 8)
									{
										if (exists($mismatches_tmp_all{$posie}{$ii}))
										{
											$count_below_8++;
										}
										$ii++;
									}
									
									if ($count_below_8 < 8)
									{
										$mismatch_score_all++;
										foreach my $rank_tmp (keys %{$mismatches_tmp_all{$posie}})
										{
											$reads_mismatch_all{$rank_tmp}{$posie} = undef;
											$reads_mismatchb_all{$posie}{$rank_tmp} = undef;
										}
									}
								}
							}
                        
							foreach my $rank_tmp2 (sort {$a <=> $b} keys %reads_mismatch)
							{
								foreach my $posie_tmp2 (sort {$a <=> $b} keys %{$reads_mismatch{$rank_tmp2}})
								{
									foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatchb{$posie_tmp2}})
									{
										if ($rank_tmp3 ne $rank_tmp2)
										{
											if (exists($reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}))
											{
												$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}{$posie_tmp2} = undef;
											}
											elsif (exists($reads_mismatch2_tmp{$rank_tmp3}{$rank_tmp2}))
											{
												$reads_mismatch2_tmp{$rank_tmp3}{$rank_tmp2}{$posie_tmp2} =undef;
											}
											else
											{
												$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}{$posie_tmp2} = undef;
											}
										}
									}
								}
							}
							foreach my $rank_tmp2 (sort {$a <=> $b} keys %reads_mismatch2_tmp)
							{
								foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp{$rank_tmp2}})
								{
									my $count_tmp = keys %{$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}};
									if ($count_tmp > 2 || ($total_nuc_count < 10 && $count_tmp > 1))
									{  
										foreach my $posie_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}})
										{
											$reads_mismatch2{$count_tmp}{$rank_tmp2}{$rank_tmp3}{$posie_tmp3} = undef;
										}
									}
									else
									{
										foreach my $posie_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp{$rank_tmp2}{$rank_tmp3}})
										{
											my $count_tmp2 = keys %{$reads_mismatchb{$posie_tmp3}};
											if ($count_tmp2 > 3 && $count_tmp2 > $total_nuc_count*0.15)
											{
												$reads_mismatch2{$count_tmp}{$rank_tmp2}{$rank_tmp3}{$posie_tmp3} = undef;
											} 
										}
									}
								}
							}
							
							foreach my $rank_tmp2 (sort {$a <=> $b} keys %reads_mismatch_all)
							{
								foreach my $posie_tmp2 (sort {$a <=> $b} keys %{$reads_mismatch_all{$rank_tmp2}})
								{
									foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatchb_all{$posie_tmp2}})
									{
										if ($rank_tmp3 ne $rank_tmp2)
										{
											if (exists($reads_mismatch2_tmp_all{$rank_tmp2}{$rank_tmp3}))
											{
												$reads_mismatch2_tmp_all{$rank_tmp2}{$rank_tmp3}{$posie_tmp2} = undef;
											}
											elsif (exists($reads_mismatch2_tmp_all{$rank_tmp3}{$rank_tmp2}))
											{
												$reads_mismatch2_tmp_all{$rank_tmp3}{$rank_tmp2}{$posie_tmp2} =undef;
											}
											else
											{
												$reads_mismatch2_tmp_all{$rank_tmp2}{$rank_tmp3}{$posie_tmp2} = undef;
											}
										}
									}
								}
							}
							foreach my $rank_tmp2 (sort {$a <=> $b} keys %reads_mismatch2_tmp_all)
							{
								foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp_all{$rank_tmp2}})
								{
									my $count_tmp = keys %{$reads_mismatch2_tmp_all{$rank_tmp2}{$rank_tmp3}};
									if ($count_tmp > 2 || ($total_nuc_count < 10 && $count_tmp > 1))
									{  
										foreach my $posie_tmp3 (sort {$a <=> $b} keys %{$reads_mismatch2_tmp_all{$rank_tmp2}{$rank_tmp3}})
										{
											$reads_mismatch2_all{$count_tmp}{$rank_tmp2}{$rank_tmp3}{$posie_tmp3} = undef;
										}
									}
								}
							}
							print {$filehandle{$seed_id2}} $mismatch_score_all." MISMATCH_SCORE_ALL\n";
						}
#--------------------------------------------------------------------------------------------------------------------------     

                        my %pos_list_number;
                        undef %pos_list_number;
                        my $SNP_pattern_average = '0';
                        my $SNP_pattern_average_tmp = '0';
						my $high_score_save = "";
						my $add_all_patterns_save = "";
						my $first_no_match_save = "";
						my $highest_first_no_match = "";
						my $highest_count_matches = "";
						my $highest_count_no_matches = "";
						$post_pattern_match_average_save = $post_pattern_match_average;
                            
                        if (($post_pattern_match_extra eq "yes" || $SNP_check eq "yes2" || $post_pattern_match eq "yes3") && $find_haps_in_seed eq "")
                        {                             
                            foreach my $rank_tmp (sort {$a <=> $b} keys %reads_mismatch)
                            {
                                my $pos_list = "";
                                my %post_SNP_matching_score;
                                undef %post_SNP_matching_score;
                                my $pos_list_number = '0';
                                
                                foreach my $posie_tmp (sort {$a <=> $b} keys %{$reads_mismatch{$rank_tmp}})
                                {                               
                                    if (exists($split_patterns_final{$rank_tmp}))
                                    {
                                        my $nuc_tmp18 = $split_patterns_final{$rank_tmp};
                                        if (exists($post_SNP_matching_score{$nuc_tmp18}))
                                        {
                                            my $count_tmp = $post_SNP_matching_score{$nuc_tmp18};
                                            $post_SNP_matching_score{$nuc_tmp18} = $count_tmp+1;
                                        }
                                        else
                                        {
                                            $post_SNP_matching_score{$nuc_tmp18} = '1';
                                        }                            
                                    }
                                    #print {$filehandle{$seed_id2}} $posie_tmp." POS ".$reads_mismatch{$rank_tmp}{$posie_tmp}."\n";
                                    if ($pos_list eq "")
                                    {
                                        $pos_list = $posie_tmp;
                                        $pos_list_number++;
                                    }
                                    else
                                    {
                                        $pos_list .= ";".$posie_tmp;
                                        $pos_list_number++;
                                    }
                                }
                                $pos_list_number{$rank_tmp} = $pos_list_number;
                                my $length_match_tmp = '1000';
                                if (exists($rank_to_id{$rank_tmp}))
                                {
                                    my $id_tmpi = $rank_to_id{$rank_tmp};
									if (exists($alignment_length_save{$id_tmpi}))
									{
										$length_match_tmp = $alignment_length_save{$id_tmpi};
									}
                                    if ($length_match_tmp > $position-$original_seed_length{$id} && $assembly_refine eq "")
                                    {
                                        $length_match_tmp -= $original_seed_length{$id} - ($position-$length_match_tmp);
                                    }
                                }
                                $SNP_pattern_average_tmp += $pos_list_number/$length_match_tmp;
                                
                                if ($pos_pattern_list_check eq "")
								{
									print {$filehandle{$seed_id2}} $rank_tmp." RANK\n";
									print {$filehandle{$seed_id2}} $pos_list."\n";
								}
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------                                                                
                                my $total_pattern_count = keys %{$reads_mismatch{$rank_tmp}};
                                foreach my $nuc_tmp19 (keys %post_SNP_matching_score)
                                {
                                    if ($post_SNP_matching_score{$nuc_tmp19} > 0.8*$total_pattern_count)
                                    {
                                        if (exists($SNP_patterns_prev2{$nuc_tmp19}))
                                        {
                                            my $count_tmp = $SNP_patterns_prev2{$nuc_tmp19};
                                            $SNP_patterns_prev2{$nuc_tmp19} = $count_tmp+1;
                                        }
                                        else
                                        {
                                            $SNP_patterns_prev2{$nuc_tmp19} = '1';
                                        }
										if ($pos_pattern_list_check eq "")
										{
											print {$filehandle{$seed_id2}} $nuc_tmp19." PATTERN_MATCH\n";
										}
                                    }
                                }               
                            }
                            
                            $SNP_pattern_average = $SNP_pattern_average_tmp/$total_nuc_count;                           
#------------------------------------------------------------------------------------------------------------------------
                            if ($pos_pattern_list_check eq "" && $find_haps_in_seed eq "" && ($post_pattern_match_extra eq "yes" || $SNP_check eq "yes2" || $post_pattern_match eq "yes3"))
                            {
                                $pos_pattern_list_check = "yes";
								
								print {$filehandle{$seed_id2}} $SNP_pattern_average." SNP_PATTERN_AVERAGE\n";
								
                                my $count_patterns = '0';
								foreach my $count_tmp (sort {$b <=> $a} keys %reads_mismatch2)
								{
									my %pos_pattern_list_tmp;
									undef %pos_pattern_list_tmp;
									my %pos_pattern_list_out_of_range;
									undef %pos_pattern_list_out_of_range;
									
	 #print {$filehandle{$seed_id2}} "\n".$count_tmp." COUNT\n";
									foreach my $rank_tmp (sort {$a <=> $b} keys %{$reads_mismatch2{$count_tmp}})
									{
										my %read_patterns2_tmp;
										undef %read_patterns2_tmp;
										$read_patterns2_tmp{$rank_tmp} = undef;
						#print {$filehandle{$seed_id2}} $rank_tmp." RANK1\n";                
										foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$reads_mismatch2{$count_tmp}{$rank_tmp}})
										{
											$read_patterns2_tmp{$rank_tmp2} = undef;
											
											foreach my $posie_tmp (sort {$a <=> $b} keys %{$reads_mismatch2{$count_tmp}{$rank_tmp}{$rank_tmp2}})
											{
												$pos_pattern_list_tmp{$posie_tmp} = '2';
												 #print {$filehandle{$seed_id2}} $posie_tmp." POSIE\n";
											}
									#print {$filehandle{$seed_id2}} $rank_tmp2." RANK2\n";
HIGHEST_RANK_NP:											
											my $highest_score_rank = '0';
											my $highest_rank_tmp = "";
											my %pos_pattern_list_tmp2;
											undef %pos_pattern_list_tmp2;
											my %pos_pattern_list_tmp3;
											undef %pos_pattern_list_tmp3;
											
											my $highest_pos_score_tmp = '0';
											
											foreach my $posie_tmp (sort {$a <=> $b} keys %pos_pattern_list_tmp)
											{
												if ($pos_pattern_list_tmp{$posie_tmp} > $highest_pos_score_tmp)
												{
													$highest_pos_score_tmp = $pos_pattern_list_tmp{$posie_tmp};
												}
											}
											my $fi = '0.65';
											if (keys %read_patterns2_tmp eq '2')
											{
												$fi = '0.45';
											}
											foreach my $rank_tmp3 (sort {$b <=> $a} keys %reads_mismatch)
											{
												my $match_tmp = '0';
												my $match_tmp2 = '0';
												my $no_match_tmp = '0';
												my $count_tmp_new = '0';

												if (exists($read_patterns2_tmp{$rank_tmp3}))
												{
												}
												else
												{
													foreach my $posie_tmp (sort {$a <=> $b} keys %pos_pattern_list_tmp)
													{
														if ($pos_pattern_list_tmp{$posie_tmp} > $highest_pos_score_tmp*$fi)
														{
															if (exists($rank_to_id{$rank_tmp3}))
															{
																my $id_tmpi = $rank_to_id{$rank_tmp3};
																if (exists($alignment_length_save{$id_tmpi}))
																{
																	my $overlap_tmp = $alignment_length_save{$id_tmpi};
																	$count_tmp_new++;
																	if ($posie_tmp > $position-$overlap_tmp)
																	{                                
																		if (exists($store_mismatches_NP{$id_tmpi}{$posie_tmp}))
																		{
																			$match_tmp++;
																			$pos_pattern_list_tmp2{$rank_tmp3}{$posie_tmp} = '1';
																		}
																		elsif (exists($store_mismatches_all_NP{$id_tmpi}{$posie_tmp}))
																		{
																			$pos_pattern_list_tmp2{$rank_tmp3}{$posie_tmp} = '0.5';
																			$match_tmp2++;
																		}
																		else
																		{
																			$no_match_tmp++;
																			$pos_pattern_list_tmp2{$rank_tmp3}{$posie_tmp} = '-0.5';
																		}
																	}
																	else
																	{
																		$pos_pattern_list_tmp3{$rank_tmp3}{$posie_tmp} = '1';
																	}
																}
															}
														}
													}
												}
												
												if ($match_tmp > 0 && $no_match_tmp < ($match_tmp+$match_tmp2)*0.2 && $no_match_tmp < 0.2*$count_tmp_new &&
													(($match_tmp+$match_tmp2) > $count_tmp_new*0.5 || ($match_tmp > 3 && ($match_tmp+$match_tmp2) > $count_tmp_new*0.2) && $highest_pos_score_tmp < 3))
												{
													if ($match_tmp+$match_tmp2 > $highest_score_rank)
													{
														$highest_score_rank = $match_tmp+$match_tmp2;
														$highest_rank_tmp = $rank_tmp3;
													}
												}
											}
											if ($highest_rank_tmp ne "")
											{
												$read_patterns2_tmp{$highest_rank_tmp} = undef;
												foreach my $posie_tmp3 (keys %{$pos_pattern_list_tmp2{$highest_rank_tmp}})
												{
													$pos_pattern_list_tmp{$posie_tmp3} += $pos_pattern_list_tmp2{$highest_rank_tmp}{$posie_tmp3};
													
												}
												foreach my $posie_tmp3 (keys %{$pos_pattern_list_tmp3{$highest_rank_tmp}})
												{
													$pos_pattern_list_out_of_range{$posie_tmp3} += $pos_pattern_list_tmp3{$highest_rank_tmp}{$posie_tmp3};
												}
												
												###CHECKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK DELETED							
												goto HIGHEST_RANK_NP;
											}
											
											my $highest_pos_list = '0';
											foreach my $posie_tmp5 (keys %pos_pattern_list_tmp)
											{
												if ($pos_pattern_list_tmp{$posie_tmp5} > $highest_pos_list)
												{
													$highest_pos_list = $pos_pattern_list_tmp{$posie_tmp5};
												}
											}
											my $total_score_tmp = '0';
											foreach my $posie_tmp5 (keys %pos_pattern_list_tmp)
											{
												if ($pos_pattern_list_tmp{$posie_tmp5} > 1 && ($pos_pattern_list_tmp{$posie_tmp5} > $highest_pos_list*0.5 ||
												   ($pos_pattern_list_tmp{$posie_tmp5} > 3 && $pos_pattern_list_tmp{$posie_tmp5} > $total_nuc_count*0.1))
													&& $pos_pattern_list_tmp{$posie_tmp5}+$pos_pattern_list_out_of_range{$posie_tmp5} > $highest_pos_list*0.7)
												{
													$total_score_tmp += $pos_pattern_list_tmp{$posie_tmp5};
												}
												else
												{
													delete $pos_pattern_list_tmp{$posie_tmp5};
												}
											}
											
											my $final_score_tmp = $total_score_tmp/($total_nuc_count*0.25);
											
											if ($final_score_tmp > 1)
											{
												$count_patterns++;
												my $first_rank_tmp = "";
												foreach my $rank_tmp6 (sort {$a <=> $b} keys %read_patterns2_tmp)
												{
													$read_patterns2{$final_score_tmp}{$count_patterns}{$rank_tmp6} = $count_tmp;
													if ($first_rank_tmp eq "")
													{
														$first_rank_tmp = $rank_tmp6;
													}
												}
												foreach my $pos_tmp6 (sort {$a <=> $b} keys %pos_pattern_list_tmp)
												{
													$pos_pattern_list{$final_score_tmp}{$first_rank_tmp}{$pos_tmp6} = undef;
												}
											}
											
											undef %pos_pattern_list_tmp;
											undef %pos_pattern_list_out_of_range;
											undef %read_patterns2_tmp;
											$read_patterns2_tmp{$rank_tmp} = undef;
										}
									}                                     
								}
								foreach my $score_tmp5 (sort {$b <=> $a} keys %read_patterns2)
								{
                                 	foreach my $pattern_number (sort {$a <=> $b} keys %{$read_patterns2{$score_tmp5}})
									{
										my $first = "";
										my $count_ranks = keys %{$read_patterns2{$score_tmp5}{$pattern_number}};
										if (($count_ranks < 3 && $total_nuc_count > 10 ) || $count_ranks < 2)
										{}
										else
										{
											foreach my $rank_tmp7 (sort {$a <=> $b} keys %{$read_patterns2{$score_tmp5}{$pattern_number}})
											{
												$first = $rank_tmp7;
												my $count_pos_tmp = keys %{$reads_mismatch{$rank_tmp7}};
												last;
											}
											foreach my $rank_tmp8 (sort {$a <=> $b} keys %{$read_patterns2{$score_tmp5}{$pattern_number}})
											{
												if ($rank_tmp8 ne $first)
												{
													$read_patterns_final{$score_tmp5}{$first}{$rank_tmp8} = undef;
												}
											}
										}
									}
								}
							}
                            
#-----------------------------------------------------------------------------------------------------------------------------------------------
                           
                            my $highest_avg_score = "";
							my $highest_avg_score2 = "";
                            my $highest_rank_count = "";
                            my $highest_high_score_count = "";
							my $highest_count_matches = "";
                            my $current_score = "";
                            my $current_rank = "";
							my $selected_patterns_count = '0';
                            my %first_no_match;
                            undef %first_no_match;
                            my $score_diff = "";
                            my %highest_avg_score;
                            undef %highest_avg_score;
							my $score_gap = "";
							my %pattern_list;
							undef %pattern_list;
							my %rank_patterns;
							undef %rank_patterns;
							
							foreach my $score_tmp (sort {$b <=> $a} keys %read_patterns_final)
                            {
								foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                {
									if (exists($split_patterns_final{$rank_tmp}))
									{
									}
									else
									{
										my $first_rank_tmp = "";
										foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
										{
											$first_rank_tmp = $rank_tmp2;
										}
										foreach my $rank_tmp3 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
										{
											if ($rank_tmp3 ne $first_rank_tmp)
											{
												$read_patterns_final{$score_tmp}{$first_rank_tmp}{$rank_tmp3} = undef;
											}
										}
										delete $read_patterns_final{$score_tmp}{$rank_tmp};
									}
									foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
									{
										if (exists($split_patterns_final{$rank_tmp2}))
										{
										}
										else
										{
											delete $read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp2};
										}
									}  
								}
							}
                            
                            foreach my $score_tmp (sort {$b <=> $a} keys %read_patterns_final)
                            {       
								if ($highest_avg_score eq "")
                                {
                                    $highest_avg_score = $score_tmp;
                                    foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                    {
                                        $highest_avg_score{$rank_tmp} = undef;
                                        foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
                                        {
                                            $highest_avg_score{$rank_tmp2} = undef;
                                        }   
                                    }
                                }
                                elsif ($score_tmp > 0.65*$highest_avg_score)
                                {
                                    foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                    {
                                        if (exists($highest_avg_score{$rank_tmp}))
                                        {}
                                        else
                                        {
                                           $score_diff = "no"; 
                                        }
                                        foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
                                        {
                                            if (exists($highest_avg_score{$rank_tmp2}))
                                            {}
                                            else
                                            {
                                               $score_diff = "no"; 
                                            }
                                        }   
                                    }
                                }
                                
                                foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
                                {
                                    my $pattern_print = $rank_tmp.";";
                                    my $rank_count_tmp = '1';
                                    my $high_score_count_tmp = '0';
									                                    
                                    if ($rank_tmp <= 4)
                                    {
                                        $high_score_count_tmp++;
                                    }
                                    foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
                                    {
										$pattern_print .= $rank_tmp2.";";
                                        $rank_count_tmp++;
                                        if ($rank_tmp2 <= 4)
                                        {
                                            $high_score_count_tmp++;
                                        }
                                    }
                                    if ($highest_rank_count eq "")
                                    {
                                        $highest_rank_count = $rank_count_tmp;
                                    }
                                    if ($highest_high_score_count eq "")
                                    {
                                        $highest_high_score_count = $high_score_count_tmp;
                                    }
                                    
#match split pattern with SNP pattern------------------------------------------------------------------                                    
                                    my $count_matches_tmp = '0';
                                    my $count_total_tmp = '0';
                                    my $first_no_match = "";				
                                    my $nuc_match = $split_patterns_final{$rank_tmp};

                                    foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
                                    {
                                        if ($split_patterns_final{$rank_tmp13} eq $nuc_match)
                                        {
                                            if ($rank_tmp eq $rank_tmp13)
                                            {
                                                $count_matches_tmp++;
                                            }
                                            elsif (exists($read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp13}))
                                            {
                                                $count_matches_tmp++;
                                            }
                                            else
                                            {
                                                $count_total_tmp++;
                                                if ($first_no_match eq "")
                                                {
                                                    $first_no_match = $rank_tmp13;
                                                }
                                            }
                                        }
                                        elsif (exists($read_patterns_final{$score_tmp}{$rank_tmp}{$rank_tmp13}))
                                        {
                                            if ($first_no_match eq "")
                                            {
                                                $first_no_match = $rank_tmp13;
                                            }
                                        }
                                    }
                                    if ($first_no_match eq "" && keys %split_patterns_final > 0.8*$total_nuc_count)
                                    {
                                        $first_no_match = $total_nuc_count;
                                    }
									if ($highest_count_matches eq "")
									{
										$highest_count_matches = $count_matches_tmp;
									}
									
									if (exists($pattern_list{$pattern_print}))
									{	
									}
									elsif ($rank_count_tmp > 1)
									{
										if ($highest_first_no_match eq "" || $score_tmp > $highest_avg_score*0.85)
										{
											$selected_patterns_count++;
										}
										
										print {$filehandle{$seed_id2}} $pattern_print." PATTERN ".$score_tmp." SCORE ".$rank_count_tmp." RANK_COUNT ".$count_matches_tmp." COUNT_MATCHES ".$first_no_match." FIRST_NO_MATCH\n";
										
										if (($count_matches_tmp > 2 || $score_tmp > $highest_avg_score*0.95) 
											&& (($score_tmp > $highest_avg_score*0.85)
											|| (($score_tmp > $highest_avg_score*0.45 || ($score_tmp > 10 && $rank_count_tmp > 4 && $highest_rank_count < 4)) && $score_tmp > 4 && $first_no_match >= $highest_first_no_match && $rank_count_tmp > $highest_rank_count && $count_matches_tmp > $highest_count_matches)
											|| ($score_tmp > $highest_avg_score*0.7 && $post_pattern_match_extra eq "yes" && $rank_count_tmp > $highest_rank_count)
											|| ($post_pattern_match eq "yes3" && $score_tmp > 1 && $count_matches_tmp > $highest_count_matches && $first_no_match >= $highest_first_no_match && $score_tmp > $highest_avg_score*0.3))
											&& ($count_matches_tmp > 1 || $highest_first_no_match eq "" || ($score_tmp > 10 && $rank_count_tmp > 3))
											&& ($score_tmp > 3)
											&& ($first_no_match > $highest_first_no_match-3 || $highest_first_no_match eq "" || ($first_no_match >= $highest_first_no_match && $rank_count_tmp > $highest_rank_count)))
										{
											$highest_first_no_match = $first_no_match;
											$first_no_match{$score_tmp}{$rank_tmp}{$first_no_match} = undef;
											$rank_patterns{$score_tmp} = $rank_count_tmp." ".$first_no_match." ".$count_matches_tmp;
											print {$filehandle{$seed_id2}} "SELECT\n";
										}													

										if ($score_gap eq "" && $highest_avg_score2 ne "")
										{
											$score_gap = $highest_avg_score-$score_tmp;
										}
										if ($highest_avg_score2 eq "")
										{
											$highest_avg_score2 = $score_tmp;
										}
										$pattern_list{$pattern_print} = undef;
									}
                                }
                            }
							
							my %check_ranks;						
							undef %check_ranks;
                            foreach my $score_tmp2 (sort {$b <=> $a} keys %first_no_match)
                            {
                                if ($score_tmp2 > 5)
                                {
                                    foreach my $rank_tmp2 (keys %{$first_no_match{$score_tmp2}})
                                    {
                                        if ($rank_tmp2 < 11)
                                        {
                                            $check_ranks{$rank_tmp2} = undef;
                                        }
                                    }
                                }
                            }
                            if (keys %check_ranks > 7)
                            {
                                print {$filehandle{$seed_id2}} "\n\n".length($best_extension)." TERMINATE_CONFLICTING_MISMATCHES\n\n";
                                $best_extension = "";
                                goto AFTER_EXT;
                            }
							
							my $first_rank_tmp = "1";
							my %new_pattern_rank;
							undef %new_pattern_rank;
RANK_PATTERNS_NP:									
							my $high_score_tmp = "0";
							my $high_rank_count_tmp = "0";
							my $high_first_no_match_tmp = "0";
							my $high_count_matches_tmp = "0";
							
							foreach my $score_tmp2 (sort {$b <=> $a} keys %rank_patterns)
                            {
                                my @rank_patterns = split /\s/, $rank_patterns{$score_tmp2};
								if ($high_score_tmp eq "0"
								|| ($score_tmp2 > $high_score_tmp*0.85 && $rank_patterns[2] > $high_count_matches_tmp && $rank_patterns[1] >= $high_first_no_match_tmp)
								|| ($post_pattern_match_extra eq "yes" && $score_tmp2 > $high_score_tmp*0.7 && $rank_patterns[0] >= $high_rank_count_tmp && $rank_patterns[1] >= $high_first_no_match_tmp && $rank_patterns[2] >= $high_count_matches_tmp && ($rank_patterns[0] > $high_rank_count_tmp || $rank_patterns[1] > $high_first_no_match_tmp))
                                || ($post_pattern_match eq "yes3" && $score_tmp2 > $high_score_tmp*0.4 && $rank_patterns[1] > $high_first_no_match_tmp && $rank_patterns[2] > $high_count_matches_tmp)
                                || ($post_pattern_match ne "yes3" && $score_tmp2 > $high_score_tmp*0.8 && $rank_patterns[0] > $high_rank_count_tmp))
								{
									$high_score_tmp = $score_tmp2;
									$high_rank_count_tmp = $rank_patterns[0];
									$high_first_no_match_tmp = $rank_patterns[1];
									$high_count_matches_tmp = $rank_patterns[2];
                                }
                            }
							$new_pattern_rank{$first_rank_tmp}{$high_score_tmp} = undef;
							delete $rank_patterns{$high_score_tmp};
							
							if (keys %rank_patterns > 0)
							{
								$first_rank_tmp++;
								goto RANK_PATTERNS_NP;
							}
                            
                            #$split_patterns_final_score{$nuc_tmp12}{$rank_tmp9} = $score_tmp;
							
READ_PATTERN_FINAL_NP0:    	foreach my $rankie_tmp (sort {$a <=> $b} keys %new_pattern_rank)
                            {
								foreach my $score_tmp (sort {$b <=> $a} keys %{$new_pattern_rank{$rankie_tmp}})
								{
									if (exists($first_no_match{$score_tmp}))
									{
READ_PATTERN_FINAL_NP:              	foreach my $rank_tmp (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}})
										{                       
											if ($highest_first_no_match ne "")
											{
												if (exists($first_no_match{$score_tmp}{$rank_tmp}{$highest_first_no_match}))
												{   
												}
												else
												{
													next READ_PATTERN_FINAL_NP;
												}
											}
											my $pattern_print = $rank_tmp.";";
											my $count_ranks_tmp =  keys %{$read_patterns_final{$score_tmp}{$rank_tmp}};
																					
											foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
											{
												$pattern_print .= $rank_tmp2.";";
											}
		
											$reads_to_remove{$rank_tmp}{$rank_tmp} = $score_tmp;
											foreach my $rank_tmp2 (sort {$a <=> $b} keys %{$read_patterns_final{$score_tmp}{$rank_tmp}})
											{
												$reads_to_remove{$rank_tmp}{$rank_tmp2} = $score_tmp;
												$remove_reads = "yes";
											}
											print {$filehandle{$seed_id2}} $pattern_print." FINAL_READ_PATTERN ".$score_tmp." SCORE\n";
											
											if ($remove_reads eq "yes")
											{
												$current_score = $score_tmp;
												$current_rank = $rank_tmp;	
												$remove_reads = "";
												my $pos_count_tmp = keys %{$pos_pattern_list{$current_score}{$current_rank}};
												foreach my $rank_tmp0 (keys %reads_to_remove)
												{
													my $count_tmp = keys %{$reads_to_remove{$rank_tmp0}};
													my $SNP_pattern_average_remove = "";
													my $SNP_pattern_average_remove_tmp = '0';
													my $SNP_pattern_average_count = "";
													my $SNP_pattern_average_count_tmp = '0';
													my $cover_complete_assembly = "";
													
													if ($count_tmp > 0)
													{
														my $high_score_count = '0';
														my $high_score_count2 = '0';
														my $rank_one_check = "";
														my $score_diff_check = "";
														my $rank_tmp2 = "";
														
														foreach my $rank_tmp (sort {$a <=> $b} keys %{$reads_to_remove{$rank_tmp0}})
														{
															if ($rank_tmp <= 4)
															{
																$high_score_count++;
															}
															if ($rank_tmp <= 6)
															{
																$high_score_count2++;
															}
															if ($rank_tmp eq '1')
															{
																$rank_one_check = "yes";
																
																$rank_tmp2 = $rank_tmp;
																while (exists($reads_to_remove{$rank_tmp0}{$rank_tmp2}))
																{
																	$rank_tmp2++;
																}
																my $id_tmp01 = $rank_to_id{'1'};
																my $id_tmp02 = $rank_to_id{$rank_tmp2};
																my $score_tmp1 = "";
																my $score_tmp2 = "";
																foreach my $score_tmp (sort {$b <=> $a} keys %scores2)
																{
																	my @ids_tmp = split /,/, $scores2{$score_tmp};
																	foreach my $ids_tmp (@ids_tmp)
																	{
																		if ($ids_tmp eq $id_tmp01)
																		{
																			$score_tmp1 = $score_tmp;
																		}
																		if ($ids_tmp eq $id_tmp02)
																		{
																			$score_tmp2 = $score_tmp;
																		} 
																	}
																}
																if ($score_tmp2 > $score_tmp1*0.7)
																{
																	$score_diff_check = "yes";
																}
															}
	
															my $id_tmp = $rank_to_id{$rank_tmp};
															my $length_tmp = $alignment_length_save{$id_tmp};
															if ($length_tmp > 0)
															{
																$SNP_pattern_average_remove_tmp += $pos_list_number{$rank_tmp}/$length_tmp;
															}
															$SNP_pattern_average_count_tmp += $pos_list_number{$rank_tmp};										
				
															if (exists($rank_to_id{$rank_tmp}))
															{
																my $id_tmp = $rank_to_id{$rank_tmp};
																if (exists($extensions2{$id_tmp}))
																{
																	if ($alignment_length_save{$id_tmp} > length($read)-500)
																	{
																		$cover_complete_assembly = "yes";
																	}
																}
															}
														}
														
														$SNP_pattern_average_remove = $SNP_pattern_average_remove_tmp/$count_tmp;
														$SNP_pattern_average_count = $SNP_pattern_average_count_tmp/$count_tmp;
														
														print {$filehandle{$seed_id2}} $SNP_pattern_average_remove." SNP_PATTERN_AVERAGE_REMOVE\n";
														
														my $count_matches_tmp = '0';
														my $count_pos_no_matches_tmp = '0';
														my $count_no_matches_tmp = '0';
														my $count_no_matches_tmp2 = '0';
														my $first_no_match = "";
														my $first_no_match2 = '0';
														my $count_total_tmp = '0';
														my $nuc_match = $split_patterns_final{$rank_tmp0};
														
														foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
														{
															$count_total_tmp++;
															if ($split_patterns_final{$rank_tmp13} eq $nuc_match)
															{                                   
																if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp13}))
																{
																	$count_matches_tmp++;
																	if ($first_no_match eq "")
																	{
																		$first_no_match2++;
																	}
																}
																else
																{
																	my $no_match = "";
																	my $no_match_tmp = '0';
																	my $match_tmp = '0';
																	if (exists($rank_to_id{$rank_tmp13}))
																	{
																		my $id_tmpi = $rank_to_id{$rank_tmp13};
																		if (exists($alignment_length_save{$id_tmpi}))
																		{
																			my $overlap_tmp = $alignment_length_save{$id_tmpi};
																			
																			foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$pos_pattern_list{$current_score}{$current_rank}})
																			{
																				if ($position-$pos_snp_tmp < $overlap_tmp)
																				{
																					if (exists($store_mismatches_all_NP{$id_tmpi}{$pos_snp_tmp}))
																					{
																						$match_tmp++;
																					}
																					elsif (exists($store_mismatches_NP{$id_tmpi}{$pos_snp_tmp}))
																					{
																						$match_tmp++;
																					}
																					else
																					{
																						$no_match_tmp++;
																					}
																				}
																			} 
																		}
																		elsif ($first_no_match eq "")
																		{
																			$first_no_match = $rank_tmp13;
																		}
																	}
																	if ($no_match_tmp > 0 && $no_match_tmp > ($match_tmp+$no_match_tmp)*0.3)
																	{
																		$no_match = "yes";
																	}
																	
																	if ($no_match eq "" && $post_pattern_match ne "" && $count_matches_tmp > 2 && $count_no_matches_tmp+$count_no_matches_tmp2 < 3 && $match_tmp > 2 && $match_tmp > ($match_tmp+$no_match_tmp)*0.3)
																	{
																		$count_matches_tmp++;
																	}
																	elsif ($no_match ne "")
																	{
																		$count_no_matches_tmp++;
																	}
																	if ($first_no_match eq "" && ($no_match ne "" || $match_tmp < 3))
																	{
																		$first_no_match = $rank_tmp13;
																	}
																	elsif ($first_no_match eq "")
																	{
																		$first_no_match2++;
																	}
																}
															}
															elsif (exists($reads_to_remove{$rank_tmp0}{$rank_tmp13}))
															{
																if ($first_no_match eq "")
																{
																	$first_no_match = $rank_tmp13;
																}
																$count_no_matches_tmp2++;
															}
															else
															{          
																if (exists($rank_to_id{$rank_tmp13}))
																{
																	my $id_tmpi = $rank_to_id{$rank_tmp13};
																	if (exists($alignment_length_save{$id_tmpi}))
																	{
																		my $overlap_tmp = $alignment_length_save{$id_tmpi};
																		my $no_pos_match_tmp = '0';
																		my $pos_match_tmp = '0';
																		
																		foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$pos_pattern_list{$current_score}{$current_rank}})
																		{
																			if ($position-$pos_snp_tmp < $overlap_tmp)
																			{
																				$pos_match_tmp++;
																			}
																			else
																			{
																				$no_pos_match_tmp++;
																			}
																		}
																		if ($pos_match_tmp > 0 && $pos_match_tmp > 0.5*($pos_match_tmp+$no_pos_match_tmp))
																		{
																			$count_pos_no_matches_tmp++;
																		}           
																	}
																}
															}
														}
														if ($first_no_match eq "" && keys %split_patterns_final > 0.8*$total_nuc_count)
														{
															$first_no_match = $total_nuc_count;
															if ($first_no_match < 10)
															{
																$first_no_match = '20';
															}
														}
														my $save_pat_check = "";
														if ($count_pos_no_matches_tmp > 1 && $count_matches_tmp > 2 && $count_matches_tmp > 0.15*$count_total_tmp && ($count_no_matches_tmp/2)+$count_no_matches_tmp2 < 0.2*$count_matches_tmp
															&& ($first_no_match > 10 || $count_matches_tmp > 5))
														{
															print {$filehandle{$seed_id2}} $count_matches_tmp." ADD_ALL_SNP_PATTERN\n";
															$remove_by_rejected = "yes";
															foreach my $rank_tmp13 (sort {$a <=> $b} keys %split_patterns_final)
															{
																if ($split_patterns_final{$rank_tmp13} eq $nuc_match)
																{
																	if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp13}))
																	{                                                     
																	}
																	else
																	{
																		$reads_to_remove{$rank_tmp0}{$rank_tmp13} = undef;
																		if ($rank_tmp13 <= 4)
																		{
																			$high_score_count++;
																		}
																		if ($rank_tmp13 <= 6)
																		{
																			$high_score_count2++;
																		}
																	}
																}
															}
															if ($highest_first_no_match < 10)
															{
																$highest_first_no_match = '10';
															}
															if ($first_no_match < 10)
															{
																$first_no_match = '10';
															}
															$save_pat_check = "yes";
														}										
														
														if (($count_matches_tmp > 4 || ($total_nuc_count < 10 && $count_matches_tmp > 1))  && $count_matches_tmp > 0.9*($count_no_matches_tmp+$count_matches_tmp+$count_no_matches_tmp2))
														{
															if ($first_no_match < 10)
															{
																$first_no_match = '10';
																print {$filehandle{$seed_id2}} $first_no_match." CORRECT_FIRST_NO_MATCH\n";
															}
														}
														
														print {$filehandle{$seed_id2}} $count_no_matches_tmp." COUNT_NO_MATCHES\n";
														print {$filehandle{$seed_id2}} $count_no_matches_tmp2." COUNT_NO_MATCHES2\n";
														print {$filehandle{$seed_id2}} $count_matches_tmp." COUNT_MATCHES\n";
														if (($rank_one_check eq "yes" && $score_diff_check eq "" && $first_no_match < 10)
															|| ($high_score_count > 1 && $current_score < 7 && ($first_no_match < 10 || ($post_pattern_match ne "yes2" && $post_pattern_match ne "yes3") || $post_pattern_match_average eq ""))
															|| ($first_no_match < 10 && $total_nuc_count < 9)
															|| ($post_pattern_match_average ne "yes" && $total_nuc_count < 15 && $current_score < 18)
															|| ($NP_reads_support ne "" && ($current_score < 10 || $count_tmp < 4 || $first_no_match < 6 || $count_matches_tmp < 3 || $high_score_count > 2 || $count_no_matches_tmp2 > $count_matches_tmp*0.2))
															|| ($post_pattern_match eq "" && ($count_tmp < 4 || $current_score < 4) && ($current_score < 20 || $count_tmp < 3))
															|| ($post_pattern_match ne "yes3" && $count_tmp < 4 && ($current_score < 8 || $count_tmp < 3))
															|| ($first_no_match < 10 && $current_score < 3 && $count_tmp < 3)
															|| ($first_no_match < 10 && $current_score < 10 && $count_matches_tmp*0.3 < $count_no_matches_tmp2 && $count_tmp < 6)
															|| ($first_no_match < 7 && $current_score < 4)
															|| ($first_no_match < 7 && $current_score < 25 && $count_tmp < 4 && $count_no_matches_tmp > $count_matches_tmp)
															|| ($first_no_match < 10 && $current_score < 40 && $post_pattern_match_extra ne "yes" && $total_nuc_count-$count_tmp < 11)
															|| ($post_pattern_match_extra ne "yes" && $current_score < 5)		
															|| ($count_matches_tmp/$count_tmp < 0.7 && $current_score < 13 && ($post_pattern_match_extra ne "yes" || $count_tmp < 6))
															|| ($post_pattern_match_extra eq "" && $post_pattern_match_average eq "" && $current_score < 12)
															|| (($first_no_match < 10 || ($count_tmp < 3 && $high_quality_ONT eq "")) && $score_gap < $current_score*0.5 && ($count_tmp < 5 || $current_score < 15) && $post_pattern_match_extra ne "yes")
															|| ($first_no_match < 5 && ($current_score < 10 || ($post_pattern_match_extra eq "" && $current_score < 30)))
															|| ($first_no_match < 10 && $count_matches_tmp < 3 && $current_score < 50 && $count_tmp < 5)
															|| ($first_no_match < 8 && $current_score < 18 && $count_tmp < 5 && $selected_patterns_count > 1)
															|| (($first_no_match < 7 || $first_no_match2 < 3) && $current_score < 5)
															|| ($count_tmp < 5 && $current_score < 50 && $count_matches_tmp < 3 && $high_quality_ONT eq "")
															|| ($post_pattern_match_extra ne "yes" && ($SNP_check eq "" || ($post_pattern_match_average ne "yes" && $count_tmp < 6)) && $current_score < 5)
															|| ($post_pattern_match_extra ne "yes" && ($SNP_check eq "" || ($count_tmp < 5 && $total_nuc_count > 15)) && $current_score < 10 && $first_no_match < 10)
															|| ($post_pattern_match_extra ne "yes" && $current_score < 20 && $count_tmp < 4 && ($cover_complete_assembly eq "yes" || $post_pattern_match_average ne "yes"))
															|| ($high_score_count2 > 4 && ($current_score < 50 || $total_nuc_count < 11 || $count_matches_with_high_scores < $sequencing_depth_NP))
															|| ($high_score_count > 1 && $count_tmp < 4 && $current_score < 11 && $high_quality_ONT eq "")
															|| ($SNP_pattern_average > 0.0005 && $SNP_pattern_average_remove > 0.0005 && $current_score < 3 && $count_tmp < 5)
															|| ($high_score_count2 > 0 && $count_tmp < 4 && $current_score < 15 && $first_no_match < 10)
															|| ($high_score_count > 1 && $SNP_check ne "yes2" && $current_score < 15 && $post_pattern_match ne "yes3")
															|| ($high_score_count > 0 && $current_score < 30 && $count_tmp < 4 && $total_nuc_count > 10 && $post_pattern_match_extra ne "yes" && $high_quality_ONT eq "")
															|| ($high_score_count > 0 && ($count_tmp < 3 || ($post_pattern_match_extra ne "yes" && ($first_no_match < 10 || $count_tmp < 5))) && $current_score < 10 && $high_quality_ONT eq "")
															|| ($high_score_count > 0 && ($first_no_match < 10 || $first_no_match2 < 3) && $current_score < 5)
															|| ($high_score_count > 2 && $first_no_match < 10 && $current_score < 15)
															|| ($high_score_count > 2 && $count_pos_no_matches_tmp < 2 && ($post_pattern_match_extra eq "yes" || $current_score < 10) && $post_pattern_match ne "yes3")
															|| ($first_no_match < 6 && $count_tmp < 4 && $post_pattern_match_extra ne "yes")
															|| ($high_score_count2 > 3 && $high_score_count > 2 && $current_score < 15 && $post_pattern_match ne "yes3")
															|| ($count_matches_tmp < 3 && $current_score < 5 && $count_tmp < 4 && ($post_pattern_match eq "yes" || $post_pattern_match eq "" || $post_pattern_match_extra ne "yes"))
															|| ($first_no_match < 10 && $post_pattern_match_extra ne "yes" && $SNP_check eq "" && (($high_score_count > 1 && $current_score < 10) || $rank_one_check eq "yes"))
															|| ($first_no_match < 10 && $count_matches_tmp < 3 && $current_score < 4)
															|| ($count_tmp < 4 && $total_nuc_count < 10 && ($first_no_match < 10 || $post_pattern_match eq "" || $post_pattern_match eq "yes" || $post_pattern_match_average eq "") && $high_quality_ONT eq "")
															|| ($first_no_match < 9 && $count_matches_tmp < 3 && $current_score < 5 && $total_nuc_count < 13)
															|| ($SNP_pattern_average_remove < $SNP_pattern_average*1.6 && (($first_no_match < 10 && $current_score < 5) || ($count_tmp < 3 && ($post_pattern_match eq "" || $post_pattern_match eq "yes" || $first_no_match < 20))))
															|| ($first_no_match < 8 && $score_diff eq "no" && $current_score < 10 && ($count_tmp < 4 || $count_tmp < $total_nuc_count*0.15))
															|| ($SNP_pattern_average_remove < $SNP_pattern_average*1.6 && $high_score_count > 2 && $high_score_count2 > 3 && $pos_count_tmp < $SNP_pattern_average_count*0.3))
														{     
															undef %reads_to_remove;
															#delete $read_patterns_final{$current_score}{$current_rank};
															print {$filehandle{$seed_id2}} $high_score_count." SCORE ".$score_diff_check." CANCEL_REMOVE\n";
															$highest_first_no_match = "";
															$highest_count_matches = "";
															$highest_count_no_matches = "";
															next READ_PATTERN_FINAL_NP0;
														}
														else
														{
															$remove_reads = "yes";
															$high_score_save = $current_score;
															$add_all_patterns_save = $save_pat_check;
															$highest_count_matches = $count_matches_tmp;
															$highest_count_no_matches = $count_no_matches_tmp;
															$first_no_match_save = $first_no_match;
															
															if ($count_tmp > 3 || $current_score > 20)
															{	
																foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$pos_pattern_list{$current_score}{$current_rank}})
																{
																	my $no_match_tmp = '0';
																	my $match_tmp = '0';
																	my $match_all_tmp = '0';
																	my $out_of_range_tmp = '0';
																	foreach my $rank_tmp5 (sort {$a <=> $b} keys %{$reads_to_remove{$current_rank}})
																	{
																		my $id_tmpi = $rank_to_id{$rank_tmp5};
																		if (exists($alignment_length_save{$id_tmpi}))
																		{
																			my $overlap_tmp = $alignment_length_save{$id_tmpi};
																			if ($position-$pos_snp_tmp < $overlap_tmp)
																			{
																				if (exists($store_mismatches_NP{$id_tmpi}{$pos_snp_tmp}))
																				{
																					$match_tmp++;
																				}
																				elsif (exists($store_mismatches_all_NP{$id_tmpi}{$pos_snp_tmp}))
																				{
																					$match_all_tmp++;
																				}
																				else
																				{
																					$no_match_tmp++;
																				}
																			}
																			else
																			{
																				$out_of_range_tmp++;
																			}
																		}
																		else
																		{
																			$out_of_range_tmp++;
																		}
																	}
																	#print {$filehandle{$seed_id2}} $pos_snp_tmp."\t".$match_tmp."\t".$match_all_tmp."\t".$no_match_tmp."\t".$out_of_range_tmp." DUP_POS_TMP_TEST\n";	
																	if (($match_tmp > 3 || $current_score > 20 && $match_tmp > 2) && $match_tmp*0.1 > $no_match_tmp
																		&& ($match_tmp > $out_of_range_tmp+$match_all_tmp || $match_tmp > 4) && $match_tmp*0.2 > $match_all_tmp+$no_match_tmp)
																	{
																		if (exists($split_positions_DUP{$seed_id}{$pos_snp_tmp}))
																		{}
																		else
																		{
																			my $read_end_tmpi = substr $read, $pos_snp_tmp-$overlap-1, $overlap;											
																			my $selected_nuc_tmp = substr $read, $pos_snp_tmp-1, 1;
																			$selected_nuc_tmp =~ tr/actgn/ACTGN/;
																			print {$filehandle{$seed_id2}} $seed_id."\t".$pos_snp_tmp."\t".$read_end_tmpi."\t".$selected_nuc_tmp." DUP_POS_TMP_HALLE2\n";		
																			$split_positions_DUP{$seed_id}{$pos_snp_tmp} = $read_end_tmpi;
																			$split_positions_DUP2{$seed_id}{$pos_snp_tmp} = $selected_nuc_tmp;
																			$count_dup_pos_halle2++;
																		}
																	}
																}
															}
#Exclude reads------------------------                                              
															if ($count_matches_with_high_scores > $sequencing_depth_NP*10000000000000 && ($current_score > 20 || $first_no_match > 9))
															{															
																my $id_tmpi = "";
																if (exists($rank_to_id{$rank_tmp0}))
																{
																	$id_tmpi = $rank_to_id{$rank_tmp0};
																}
																my $exclude_pos = $alignment_length_save{$id_tmpi};
																if (length($read) < $alignment_length_save{$id_tmpi})
																{
																	$exclude_pos = length($read);
																}
																if ($length_ext_all{$id_tmpi} > $exclude_pos && $alignment_length_save{$id_tmpi} > 5000)
																{
																	$exclude_pos = $length_ext_all{$id_tmpi}*1.1;
																}
																if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "")
																{
																	$exclude_reads_NP{$id}{$id_tmpi} = $position+$exclude_pos;
																}
																foreach my $rank_tmp5 (sort {$a <=> $b} keys %{$reads_to_remove{$rank_tmp0}})
																{
																	my $id_tmpi2 = "";
																	if (exists($rank_to_id{$rank_tmp5}))
																	{
																		$id_tmpi2 = $rank_to_id{$rank_tmp5};
																	}
																	my $exclude_pos = $alignment_length_save{$id_tmpi2};
																	if (length($read) < $alignment_length_save{$id_tmpi2})
																	{
																		$exclude_pos = length($read);
																	}
																	if ($length_ext_all{$id_tmpi2} > $exclude_pos && $alignment_length_save{$id_tmpi2} > 5000)
																	{
																		$exclude_pos = $length_ext_all{$id_tmpi2}*1.1;
																	}
																	if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "")
																	{
																		$exclude_reads_NP{$id}{$id_tmpi2} = $position+$exclude_pos;
																	}
																}
															}
															last READ_PATTERN_FINAL_NP0;
														}
													}
												}
											}
                                        }
                                    }                            
                                }  
                            }
#-------------------                            
                            my $count_pattern_lists = keys %reads_mismatch;
                            foreach my $nuc_tmp20 (keys %SNP_patterns_prev2)
                            {
                                if ($SNP_patterns_prev2{$nuc_tmp20} > $count_pattern_lists*0.25 && $SNP_patterns_prev2{$nuc_tmp20} > 1)
                                {
                                    print {$filehandle{$seed_id2}} $nuc_tmp20." ".$SNP_patterns_prev2{$nuc_tmp20}." PATTERN_MATCH_FINAL\n";
                                }
                            }
                        }
						
						if (($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") &&
                            $post_pattern_match_average eq "yes" && $post_pattern_match_extra eq "yes" && $remove_reads eq "" && $find_haps_in_seed eq "")
                        {
                            if ($assembly_length_max eq "WG" && $y eq "1" && ($first_back_assembly eq "" || length($read) < 5000))
							{
								print "READ_REJECTED4\n";
								print {$filehandle{$seed_id2}} "READ_REJECTED4\n";
								$first_back_assembly = "yes";
								goto END1;
							}
						}
                        
#Select based on average score of each group---------------------------------------------------------------------------                                           
                        
                        if (((($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3") && $post_pattern_match_average eq "yes" && $post_pattern_match_extra eq "yes")
							 || ($SNP_check eq "yes2" && $total_nuc_count > 13)) && $remove_reads eq "" && $find_haps_in_seed eq "" && $add_no_match_reads eq "" && $add_rejected_reads eq "" && $add_rejected_and_no_match_reads eq "")
                        {
							my %average_rank_score_first;
							undef %average_rank_score_first;
                            my %average_rank_score_firstb;
							undef %average_rank_score_firstb;
                            my $highest_nuc_tmp = "";
                            my $hihest_score_tmp = '0';
                            
                            foreach my $nuc_tmp (sort {$a <=> $b} keys %split_patterns_final_score)
                            {
                                my $rank_score = '0';
                                my $rank_count = '0';

                                foreach my $rank_tmp (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp}})
                                {
                                    my $score_tmp = '0';
                                    if (exists($rank_to_id{$rank_tmp}))
                                    {
                                        my $id_tmp = $rank_to_id{$rank_tmp};
                                        if (exists($scores{$id_tmp}))
                                        {
                                            $score_tmp = $scores{$id_tmp};
                                        }
                                    }
                                    if ($rank_score eq '0')
                                    {
                                        $average_rank_score_first{$nuc_tmp} = $score_tmp;
                                        $average_rank_score_firstb{$nuc_tmp} = $rank_tmp;
                                    }
                                    $rank_score += $score_tmp;
                                    $rank_count++;
                                }
                                my $average_rank = $rank_score/$rank_count;
                                if ($rank_count > 1 && $rank_count > $total_nuc_count*0.19)
                                {
                                    $average_rank_score{$nuc_tmp} = $average_rank;
                                    print {$filehandle{$seed_id2}} $nuc_tmp." ".$average_rank." AVERAGE_RANK\n";
                                    if ($average_rank > $hihest_score_tmp && $highest_nuc_tmp ne "-")
                                    {
                                        $hihest_score_tmp = $average_rank;
                                        $highest_nuc_tmp = $nuc_tmp;
                                    }
                                } 
                            }                          
                            if (exists($average_rank_score{$first_rank}))
                            {         
                                my $nuc_best = "";
                                foreach my $nuc_tmp (keys %average_rank_score)
                                {
                                    my $count_ranks = keys %{$SNP_patterns_now{$nuc_tmp}};
                                    if (($count_ranks > 2 && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $count_ranks > $total_nuc_count*0.3)) && $nuc_tmp ne $first_rank && $average_rank_score{$first_rank}*0.35 > $average_rank_score{$nuc_tmp} &&
                                        (($average_rank_score{$first_rank}*0.3 > $average_rank_score{$nuc_tmp}) || ($average_rank_score_first{$first_rank} > 3*$average_rank_score_first{$nuc_tmp} && $average_rank_score_firstb{$nuc_tmp} > 4)))
                                    {
                                        if (($post_pattern_match_extra eq "yes" && $post_pattern_match_average eq "yes") || ($post_pattern_match_extra eq "yes" && $SNP_check eq "yes2" && $total_nuc_count > 13))
                                        {
                                            my $count_tmpi = '0';
											print {$filehandle{$seed_id2}} $nuc_tmp." ".$average_rank_score{$nuc_tmp}." ".$average_rank_score{$first_rank}." AVERAGE_RANK_REMOVE\n";
                                            
											foreach my $nuc_tmp2 (sort {$a <=> $b} keys %split_patterns_final_score)
											{
												if ($nuc_tmp2 eq $nuc_tmp)
												{
													foreach my $rank_tmp (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp2}})
													{
														if ($rank_tmp < 3)
														{
															last;
														}
														my $ss = $total_nuc_count/2.2;
														if ($ss > 10)
														{
															$ss = '11';
														}
														if ($rank_tmp < 6 || $rank_tmp < $ss)
														{
															$count_tmpi++;
															if ($count_tmpi > 0)
															{
																$remove_reads = "";
																undef %reads_to_remove;
																last;
															}
														}
														$selected_nuc = $first_rank;
														$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
														$remove_reads = "yes";
													}
												}  
                                            }
                                        }
										else
										{
											my $count_tmpi = '0';
                                            foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
                                            {
                                                if ($rank_tmp < 3)
                                                {
                                                    $nuc_best = "no";
                                                }
                                                if ($rank_tmp < 7)
                                                {
                                                    $count_tmpi++;
                                                    if ($count_tmpi > 1)
                                                    {
                                                        $nuc_best = "no";
                                                    }
                                                }
                                            }
										}
                                    }
                                    else
                                    {
                                        if ($nuc_best eq "")
                                        {
                                            $nuc_best = $nuc_tmp;
                                        }
                                        else
                                        {
                                            $nuc_best = "no";
                                        }
                                    }
                                }
                     
                                if ($remove_reads eq "yes")
                                {
                                    print {$filehandle{$seed_id2}} "REMOVE_BOTTOM_SCORES\n";
                                    goto REMOVE_READS_NP;
                                }
                            }

                            my $nuc_highest_tmp = "";
                            my $count_highest_tmp = '0';
                            my $count_total_tmp = '0';
                            my $count_total_ext2 = '0';
                            my %nuc_tmp2;
                            undef %nuc_tmp2;
    
                            foreach my $ranki_tmp (sort {$a <=> $b} keys %subject_list)
                            {
                                if (exists($rank_to_id{$ranki_tmp}))
                                {
                                    my $id_tmp = $rank_to_id{$ranki_tmp};
                                    if (exists($extensions2{$id_tmp}))
                                    {
                                        if ($alignment_length_save{$id_tmp} > length($read)-500)
                                        {
											my $nuc_tmp = $nucs_by_rank{$ranki_tmp};
                                            $nuc_tmp2{$nuc_tmp} += 1;
                                            if ($nuc_tmp2{$nuc_tmp} > $count_highest_tmp)
                                            {
                                                $count_highest_tmp = $nuc_tmp2{$nuc_tmp};
                                                $nuc_highest_tmp = $nuc_tmp;
                                            }
                                            $count_total_tmp++;
                                        }
                                    }
                                    $count_total_ext2++;
                                }
                            }
    
                            if ($nuc_highest_tmp ne "" && $count_highest_tmp > $total_nuc_count*0.1 && $count_highest_tmp > 1
                                && $count_highest_tmp eq $count_total_tmp && $nucs{$nuc_highest_tmp} > $total_nuc_count*0.3)
                            {
                                if ($post_pattern_match_average eq "yes" && $post_pattern_match_extra eq "yes")
                                {
                                    my $count_tmpi = '0';
                                    foreach my $nuc_tmp (keys %SNP_patterns_now)
                                    {
                                        if ($nuc_tmp ne $nuc_highest_tmp && $nuc_tmp ne "-" && $nucs{$nuc_tmp} > $total_nuc_count*0.2)
                                        {
                                            foreach my $rank_tmp (sort {$a <=> $b} keys %{$SNP_patterns_now{$nuc_tmp}})
                                            {
                                                if ($rank_tmp < 3)
                                                {
                                                    $remove_reads = "";
                                                    undef %reads_to_remove;
													last;
                                                }
                                                if ($rank_tmp < 6)
                                                {
                                                    $count_tmpi++;
                                                    if ($count_tmpi > 2)
                                                    {
                                                        $remove_reads = "";
                                                        undef %reads_to_remove;
                                                        last;
                                                    }
                                                }
                                                $selected_nuc = $first_rank;
                                                $reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
                                                $remove_reads = "yes";
                                            }
                                        }
                                    }
                                    if ($remove_reads eq "yes")
                                    {
                                        print {$filehandle{$seed_id2}} "REMOVE_BOTTOM_SCORES2\n";
                                        goto REMOVE_READS_NP;
                                    }
                                }
                                else
                                {
                                    $nuc_match = $nuc_highest_tmp;
                                    $nuc_match =~ tr/actgn/ACTGN/;
                                    if ($nuc_highest_tmp eq "-")
                                    {
                                        $nuc_match = "";
                                    }
                                    $best_extension .= $nuc_match;
									$best_extension_part .= $nuc_match;
                                    
                                    if ($nuc_highest_tmp eq "-" && $nucs{"-"} > 0)
                                    {
										if ($nucs{"-"}/$count_total_ext2 < 0.8)
										{
											$quality_scores_gap_tmp{length($best_extension)} = $nucs{"-"}/$count_total_ext2." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
										}
                                    }
                                    else
                                    {
                                        $quality_scores_tmp{length($best_extension)} = $nucs{$nuc_highest_tmp}/$count_total_ext2." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                                    }           
                                    
                                    print {$filehandle{$seed_id2}} $nuc_match." N_CORRECTION_LONG\n";
                                    goto SKIP_INPUT_BLAST3_NP
                                }
                            }
                        }
						
						my $one_rej_read_found = "";
						my $lowest_longest_match_nuc = "";
						foreach my $nuc_tmp14 (keys %longest_match)
						{
							my $longest_match_tmp = $longest_match{$nuc_tmp14};
							if (($lowest_longest_match eq "" || ($longest_match_tmp < $lowest_longest_match && $nucs{$nuc_tmp14} > $total_nuc_count*0.14 && ($nuc_tmp14 ne "-" || $trace_back_check eq ""))) && $nuc_tmp14 ne "")
							{
								$lowest_longest_match = $longest_match_tmp;
								$lowest_longest_match_nuc = $nuc_tmp14;	
							}
							if (($longest_longest_match eq "" || ($longest_match_tmp > $longest_longest_match && $nucs{$nuc_tmp14} > $total_nuc_count*0.14 && ($nuc_tmp14 ne "-" || $trace_back_check eq ""))) && $nuc_tmp14 ne "")
							{
								$longest_longest_match = $longest_match_tmp;
								$longest_longest_match_nuc = $nuc_tmp14;	
							}
						}
						
#Resolve ambigious positions through other haplotype----------------------------------------------------------------------------------------------                                   

						if ($remove_reads eq "" && $add_rejected_and_no_match_reads eq "" && $ext2_count > 0 && $merged_ext ne "" && $post_pattern_match_extra eq "yes"
							&& (($post_pattern_match eq "yes2" && $count_matches_with_high_scores > $sequencing_depth_NP) || $post_pattern_match eq "yes3")
							&& ($post_pattern_match_average eq "yes" || $post_pattern_match eq "yes3") && $find_haps_in_seed eq ""
							&& ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3") && ($post_pattern_match eq "yes3" || $total_nuc_count > 18))
						{
							my %nuc_tmp0;
							undef %nuc_tmp0;
							
							foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
								{
									if (exists($rank_to_id{$rank_tmp13}))
									{
										if (exists($split_contigs_reads2{$id}{$rank_to_id{$rank_tmp13}}))
										{
											$nuc_tmp0{$nuc_tmp13} += 1;
										}
									}
								}
							}
							my $count_haps0 = keys %nuc_tmp0;
							if ($count_haps0 eq '1')
							{
								foreach my $nuc_tmp17 (keys %nuc_tmp0)
								{
									$remove_reads = "yes";
									print {$filehandle{$seed_id2}} $nuc_tmp17." REMOVE_BY_ORIGI\n";
	
									foreach my $nuc_tmp15 (sort {$a <=> $b} keys %split_patterns_final_score)
									{
										if ($nuc_tmp17 ne $nuc_tmp15)
										{
											foreach my $rank_tmp15 (keys %{$split_patterns_final_score{$nuc_tmp15}})
											{
												$reads_to_remove{$rank_tmp15}{$rank_tmp15} = undef;
											}
										}
									}
									goto REMOVE_READS_NP;
								}
							}
							
							my %nuc_tmp2;
							undef %nuc_tmp2;
							my %nuc_tmp2_VIP;
							undef %nuc_tmp2_VIP;
							
							foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
								{
									if (exists($rank_to_id{$rank_tmp13}))
									{
										if (exists($extensions2{$rank_to_id{$rank_tmp13}}))
										{
											$nuc_tmp2{$nuc_tmp13} += 1;
											if (exists($extensions2_VIP{$rank_to_id{$rank_tmp13}}))
											{
												$nuc_tmp2_VIP{$nuc_tmp13} += 1;
											}
										}
									}
								}
							}
							
							my $count_haps = keys %nuc_tmp2;
							my $count_haps_vips = keys %nuc_tmp2_VIP;
							print {$filehandle{$seed_id2}} $count_haps." ".$count_haps_vips." REMOVE_BY_HAP\n";
							
							if ($count_haps eq '1' && $count_haps_vips < '2')
							{
								foreach my $nuc_tmp17 (keys %nuc_tmp2_VIP)
								{
									if ($nuc_tmp2_VIP{$nuc_tmp17} > 2 && $nuc_tmp17 eq $longest_longest_match_nuc)
									{
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $nuc_tmp17." REMOVE_BY_VIP\n";

										foreach my $nuc_tmp15 (sort {$a <=> $b} keys %split_patterns_final_score)
										{
											if ($nuc_tmp17 ne $nuc_tmp15)
											{
												foreach my $rank_tmp15 (keys %{$split_patterns_final_score{$nuc_tmp15}})
												{
													$reads_to_remove{$rank_tmp15}{$rank_tmp15} = undef;
												}
											}
										}
										goto REMOVE_READS_NP;
									}
								}
								foreach my $nuc_tmp17 (keys %nuc_tmp2)
								{
									if ($nuc_tmp2{$nuc_tmp17} > 3 && $nuc_tmp17 eq $longest_longest_match_nuc)
									{
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $nuc_tmp17." REMOVE_BY_HAPI\n";

										foreach my $nuc_tmp15 (sort {$a <=> $b} keys %split_patterns_final_score)
										{
											if ($nuc_tmp17 ne $nuc_tmp15)
											{
												foreach my $rank_tmp15 (keys %{$split_patterns_final_score{$nuc_tmp15}})
												{
													$reads_to_remove{$rank_tmp15}{$rank_tmp15} = undef;
												}
											}
										}
										goto REMOVE_READS_NP;
									}
								}
							}
							if ($merged_ext eq "2")
							{
								my %nuc_tmp_no2;
								undef %nuc_tmp_no2;
								
								foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
								{
									foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
									{
										if (exists($rank_to_id{$rank_tmp13}))
										{
											if (exists($extensions_nomatch2{$rank_to_id{$rank_tmp13}}))
											{
												$nuc_tmp_no2{$nuc_tmp13}{$rank_to_id{$rank_tmp13}} += 1;
											}
										}
									}
								}
								my $count_haps2 = keys %nuc_tmp_no2;
								if ($count_haps2 eq '1')
								{
									foreach my $nuc_tmp17 (keys %nuc_tmp_no2)
									{
										my $count_haps3 = keys %{$nuc_tmp_no2{$nuc_tmp17}};
										my $length_check = "";
										
										if ($count_haps3 > 1)
										{
											foreach my $id_tmp17 (keys %{$nuc_tmp_no2{$nuc_tmp17}})
											{
												foreach my $length_tmp17 (keys %{$longest_match2{$nuc_tmp17}})
												{
													foreach my $id_tmp18 (keys %{$longest_match2{$nuc_tmp17}{$length_tmp17}})
													{
														if (exists($extensions_nomatch2{$id_tmp18}))
														{}
														elsif ($alignment_length_save{$id_tmp18} > $alignment_length_save{$id_tmp17})
														{
															$length_check = "no";
														}
													}
												}
											}
											if ($length_check eq "")
											{
												$remove_reads = "yes";
												print {$filehandle{$seed_id2}} $nuc_tmp17." REMOVE_BY_NO_MATCH\n";
	
												foreach my $rank_tmp15 (keys %{$split_patterns_final_score{$nuc_tmp17}})
												{
													$reads_to_remove{$rank_tmp15}{$rank_tmp15} = undef;
												}
	
												goto REMOVE_READS_NP;
											}
										}
									}
								}
							}
						}

						
ADD_REJ_NP:
#Add rejected reads to mafft-------------------------------------------------------------------------------------------------------------------------------                                        

						if ($add_rejected_reads eq "" && $add_no_match_reads eq "" && $total_nuc_count > 5 && $remove_reads eq "" && ($SNR_read_ahead eq "" || ($post_pattern_match eq "yes3" && $total_nuc_count > 10)) &&
                             $post_pattern_match eq "yes3" && $find_haps_in_seed eq "" && $add_rejected_and_no_match_reads eq "")
                        {
							my $new_longest_match_check = "";
NEW_LONGEST_MATCH_NP:							
							print {$filehandle{$seed_id2}} $lowest_longest_match." ADD_REJECTED_READS\n";   

                            my $count_tmp = '0';
                            my $count_tmp3 = '0';
                            my %read_start_pos_rej_tmp;
                            undef %read_start_pos_rej_tmp;
							my $rej_rej_check = "";
                            
                            foreach my $id_tmp5 (keys %read_start_pos_rej)
                            {                                   
								if ($read_start_pos_rej{$id_tmp5} > $lowest_longest_match-600 && $read_start_pos_rej{$id_tmp5} < $longest_longest_match && length($read) > 1000)
                                {
                                    $count_tmp++;
									print {$filehandle{$seed_id2}} $read_start_pos_rej{$id_tmp5}." REJ\n";  
                                    if (exists($read_start_pos_rej_tmp{$read_start_pos_rej{$id_tmp5}}))
                                    {
                                        $read_start_pos_rej_tmp{$read_start_pos_rej{$id_tmp5}}{$id_tmp5} = undef;
                                    }
                                    else
                                    {
                                        my $check_tmp = "";
                                        foreach my $pos_tmp1 (keys %read_start_pos_rej_tmp)
                                        {
                                            if ($pos_tmp1 > $read_start_pos_rej{$id_tmp5}-450 && $pos_tmp1 < $read_start_pos_rej{$id_tmp5}+450)
                                            {
                                                $read_start_pos_rej_tmp{$pos_tmp1}{$id_tmp5} = undef;
                                                $check_tmp = "yes";
                                                last;
                                            }
                                        }
                                        if ($check_tmp eq "")
                                        {
                                            $read_start_pos_rej_tmp{$read_start_pos_rej{$id_tmp5}}{$id_tmp5} = undef;
                                        }
                                    }
									if (exists($rejected_rej_reads{$id_tmp5}))
									{
										$rej_rej_check = "yes";
									}
                                }
                            }
                            foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
                            {
                                if (keys %{$read_start_pos_rej_tmp{$pos_tmp5}} > 1)
                                {
                                    $count_tmp3++;
                                }
                            }
							my $one_check = "";
							foreach my $nuc_tmp5 (keys %split_patterns_final_score)
                            {
								my $count_tmp = keys %{$split_patterns_final_score{$nuc_tmp5}};
							    if ($count_tmp > 5 && $count_tmp > 0.3*$total_nuc_count)
                                {
                                    $one_check = "yes";
                                }
								else
								{
									$one_check = "";
									last;
								}
                            }
							print {$filehandle{$seed_id2}} $count_tmp." COUNT_TMP\n";  
                            print {$filehandle{$seed_id2}} $count_tmp3." COUNT_TMP3\n";
							my $acc_rej = "";
							
							if ($count_tmp < 2 && $count_tmp > 0 && $one_check eq "yes" && $count_matches_with_high_scores < ($sequencing_depth_NP/0.7)*2.3
								&& $post_pattern_match_extra eq "yes" && $post_pattern_match eq "yes3" && $post_pattern_match_average eq "yes" && $rej_rej_check eq ""
								&& ($count_tmp3 > 0 || ($trace_back_check ne "" && $sequencing_depth_NP < 20)))
							{
								my $accuracy_rej = "";
								foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
                                {                                   
									my $rej_reads_count = keys %{$read_start_pos_rej_tmp{$pos_tmp5}};
									if ($count_tmp3 eq '0' || $rej_reads_count > 1)
									{
										foreach my $id_tmp5 (sort {$a <=> $b} keys %{$read_start_pos_rej_tmp{$pos_tmp5}})
										{
											$accuracy_rej = $accuracy{$id_tmp5};
										}
									}
								}
								print {$filehandle{$seed_id2}} $accuracy_rej." ACC_REJ\n";
								my $more_tmp = '0';
								my $less_tmp = '0';
								
								if ($accuracy_rej ne "")
								{
									foreach my $accuracy_id_tmp (sort {$a <=> $b} keys %accuracy)
									{
										if ((exists($extensions2_tmp{$accuracy_id_tmp})))
										{
											my $accuracy_tmp = $accuracy{$accuracy_id_tmp};
											if ($accuracy_tmp >= $accuracy_rej)
											{
												$more_tmp++;
											}
											else
											{
												$less_tmp++;
											}
										}
									}
									if ($more_tmp > 0.85*($more_tmp+$less_tmp))
									{
										$acc_rej = "yes";
									}
								}
								if ($one_rej_read_found eq "")
								{
									$one_rej_read_found = "yes";
									print {$filehandle{$seed_id2}} $one_rej_read_found." SKIP_ONE_HIT\n";
									goto SKIP_REJ_NP;
								}
							}
							my $check_length_tmp = "";
							if ($count_tmp > 25)
							{
								foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
								{
									if ($pos_tmp5 > $lowest_longest_match-600 && $pos_tmp5 < $longest_longest_match)
									{
									}
									else
									{
										$check_length_tmp = "no";
									}
								}
								if ($check_length_tmp eq "")
								{
									$remove_reads = "yes";
                                    print {$filehandle{$seed_id2}} $add_rejected_reads." REMOVE_BY_REJECTED_READS_50\n";
									$remove_by_rejected = "yes";
                                    
                                    foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
                                    {
                                        if ($split_patterns_final{$rank_tmp8} eq $lowest_longest_match_nuc)
                                        {
                                            $reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
                                        }
                                    }
									goto REMOVE_READS_NP;
								}
							}
							my $ff = keys %read_start_pos_rej_tmp;
							print {$filehandle{$seed_id2}} $ff." KEYS_REJ\n";
							
                            if ((($count_tmp > 1 && $count_tmp3 eq 1) || ($count_tmp eq '1' && $acc_rej eq "" && $one_check eq "yes"
								&& $count_matches_with_high_scores < ($sequencing_depth_NP/0.7)*2.3 && $post_pattern_match_extra eq "yes" && $post_pattern_match eq "yes3" && $post_pattern_match_average eq "yes" && $rej_rej_check eq ""))
								&& $count_tmp < 55 && ($count_tmp3 > 0 || ($trace_back_check ne "" && $sequencing_depth_NP < 20)) && ($ff eq '1' || $count_tmp3 eq '0' || $count_matches_with_high_scores < $sequencing_depth_NP*2.3))
                            {
								undef %id_matches;
								$no_go_back_sort_matches = "yes";
                                foreach my $pos_tmp5 (keys %read_start_pos_rej_tmp)
                                {                                   
									foreach my $id_tmp5 (sort {$a <=> $b} keys %{$read_start_pos_rej_tmp{$pos_tmp5}})
									{ 
										print {$filehandle{$seed_id2}} $id_tmp5." ID ".$pos_tmp5." POS_REJ\n";

										if (exists($store_mismatches_NP{$id_tmp5}))
										{
											my $long_read_tmp = "";
											if (exists($reverse_list{$id_tmp5}))
											{
												$long_read_tmp = reverse($hash_NP_reads_tmp{$id_tmp5});
												$long_read_tmp =~ tr/ACTG/TGAC/;
											}
											else
											{
												$long_read_tmp = $hash_NP_reads_tmp{$id_tmp5};
											}
											
											my $long_read_end_pos_tmp = $long_read_end_pos_save{$id_tmp5};
											my $ext = substr $long_read_tmp, $long_read_end_pos_tmp-90, $length_extension;
											if (exists($scores2{'0'}))
											{
												$scores2{'0'} .= ",$id_tmp5"; 
											}
											else
											{
												$scores2{'0'} = $id_tmp5;
											}
											$extensions2_tmp{$id_tmp5} = $ext;
										}
										else
										{
											$id_matches{$id_tmp5} = undef;
											print {$filehandle{$seed_id2}} $id_tmp5." ID ".$pos_tmp5." POS_REJ000\n";
											delete $save_alignment_data_NP{$seed_id}{$id_tmp5};
											delete $read_start_pos_rej{$id_tmp5};	
										}
									}
                                }
								foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
								{
									if (exists($split_positions_VIP{$id}{$pos_tmp14}))
									{}
									elsif ($pos_tmp14 > $position+length($best_extension)+150)
									{
										 delete $split_positions_DUP{$id}{$pos_tmp14};
										 delete $split_positions_DUP2{$id}{$pos_tmp14};
									}
								}
	
                                $add_rejected_reads = $total_nuc_count_original;
								$add_rejected_reads_pos = length($best_extension);
								$add_rejected_reads_low_longest = $lowest_longest_match;
								
                                print {$filehandle{$seed_id2}} $best_extension."\nHALLE1\n";
                                $mismatch_retry++;
                                $best_extension = "";
								$best_extension_part = "";
                                undef %quality_scores_tmp;
                                $remove_reads_check = "";                                    
								
								if (keys %id_matches > 0)
                                {
                                    goto ADD_REJ_POS_NP;
                                }
                                goto SELECT_LENGTH_NP2;   
                            }
							elsif ($new_longest_match_check eq "")
							{
								$new_longest_match_check = "yes";
								foreach my $nuc_tmp14 (keys %longest_match2)
								{
									if ($nuc_tmp14 eq $lowest_longest_match_nuc)
									{
										my $check_tmp = "";
										my $next_lowest_longest_match = "";
										foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp14}})
										{
											if ($length_tmp14 eq $lowest_longest_match)
											{
												$check_tmp = "yes";
											}
											elsif ($check_tmp eq "yes")
											{
												$next_lowest_longest_match = $length_tmp14;
												last;
											}
										}
										foreach my $id_tmp14 (keys %{$longest_match2{$nuc_tmp14}{$lowest_longest_match}})
										{
											if (exists($multi_match{$id_tmp14}))
											{
												foreach my $mm_pos_tmp14 (sort {$b <=> $a} keys %{$multi_match{$id_tmp14}})
												{
													if ($mm_pos_tmp14 > $next_lowest_longest_match-5000)
													{
														$lowest_longest_match = $next_lowest_longest_match;
														print {$filehandle{$seed_id2}} $lowest_longest_match." NEW_LOWEST_MATCH\n";   
														goto NEW_LONGEST_MATCH_NP;
													}
												}
											}
										}
									}
								}
							}
                        }
                        elsif ($add_rejected_reads ne "" && $longest_longest_match_nuc ne "" && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2")
							   && ($post_pattern_match_average eq "yes" || $full_reset_NP ne "") && $post_pattern_match_extra eq "yes" && $add_rejected_reads_stop eq "")
                        {          
                            print {$filehandle{$seed_id2}} $longest_longest_match_nuc." LONGEST_NUC\n";
							
							my %nucs_rej_tmp;						
							undef %nucs_rej_tmp;
							foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
							{
								if ($rank_tmp8 > $add_rejected_reads)
								{
									$nucs_rej_tmp{$split_patterns_final{$rank_tmp8}} += 1;
								}
							}
							foreach my $nuc_rej_tmp (keys %nucs_rej_tmp)
                            {
                                print {$filehandle{$seed_id2}} $nuc_rej_tmp." NUC_REJ\n";
								if ($nuc_rej_tmp eq $longest_longest_match_nuc && $nucs_rej_tmp{$nuc_rej_tmp} > $total_nuc_count_rej*0.04)
                                {
                                    foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
									{
										if ($rank_tmp8 > $add_rejected_reads)
										{
											my $id_tmp8 = $rank_to_id{$rank_tmp8};
											$rejected_rej_reads{$id_tmp8} = undef;
										}
									}
									if ($post_pattern_match eq "yes3" && length($best_extension) > $add_rejected_reads_pos+50)
									{
										goto REJECT_STOP;
									}
									goto READ_LENGTH_NP;
                                }
                            }
							
                            foreach my $nuc_rej_tmp (keys %nucs_rej_tmp)
                            {
								my $count_tmp = keys %nucs_rej_tmp;
								my $count_tmp2 = "0";
								my $length_check = "";
								foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
								{
									if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
									{
										$count_tmp2++;
										my $id_tmp8 = $rank_to_id{$rank_tmp8};
										if ($longest_match{$nuc_rej_tmp} > $alignment_length_save{$id_tmp8})
										{
											#$length_check = "no"
										}
									}
								}
								
								if ($length_check eq "" && $nuc_rej_tmp ne $longest_longest_match_nuc && ($nucs_rej_tmp{$nuc_rej_tmp} > 2 || ($nucs_rej_tmp{$nuc_rej_tmp} > 1 && $count_tmp eq "1")
									|| ($nucs_rej_tmp{$nuc_rej_tmp} > 0 && $count_tmp eq "1" && $post_pattern_match eq "yes3")) && $count_tmp2 > 0.15*$total_nuc_count)
                                {
                                    $remove_reads = "yes";
                                    print {$filehandle{$seed_id2}} $add_rejected_reads." REMOVE_BY_REJECTED_READS0\n";
                                    print {$filehandle{$seed_id2}} $nuc_rej_tmp." REMOVE_BY_REJECTED_READS1\n";
                                    print {$filehandle{$seed_id2}} $total_nuc_count_rej." TOTAL_NUC_REJ\n";
                                    $add_rejected_reads = "";
									$remove_by_rejected = "yes";
                                    
                                    foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
                                    {
                                        if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
                                        {
                                            $reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
                                            my $id_tmp0 = $rank_to_id{$rank_tmp8};
                                            delete $read_start_pos_rej{$id_tmp0};
                                        }
                                    }
                                    foreach my $id_tmp5 (keys %read_start_pos_rej)
                                    {
                                        delete $extensions2_tmp{$id_tmp5};
                                    }
                                    delete $scores2{'0'};
									
									#my $last_11 = substr $best_extension, -11, 11;
									#$track_split_NP{$id}{$position+length($best_extension)} = $last_10."+".$longest_longest_match_nuc;
									#foreach my $posie_tmp (keys %SNP_patterns_prev_match)
									#{
										#my $last_10_tmp = substr $best_extension, $posie_tmp-$position-10, 10;
										#$track_split_NP{$id}{$posie_tmp} = $last_10_tmp."+".$SNP_patterns_prev_match{$posie_tmp};
									#}
                                }
                            }
REJECT_STOP:
							if ($remove_reads eq "" && $post_pattern_match eq "yes3" && length($best_extension) > $add_rejected_reads_pos+50)
							{
								$add_rejected_reads_stop = "yes";
								print {$filehandle{$seed_id2}} $add_rejected_reads." REJECT_STOP\n";
								foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
                                {
                                    if ($rank_tmp8 > $add_rejected_reads)
									{
										$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
									}
								}
								$add_rejected_reads = "";
								foreach my $id_tmp5 (keys %read_start_pos_rej)
								{
									delete $extensions2_tmp{$id_tmp5};
								}
								delete $scores2{'0'};
							}
                        }
READ_LENGTH_NP:						
#Select reads based on length--------------------------------------------------------------------------------------  
                        if ($add_rejected_and_no_match_reads eq "" && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2")
							&& $post_pattern_match_extra eq "yes" && ($post_pattern_match_average eq "yes" || $full_reset_NP ne "") && $find_haps_in_seed eq ""
							&& ($SNR_read_ahead eq "" || ($post_pattern_match eq "yes3" && $total_nuc_count > 12)) && $remove_reads eq ""
							&& ($post_pattern_match eq "yes3" || $total_nuc_count > 15))
                        {
							my $count_tmp2 = '0';
							if ($longest_longest_match > $lowest_longest_match*3 && $longest_longest_match_nuc ne "")
							{
								foreach my $nuc_tmp11 (keys %longest_match2)
								{
									if ($nuc_tmp11 eq $longest_longest_match_nuc)
									{
										foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp11}})
										{
											if ($length_tmp14 < $lowest_longest_match*2)
											{
												last;
											}
											else
											{
												$count_tmp2++;
											}
										}
									}
								}
								my $count_tmp3 = '0';					
								foreach my $nuc_tmp14 (keys %longest_match2)
								{
									if ($nuc_tmp14 eq $longest_longest_match_nuc)
									{
										foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp14}})
										{
											$count_tmp3++;
											if ($length_tmp14 < $lowest_longest_match*1.3 && $count_tmp3 < 5)
											{
												last;
											}
											elsif ($length_tmp14 < $lowest_longest_match)
											{
												last;
											}
										}
									}
								}
								my $lowest_count = keys %{$split_patterns_final_score{$lowest_longest_match_nuc}};
														  
								if (($count_tmp2 > 2 || $lowest_count < 4) && $count_tmp3 > $sequencing_depth_NP/15 && $count_tmp3 > 3)
								{
									$remove_reads = "yes";
									print {$filehandle{$seed_id2}} $count_tmp3." REMOVE_BY_LENGTH2\n";
									
									foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
									{
										if ($split_patterns_final{$rank_tmp} eq $lowest_longest_match_nuc)
										{
											$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
										}
									}
									goto REMOVE_READS_NP;
								}
							}
							
							if ($total_nuc_count > 12)
							{
								my %second_longest;						
								undef %second_longest;
								foreach my $nuc_tmp11 (keys %longest_match2)
								{
									my $second_check = "";
									foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp11}})
									{
										if ($second_check eq "")
										{
											$second_check = "yes";
											next;
										}
										else
										{
											while (exists($second_longest{$length_tmp14}))
											{
												$length_tmp14++;
											}
											$second_longest{$length_tmp14} = $nuc_tmp11;
											last;
										}
									}
								}
								
								if ($trace_back_check ne "")
								{
									my $count_tmp = '0';
									foreach my $length_tmp15 (keys %second_longest)
									{
										if ($length_tmp15 > length($read)-100)
										{
											$count_tmp++;
										}
									}
									if ($count_tmp > 1)
									{
										$trace_back_split_NP_exclude{$id}{$trace_back_check} = $trace_back_split_NP{$id}{$trace_back_check};
										$trace_back_check = "";
										$post_pattern_match = "";
										delete $trace_back_split_NP{$id}{$trace_back_check};
										goto ALL_MISMATCHES_NP;
									}
								}					
								
								if ($total_nuc_count > 20)
								{
									my $highest = "";
									my $highest_nuc = "";
									foreach my $length_tmp15 (sort {$b <=> $a} keys %second_longest)
									{
										if ($highest eq "")
										{
											$highest = $length_tmp15;
											$highest_nuc = $second_longest{$length_tmp15};
										}
										elsif ($length_tmp15 < $highest/5 && $length_tmp15 < 30000)
										{
											$remove_reads = "yes";
											print {$filehandle{$seed_id2}} $count_tmp2." REMOVE_BY_LENGTH3\n";
											
											foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
											{
												if ($split_patterns_final{$rank_tmp} eq $second_longest{$length_tmp15})
												{
													$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
												}
											}
											goto REMOVE_READS_NP;
										}
									}
								}
								my $count_tmp7 = '0';
								foreach my $nuc_tmp14 (keys %longest_match2)
								{
									if ($nuc_tmp14 ne $longest_longest_match_nuc)
									{
										$count_tmp7 += keys %{$longest_match2{$nuc_tmp14}}
									}
								}
								if ($count_tmp7 < 5 && $count_tmp7 <= $sequencing_depth_NP/3.5 && $longest_longest_match > $lowest_longest_match*2)
								{
									$remove_reads = "yes";
									print {$filehandle{$seed_id2}} $count_tmp7." REMOVE_BY_LENGTH4\n";
									
									foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
									{
										if ($split_patterns_final{$rank_tmp} eq $lowest_longest_match_nuc)
										{
											$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
										}
									}
									goto REMOVE_READS_NP;
								}
							}
							elsif ($total_nuc_count > 6 && $post_pattern_match eq "yes3")
							{
								foreach my $nuc_tmp (sort {$a <=> $b} keys %split_patterns_final_score)
								{
									my $rank_count_tmp = keys %{$split_patterns_final_score{$nuc_tmp}};
									if ($rank_count_tmp < 3 && $nuc_tmp eq $lowest_longest_match_nuc)
									{
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $nuc_tmp." REMOVE_BY_LENGTH5\n";
										
										foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
										{
											if ($split_patterns_final{$rank_tmp} eq $lowest_longest_match_nuc)
											{
												$reads_to_remove{$rank_tmp}{$rank_tmp} = undef;
											}
										}
										goto REMOVE_READS_NP;
									}
								}
							}
							
							if ($unresolvable_NP eq "yes2" || ($post_pattern_match eq "yes3" && $trace_back_check eq "" && $post_pattern_match_count > 2 && $find_haps_in_seed eq ""
								&& (length($best_extension) < 2000 || length($best_extension) < $length_extension*0.7) && $SNR_read_ahead eq ""))
							{           
								if (exists($track_coverage{$id}))
								{
									my $cov_total_high = '0';
									my $cov_count_high = '0';
									my $cov_total_low = '0';
									my $cov_count_low = '0';
									foreach my $pos_tmp17 (sort {$b <=> $a} keys %{$track_coverage{$id}})
									{
										if ($pos_tmp17 > $position-$lowest_longest_match)
										{
											if (exists($longest_match2{$lowest_longest_match_nuc}{$lowest_longest_match}))
											{
												foreach my $id_tmp17 (keys %{$longest_match2{$lowest_longest_match_nuc}{$lowest_longest_match}})
												{
													if (exists($track_coverage{$id}{$pos_tmp17}{$id_tmp17}))
													{
														my $cov_tmp = keys %{$track_coverage{$id}{$pos_tmp17}};
														$cov_total_low += $cov_tmp;
														$cov_count_low++;
														print {$filehandle{$seed_id2}} $pos_tmp17." ".$cov_tmp." POS_TRACK_COVERAGE_LOW\n";
													}
												}
											}
										}
										elsif ($pos_tmp17 > $position-$longest_longest_match)
										{
											if (exists($longest_match2{$longest_longest_match_nuc}{$longest_longest_match}))
											{
												foreach my $id_tmp17 (keys %{$longest_match2{$longest_longest_match_nuc}{$longest_longest_match}})
												{
													if (exists($track_coverage{$id}{$pos_tmp17}{$id_tmp17}))
													{
														my $cov_tmp = keys %{$track_coverage{$id}{$pos_tmp17}};
														$cov_total_high += $cov_tmp;
														$cov_count_high++;
														print {$filehandle{$seed_id2}} $pos_tmp17." ".$cov_tmp." POS_TRACK_COVERAGE_HIGH\n";
													}
												}
											}
										}
									}
									if ($cov_count_low > 0)
									{
										my $avrage_count = $cov_total_low/$cov_count_low;
										print {$filehandle{$seed_id2}} $avrage_count." AVERAGE_POS_TRACK_COVERAGE_LOW\n";
									}
									if ($cov_count_high > 0)
									{
										my $avrage_count = $cov_total_high/$cov_count_high;
										print {$filehandle{$seed_id2}} $avrage_count." AVERAGE_POS_TRACK_COVERAGE_HIGH\n";
									}
								}
							}
						}
SKIP_REJ_NP:						
						
#Add no match reads to mafft-------------------------------------------------------------------------------------------------------------------------------                                        
						if ($post_pattern_match eq "yes3")
						{
							print {$filehandle{$seed_id2}} $extensions_nomatch2b_count." ".$extensions_nomatch2b_count_saved." SCORE_NO_SCORE_MATCH0\n";
							print {$filehandle{$seed_id2}} $post_pattern_match." ".$post_pattern_match_extra." SCORE_NO_SCORE_MATCH0\n";
							print {$filehandle{$seed_id2}} $add_rejected_and_no_match_reads." ".$add_rejected_reads." ".$add_no_match_reads." ".$add_no_match_reads_stop." SCORE_NO_SCORE_MATCH0\n";
						}
						if ($add_rejected_and_no_match_reads eq "" && $add_no_match_reads eq "" && $add_rejected_reads eq "" && $add_no_match_reads_stop eq ""
							&& ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2") && $SNR_read_ahead eq ""
							&& $post_pattern_match_extra eq "yes" && ($post_pattern_match_average eq "yes" || $full_reset_NP ne "") && $remove_reads eq ""
							&& ((($extensions_nomatch2b_count+$extensions_nomatch2b_count_saved) > 1) || ($total_matches < ($sequencing_depth_NP/0.7)*2.3
							&& ($extensions_nomatch2b_count+$extensions_nomatch2b_count_saved) > 0)) && $find_haps_in_seed eq "")
                        {          
							my %extensions_nomatch2b_tmp;
							undef %extensions_nomatch2b_tmp;
							my $score_score_no_match = '0';
							my $score_score_no_match1 = '0';
							print {$filehandle{$seed_id2}} $extensions_nomatch2b_count." ".$extensions_nomatch2b_count_saved." SCORE_NO_SCORE_MATCH0bb\n";
							
							foreach my $ext_id_tmp (keys %extensions_nomatch2b)
							{
								foreach my $ext_tmp (keys %{$extensions_nomatch2b{$ext_id_tmp}})
								{
									foreach my $score_no_match_tmp (keys %{$extensions_nomatch2b{$ext_id_tmp}{$ext_tmp}})
									{
										if (length($ext_tmp) > length($best_extension) && $alignment_length_save{$ext_id_tmp} > $lowest_longest_match)
										{
											if ($score_no_match_tmp > 1)
											{
												$score_score_no_match++;
											}
											else
											{
												$score_score_no_match1++;
											}
											$extensions_nomatch2b_tmp{$ext_id_tmp} = undef;
											print {$filehandle{$seed_id2}} $ext_id_tmp." ADD_NOMATCH\n";
										}
									}
								}
							}
							
							foreach my $ext_id_tmp (keys %extensions_nomatch2b_saved)
							{
								if (exists($extensions_nomatch2b{$ext_id_tmp}))
								{}
								else
								{
									foreach my $score_match_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}})
									{
										foreach my $score_no_match_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}})
										{
											foreach my $aln_length_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}{$score_no_match_tmp}})
											{
												foreach my $pos_prev_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}{$score_no_match_tmp}{$aln_length_tmp}})
												{
													if ((($extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}{$score_no_match_tmp}{$aln_length_tmp}{$pos_prev_tmp})*1.05)+$pos_prev_tmp > $position+length($best_extension)
														&& $position-$pos_prev_tmp+$aln_length_tmp > $lowest_longest_match)
													{
														if ($score_no_match_tmp > 1)
														{
															$score_score_no_match++;
														}
														else
														{
															$score_score_no_match1++;
														}
														$extensions_nomatch2b_tmp{$ext_id_tmp} = undef;
														print {$filehandle{$seed_id2}} $ext_id_tmp." ADD_NOMATCH_SAVED\n";
													}
												}
											}
										}
									}
								}
							}
						
							print {$filehandle{$seed_id2}} $score_score_no_match." ".$score_score_no_match1." SCORE_NO_SCORE_MATCH\n";   
							if ((($score_score_no_match > 0 && $score_score_no_match1+$score_score_no_match > 0) || $score_score_no_match1 > 2) && $score_score_no_match1+$score_score_no_match < 20)
							{
								undef %id_matches;
								$no_go_back_sort_matches = "yes";
								foreach my $id_tmp55 (keys %extensions_nomatch2b_tmp)
								{	
									if (exists($extensions_nomatch2b_saved{$id_tmp55}))
									{
										$id_matches{$id_tmp55} = undef;
									}
									if (exists($extensions_nomatch2b{$id_tmp55}))
									{
										if (exists($scores2{'0'}))
										{
											$scores2{'0'} .= ",$id_tmp55"; 
										}
										else
										{
											$scores2{'0'} = $id_tmp55;
										}
										foreach my $ext_tmp (keys %{$extensions_nomatch2b{$id_tmp55}})
										{
											$extensions2_tmp{$id_tmp55} = $ext_tmp; 
										}
									}
								}
								foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
								{
									if (exists($split_positions_VIP{$id}{$pos_tmp14}))
									{}
									elsif ($pos_tmp14 > $position+length($best_extension)+150)
									{
										 delete $split_positions_DUP{$id}{$pos_tmp14};
										 delete $split_positions_DUP2{$id}{$pos_tmp14};
									}
								}
								$add_no_match_reads = $total_nuc_count_original;
								$add_no_match_reads_pos = length($best_extension);
								$add_rejected_reads_low_longest = $lowest_longest_match;
								print {$filehandle{$seed_id2}} $best_extension."\nHALLE0\n";
								$mismatch_retry++;
								$best_extension = "";
								$best_extension_part = "";
								$remove_reads_check = "";
								undef %quality_scores_tmp;
								
								if (keys %id_matches > 0)
								{
									goto ADD_REJ_POS_NP;
								}
								goto SELECT_LENGTH_NP2;
							}
                        }
                        elsif ($add_no_match_reads ne "" && $remove_reads eq "" && ($post_pattern_match eq "yes2" || $post_pattern_match eq "yes3" || $SNP_check eq "yes2")
							   && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3") && $post_pattern_match_extra eq "yes")
                        {                            
#Check if nomatch reads have same SNP patterns as matched reads-----------------------------------------------------------------				
							
							my %reads_exclude_splits;							
							undef %reads_exclude_splits;
							my %rank_checked;
							undef %rank_checked;
							foreach my $rank_tmp8 (sort {$a <=> $b} keys %subject_list)
							{
								my $no_matches_count = '0';
								if ($rank_tmp8 > $add_no_match_reads)
								{
									my $id_tmp0 = $rank_to_id{$rank_tmp8};
									foreach my $pos_tmp (keys %SNP_no_matches)
									{
										if (exists($SNP_no_matches{$pos_tmp}{$id_tmp0}))
										{
											my $no_matches_check = "";
											foreach my $nuc_tmp (sort {$a <=> $b} keys %split_patterns_final_score)
											{
												my $rank_count_tmp = keys %{$split_patterns_final_score{$nuc_tmp}};
												if ($rank_count_tmp > $total_nuc_count*0.15)
												{
													foreach my $rank_tmp (sort {$a <=> $b} keys %{$split_patterns_final_score{$nuc_tmp}})
													{
														if ($rank_tmp <= $add_no_match_reads)
														{
															if (exists($rank_to_id{$rank_tmp}))
															{
																my $id_tmp3 = $rank_to_id{$rank_tmp};
																if (exists($SNP_matches{$pos_tmp}{$id_tmp3}))
																{
																	$reads_exclude_splits{$rank_tmp8}{$pos_tmp}{$nuc_tmp} += 1;
																	if (exists($split_positions_VIP{$id}{$pos_tmp}))
																	{
																		$reads_exclude_splits{$rank_tmp8}{$pos_tmp}{$nuc_tmp} += 4;
																	}
																	$no_matches_check = "yes";
																}
																elsif (exists($SNP_no_matches{$pos_tmp}{$id_tmp3}))
																{
																	$reads_exclude_splits{$rank_tmp8}{$pos_tmp}{$nuc_tmp} -= 2;
																	if (exists($split_positions_VIP{$id}{$pos_tmp}))
																	{
																		$reads_exclude_splits{$rank_tmp8}{$pos_tmp}{$nuc_tmp} -= 5;
																	}
																	$no_matches_check = "yes";
																}
															}
														}
													}
												}
											}
											if ($no_matches_check eq "")
											{
												$no_matches_count++;
											}
										}
									}
								}
								if ($no_matches_count > 1)
								{
									$rank_checked{$rank_tmp8} = $no_matches_count;
								}
							}
							
							foreach my $rank_tmp9 (sort {$a <=> $b} keys %reads_exclude_splits)
							{
								my $count_final = '0';
								my $count_final2 = '0';
								my $count_final3 = '0';
								foreach my $pos_tmp9 (sort {$a <=> $b} keys %{$reads_exclude_splits{$rank_tmp9}})
								{
									my $count_tmp = '0';
									my $count_min_tmp = '0';
									if (keys %{$reads_exclude_splits{$rank_tmp9}{$pos_tmp9}} > 1)
									{
										foreach my $nuc_tmp (sort {$a <=> $b} keys %{$reads_exclude_splits{$rank_tmp9}{$pos_tmp9}})
										{
											if ($reads_exclude_splits{$rank_tmp9}{$pos_tmp9}{$nuc_tmp} > 0)
											{
												$count_tmp++;
											}
											elsif ($reads_exclude_splits{$rank_tmp9}{$pos_tmp9}{$nuc_tmp} < 0)
											{
												$count_min_tmp++;
											}
										}	
									}
									else
									{
										foreach my $nuc_tmp (sort {$a <=> $b} keys %{$reads_exclude_splits{$rank_tmp9}{$pos_tmp9}})
										{
											if ($reads_exclude_splits{$rank_tmp9}{$pos_tmp9}{$nuc_tmp} > 0 && $nuc_tmp ne $nucs_by_rank{$rank_tmp9})
											{
												$count_final++;
											}
											elsif ($reads_exclude_splits{$rank_tmp9}{$pos_tmp9}{$nuc_tmp} > 0)
											{
												$count_final3++;
											}
										}
									}
									if ($count_tmp > 0 && $count_min_tmp > 0)
									{
										$count_final++;
									}
									elsif ($count_tmp > 1)
									{
										$count_final2++;
									}
								}
								print {$filehandle{$seed_id2}} $count_final." COUNT_FINAL ".$count_final3." COUNT_FINAL3".$rank_tmp9." REMOVE_SPLIT_EXCLUDE_TEST\n";
								if ($count_final < 2 || $count_final3 > 2)
								{
									if (exists($rank_checked{$rank_tmp9}) && $rank_checked{$rank_tmp9} > $count_final2 && $count_final3 <3)
									{}
									else
									{
										$reads_to_remove{$rank_tmp9}{$rank_tmp9} = undef;
										my $id_tmp0 = $rank_to_id{$rank_tmp9};
										delete $extensions2_tmp{$id_tmp0};
										delete $split_patterns_final{$rank_tmp9};
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $rank_tmp9." REMOVE_SPLIT_EXCLUDE\n";
									}
								}
							}
#-------------------------------------------------------------------------------------------------------------------------------						
							my $score_score_match = '0';
							my $score_score_match1 = '0';
							foreach my $ext_id_tmp (keys %extensions2b)
							{
								foreach my $ext_tmp (keys %{$extensions2b{$ext_id_tmp}})
								{
									foreach my $score_match_tmp (keys %{$extensions2b{$ext_id_tmp}{$ext_tmp}})
									{
										my $rank_tmp0 = $id_to_rank{$ext_id_tmp};
										if (exists($split_patterns_final{$rank_tmp0}))
										{
											if ($score_match_tmp > 1)
											{
												$score_score_match++;
											}
											elsif ($score_match_tmp > 0)
											{
												$score_score_match1++;
											}
											if (exists($extensions2_VIP{$ext_id_tmp}))
											{
												$score_score_match++;
											}
										}
									}
								}
							}
							print {$filehandle{$seed_id2}} $score_score_match." ".$score_score_match1." SCORE_SCORE_MATCH\n";   
							if ($score_score_match > 0 || $score_score_match1 > 2)
							{
								my %nucs_rej_tmp;
								undef %nucs_rej_tmp;
								foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
								{
									if ($rank_tmp8 > $add_no_match_reads)
									{
										if (exists($split_patterns_final_score{$split_patterns_final{$rank_tmp8}}))
										{
											$nucs_rej_tmp{$split_patterns_final{$rank_tmp8}} += 1;
										}
									}
								}
								
								my $no_match_count_tmp = keys %nucs_rej_tmp;
								if ($no_match_count_tmp > 1 || $no_match_count_tmp eq '0')
								{
									print {$filehandle{$seed_id2}} $no_match_count_tmp." CANCEL_NO_MATCH\n";
									goto REMOVE_READS_NP;
								}
								foreach my $nuc_rej_tmp (keys %nucs_rej_tmp)
								{
									if ($nucs_rej_tmp{$nuc_rej_tmp} > 1 || ($nucs_rej_tmp{$nuc_rej_tmp} > 0 && $score_score_match1 > 2))
									{
										my $count_removed = '0';
										foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
										{
											if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp && $rank_tmp8 <= $add_no_match_reads)
											{
												$count_removed++;
											}
										}
										if ($total_nuc_count-$count_removed < 3)
										{
											goto REMOVE_READS_NP;
										}
										
										$remove_reads = "yes";
										print {$filehandle{$seed_id2}} $add_no_match_reads." REMOVE_BY_NO_MATCH_READS0\n";
										print {$filehandle{$seed_id2}} $nuc_rej_tmp." REMOVE_BY_NO_MATCH_READS1\n";
										print {$filehandle{$seed_id2}} $total_nuc_count_rej." TOTAL_NUC_REJ\n";
										$add_no_match_reads = "";
										
										foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
										{
											if ($split_patterns_final{$rank_tmp8} eq $nuc_rej_tmp)
											{
												$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
												my $id_tmp0 = $rank_to_id{$rank_tmp8};
											}
										}
										foreach my $id_tmp5 (keys %extensions_nomatch2b)
										{
											delete $extensions2_tmp{$id_tmp5};
										}
										delete $scores2{'0'};
									}
								}
							}

							if ($remove_reads eq "" && $post_pattern_match eq "yes3" && length($best_extension) > $add_no_match_reads_pos+50)
							{
								$add_no_match_reads_stop = "yes";
								print {$filehandle{$seed_id2}} $add_no_match_reads." NO_MATCH_STOP\n";
								foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
                                {
                                    if ($rank_tmp8 > $add_no_match_reads)
									{
										$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
									}
								}
								$add_no_match_reads = "";
								foreach my $id_tmp5 (keys %extensions_nomatch2b)
								{
									delete $extensions2_tmp{$id_tmp5};
								}
								delete $scores2{'0'};
							}
                        }
						$time_mafft_tmp2 += (time-$time_split);
						$time_mafft_tmp2b += (time-$time_split2);
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------                                          
REMOVE_READS_NP:                            
                        if (keys %reads_to_remove > 0)
						{}
						elsif ($remove_reads ne "")
						{
							$remove_reads = "";
							print {$filehandle{$seed_id2}} "REMOVE_ERROR\n";
							goto BASECALL2_NP;
						}
						if ($remove_reads eq "yes")
                        {
                            my $removed_reads_tmp = '0';
                            my $highest_rank = "";
                            my $add_rejected_reads_new = '0';
							
							my $reads_remain = '0';
							foreach my $rank_tmp0 (keys %reads_to_remove)
                            {
								foreach my $rank_tmp2 (keys %split_patterns_final)
								{
									if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp2}))
									{
									}
									else
									{
										$reads_remain++;
									}
								}
							}

							if ($reads_remain < 4 && $full_reset_NP ne "" && $post_pattern_match ne "yes3")
							{
								$remove_reads = "";
								undef %reads_to_remove;
								print {$filehandle{$seed_id2}} $reads_remain." REMAIN_TOO_LOW\n";
								goto BASECALL2_NP;
							}
                            
                            foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
                            {
                                my $removed = "";
                                foreach my $rank_tmp0 (keys %reads_to_remove)
                                {
                                    if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
                                    {
                                        $removed_reads_tmp++;
                                        $removed = "yes";
                                        my $id_tmp0 = $rank_to_id{$rank_tmp};
                                        delete $extensions{$extensions2{$id_tmp0}};
                                        delete $extensions2{$id_tmp0};
                                        delete $extensions2b{$id_tmp0};
                                        delete $extensions2_tmp{$id_tmp0};
                                        delete $extensions_nomatch{$extensions2{$id_tmp0}};
                                        delete $extensions_nomatch2{$id_tmp0};
                                        delete $extensions_nomatch2b{$id_tmp0};
                                        delete $extensions_unknown{$extensions2{$id_tmp0}};
                                        delete $extensions_unknown2{$id_tmp0};
                                        delete $save_reads_for_next{$id_tmp0};
                                        delete $add_rej_reads_extra{$id_tmp0};
                                        delete $read_start_pos_rej{$id_tmp0};
										$ext2_count = keys %extensions2_tmp;
                                        if (($rank_tmp <= $add_rejected_reads && $add_rejected_reads ne "") || ($rank_tmp <= $add_no_match_reads && $add_no_match_reads ne ""))
                                        {
                                            $add_rejected_reads_new++;
                                        }									
#Exclude reads-----------------------------------                                              
										if (($SNP_check eq "yes2" || ($SNP_check ne "" && $trace_back_check ne "")) && ((($post_pattern_match_extra eq "yes" || $high_score_save > 15 || $add_all_patterns_save ne "") && $first_no_match_save > 9
											&& $highest_count_matches > 0.2*$total_nuc_count && $highest_count_matches*0.3 > $highest_count_no_matches) || $trace_back_check ne "" || $remove_by_rejected eq "yes"))
										{
											my $id_tmpi = "";
											if (exists($rank_to_id{$rank_tmp}))
											{
												$id_tmpi = $rank_to_id{$rank_tmp};
											}
											my $exclude_pos = $alignment_length_save{$id_tmpi};
											if (length($read) < $alignment_length_save{$id_tmpi})
											{
												$exclude_pos = length($read);
											}
											if ($length_ext_all{$id_tmpi} > $exclude_pos && $alignment_length_save{$id_tmpi} > 5000)
											{
												$exclude_pos = $length_ext_all{$id_tmpi}*1.1;
											}
											if ($repetitive_detect1 eq "" && $repetitive_detect2 eq "kkkkkkkkkkkkkkkk")
											{
												$exclude_reads_NP{$id}{$id_tmpi} = $position+$exclude_pos;
											}
										}
                                    }
                                }
                                if ($highest_rank eq "" && $removed eq "")
                                {
                                    $highest_rank = $rank_tmp;
                                }
                            }
                            if ($removed_reads_tmp > 0 && keys %extensions2_tmp > 1)
                            {
								my $read_end_tmpi;
								if (length($best_extension) < $overlap)
								{
									$read_end_tmpi = substr $read, -($overlap-length($best_extension)), ($overlap-length($best_extension));
									$read_end_tmpi .= substr $best_extension, 0, length($best_extension);
								}
								else
								{
									$read_end_tmpi = substr $best_extension, -$overlap, $overlap;
								}
                                my $pos_tmp = $position+length($best_extension);
								
								if ($selected_nuc eq "")
								{
									my %removed_nuc;
									undef %removed_nuc;
									my $highest_count_tmp = '0';
									foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
									{
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
											{
												$removed_nuc{$split_patterns_final{$rank_tmp}} += 1;
												if ($removed_nuc{$split_patterns_final{$rank_tmp}} > $highest_count_tmp)
												{
													$highest_count_tmp = $removed_nuc{$split_patterns_final{$rank_tmp}};
												}
											}
										}
									}
									foreach my $nuc_tmp0 (keys %removed_nuc)
									{
										if ($removed_nuc{$nuc_tmp0} < 0.3*$highest_count_tmp)
										{
											delete $removed_nuc{$nuc_tmp0};
										}
									}
									my $count_tmp = keys %removed_nuc;
									my $deleted_nuc = "";
									if ($count_tmp eq '1')
									{
										foreach my $nuc_tmp0 (keys %removed_nuc)
										{
											my $rank_count_tmp = keys %{$split_patterns_final_score{$nuc_tmp0}};
											if ($removed_nuc{$nuc_tmp0} > 0.8*$rank_count_tmp)
											{
												$deleted_nuc = $nuc_tmp0;
											}
										}
									}
									if ($deleted_nuc ne "")
									{
										foreach my $nuc_tmp1 (keys %split_patterns_final_score)
										{
											my $rank_count_tmp = keys %{$split_patterns_final_score{$nuc_tmp1}};
											if ($nuc_tmp1 ne $deleted_nuc && $selected_nuc eq "" && $rank_count_tmp > 0.15*$total_nuc_count)
											{
												$selected_nuc = $nuc_tmp1;
											}
											elsif ($nuc_tmp1 ne $deleted_nuc && $rank_count_tmp > 0.15*$total_nuc_count)
											{
												$selected_nuc = "";
											}
										}
									}
								}
                                
                                if (($SNP_check eq "yes2" || ($SNP_check ne "" && $trace_back_check ne "")) && ((($post_pattern_match_extra eq "yes" || $high_score_save > 15) && $first_no_match_save > 9
									&& $highest_count_matches > 0.2*$total_nuc_count && $highest_count_matches*0.3 > $highest_count_no_matches) || $trace_back_check ne "" || $remove_by_rejected eq "yes") && $selected_nuc ne "")
                                {
                                    my $first_rank_tmp = '1';
									foreach my $rank_tmp (sort {$a <=> $b} keys %subject_list)
									{
										my $remove_check_tmp = "";
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
											{
												$remove_check_tmp = "yes";
											}
										}
										if ($remove_check_tmp eq "")
										{
											$first_rank_tmp = $rank_tmp;
											last;
										}
									}
									
									my $pos_tmp2 = $track_length_ext_total{$first_rank_tmp}+$track_length_ext{$first_rank_tmp};
                                    $split_positions_DUP_tmp{$pos_tmp2} = $read_end_tmpi;
									$split_positions_DUP_tmp2{$pos_tmp2} = $selected_nuc;
									if ($trace_back_check ne "")
									{
										$split_positions_DUP_tmp3{$pos_tmp2} = "yes";
									}
									print {$filehandle{$seed_id2}} $seed_id."\t".$pos_tmp."\t".$read_end_tmpi.",".$selected_nuc." DUP_POS\n";
                                }
								
								my $remaining_rej = '0';
REMAIN_REJ_NP:					foreach my $rank_tmp (sort {$a <=> $b} keys %split_patterns_final)
								{
									if (($add_rejected_reads ne "" && $rank_tmp > $add_rejected_reads) || ($add_no_match_reads ne "" && $rank_tmp > $add_no_match_reads))
									{
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											if (exists($reads_to_remove{$rank_tmp0}{$rank_tmp}))
											{
												next REMAIN_REJ_NP;
											}
										}
										$remaining_rej++;
									}
								}

                                foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
								{
									if (exists($split_positions_VIP{$id}{$pos_tmp14}))
									{}
									elsif ($pos_tmp14 > $position+length($best_extension)+150)
									{
										 delete $split_positions_DUP{$id}{$pos_tmp14};
										 delete $split_positions_DUP2{$id}{$pos_tmp14};
									}
								}
                                print {$filehandle{$seed_id2}} $selected_nuc." NUC ".$best_extension."\nHALLE2\n";
													
                                $mismatch_retry++;
                                $best_extension = "";
								$best_extension_part = "";
                                undef %quality_scores_tmp;
								$remove_reads_check = "yes";
                                
                                if ($add_rejected_reads ne "")
                                {    
									if ($remaining_rej > 0)
									{
										$add_rejected_reads -= $add_rejected_reads_new;
										goto SELECT_LENGTH_NP;
									}
                                    else
									{
										$add_rejected_reads = "";
									}
                                }
								if ($add_no_match_reads ne "")
                                {
									if ($remaining_rej > 0)
									{
										$add_no_match_reads -= $add_rejected_reads_new;
										goto SELECT_LENGTH_NP;
									}
                                    else
									{
										$add_no_match_reads = "";
										$add_no_match_reads_stop = "yes";
									}
                                }
                                if ($mismatch_retry > 500000000 && $total_nuc_count-$removed_reads_tmp > 7 && $high_quality eq "")
                                {
                                    $high_quality = "yes";
                                    goto SELECT_LENGTH_NP;
                                }
								if ($count_dup_pos_halle2 > 400000000000000 && $no_go_back_sort_matches eq "" && $merged_ext ne '2')
								{
									goto SORT_MATCHES_NP;
								}
           
                                goto MISMATCH_RETRY_NP;
                            }
                        }
					
ALL_MISMATCHES_NP:						
						if ($post_pattern_match_extra eq "yes" && (($post_pattern_match eq "yes2" && $count_matches_with_high_scores > $sequencing_depth_NP) || $post_pattern_match eq "yes3")
							&& ($post_pattern_match_average eq "yes" || $full_reset_NP ne "") && $find_haps_in_seed eq "" && ($SNR_read_ahead eq "" || $post_pattern_match eq "yes3"))
						{
#Select reads based on all mismatches--------------------------------------------------------------------------------------  
							my %mismatch_pattern_all;
							undef %mismatch_pattern_all;
							my %mismatch_pattern;
							undef %mismatch_pattern;
							my %mismatch_pattern_N;
							undef %mismatch_pattern_N;
							my %split_patterns_final_score_no_rej;
							undef %split_patterns_final_score_no_rej;
							foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp13}})
								{
									if ($add_rejected_reads ne "" && $rank_tmp13 > $add_rejected_reads)
									{
										next;
									}
									if ($add_no_match_reads ne "" && $rank_tmp13 > $add_no_match_reads)
									{
										next;
									}
									$split_patterns_final_score_no_rej{$nuc_tmp13}{$rank_tmp13} = undef;
								}
							}
							
							my $count_groups_tmp = '0';
							my $check_mismatch_pattern1 = "0";
							foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score_no_rej)
							{
								my $total_count_tmp = '0';
								my $total_score_count_tmp = '0';
								my $count_ranks_tmp = keys %{$split_patterns_final_score_no_rej{$nuc_tmp13}};
								if ($count_ranks_tmp > 2 && $count_ranks_tmp > 0.16*$total_nuc_count)
								{
									$count_groups_tmp++;
									foreach my $rank_tmp13 (keys %{$split_patterns_final_score_no_rej{$nuc_tmp13}})
									{
										if (exists($rank_to_id{$rank_tmp13}))
										{
											my $id_tmpi = $rank_to_id{$rank_tmp13};
											foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_NP{$id_tmpi}})
											{
												$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi} = undef;
											}
											foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_all_NP{$id_tmpi}})
											{
												my @store_mismatches_all_NP = split /,/, $store_mismatches_all_NP{$id_tmpi}{$pos_snp_tmp};
												$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi} = $store_mismatches_all_NP[0]."+".$store_mismatches_all_NP[1];
											}
											foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_N_NP{$id_tmpi}})
											{
												my @store_mismatches_N_NP = split /,/, $store_mismatches_N_NP{$id_tmpi}{$pos_snp_tmp};
												$mismatch_pattern_N{$pos_snp_tmp}{$nuc_tmp13}{$store_mismatches_N_NP[1]}{$id_tmpi} = undef;
											}
										}
									}
								}	
							}
							print {$filehandle{$seed_id2}} $count_groups_tmp." CHECK_ALL_MISMATCHES\n";
							if ($count_groups_tmp > 1)
							{
								my $count_tmp = keys %mismatch_pattern_all;						
								my %pos_no_matches;
								undef %pos_no_matches;
								my %pos_no_matches1;
								undef %pos_no_matches1;
								my %rank_pattern;
								undef %rank_pattern;

								foreach my $pos_snp_tmp (sort {$b <=> $a} keys %mismatch_pattern_all)
								{
									my $one_nuc_match = "";
									my $one_nuc_no_match = "";
									my $gap_check_tmp = "";
									
									if (exists($mismatch_pattern{$pos_snp_tmp}))
									{
										my $total_rank_count = '0';
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
										{
											$total_rank_count += keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}}
										}
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
										{
											my $this_rank_count_tmp = keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}};
											if ($this_rank_count_tmp < 2 && $this_rank_count_tmp < 0.15*$total_rank_count)
											{
												foreach my $id_tmpi14 (sort {$a <=> $b} keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}})
												{
													delete $mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}{$id_tmpi14};
												}
												delete $mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14};
											}
										}
										if (keys %{$mismatch_pattern{$pos_snp_tmp}} eq '1')
										{
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern{$pos_snp_tmp}})
											{
												if (keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}} > 3)
												{
													my $rank_pattern_tmp = "";
													foreach my $id_tmpi14 (sort {$a <=> $b} keys %{$mismatch_pattern{$pos_snp_tmp}{$nuc_tmp14}})
													{
														if ($rank_pattern_tmp eq "")
														{
															$rank_pattern_tmp = $id_tmpi14;
														}
														else
														{
															$rank_pattern_tmp .= "_".$id_tmpi14
														}
													}
													$rank_pattern{$rank_pattern_tmp}{$nuc_tmp14}{$pos_snp_tmp} = 3;
												}
											}
										}
										
										foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score_no_rej)
										{
											my $nuc_mismatches_count = '0';
											my $gap_count_tmp = '0';
											my $too_short_count = '0';
											my $match_count = '0';
											my $total_count_tmp = '0';
											
											foreach my $rank_tmp13 (keys %{$split_patterns_final_score_no_rej{$nuc_tmp13}})
											{
												if (exists($rank_to_id{$rank_tmp13}))
												{
													my $id_tmpi = $rank_to_id{$rank_tmp13};
													if (exists($mismatch_pattern{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi}))
													{
														$nuc_mismatches_count++;
														my @mismatch_pattern_tmp = split /\+/, $mismatch_pattern{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi};
														if ($mismatch_pattern_tmp[0] eq "-" || $mismatch_pattern_tmp[1] eq "-")
														{
															$gap_count_tmp++;
														}
													}
													elsif (exists($alignment_length_save{$id_tmpi}))
													{
														my $overlap_tmp = $alignment_length_save{$id_tmpi};
														if ($position - $pos_snp_tmp > $overlap_tmp)
														{
															$too_short_count++;
														}
														else
														{
															$match_count++;
														}
													}
												}
												$total_count_tmp++;
											}
											if (($match_count < 2 && $nuc_mismatches_count > 2 && $nuc_mismatches_count > $total_count_tmp*0.3 && $nuc_mismatches_count > $match_count*4
												&& $match_count < $total_count_tmp*0.1) || ($match_count eq '0' && $nuc_mismatches_count > 2))
											{
												$one_nuc_no_match = $nuc_tmp13;
											}
											elsif (($nuc_mismatches_count < $total_count_tmp*0.1 && $match_count > 2 && $match_count > 3*$nuc_mismatches_count
												  ) || ($nuc_mismatches_count eq '0' && $match_count > 2))
											{
												$one_nuc_match = $nuc_tmp13;
											}
											if ($gap_count_tmp > $nuc_mismatches_count*0.4)
											{
												$gap_check_tmp = "yes";
											}
										}
									}
									
									if ($one_nuc_match ne "" && $one_nuc_no_match ne "")
									{
										if ($gap_check_tmp eq "yes")
										{
											$pos_no_matches{$one_nuc_no_match} += 0.7;
											$pos_no_matches1{$one_nuc_no_match} += 0.35;
										}
										else
										{
											$pos_no_matches{$one_nuc_no_match} += 4;
											$pos_no_matches1{$one_nuc_no_match} += 1;
										}
										$check_mismatch_pattern1 += 1;
										print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_PATTERN_MATCH1\n";
										print {$filehandle{$seed_id2}} $one_nuc_no_match." FINAL_PATTERN_MATCH_NUC1\n";
									}
									else
									{
										$one_nuc_match = "";
										$one_nuc_no_match = "";
									
										my $total_rank_count = '0';
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern_all{$pos_snp_tmp}})
										{
											$total_rank_count += keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}}
										}
										foreach my $nuc_tmp14 (keys %{$mismatch_pattern_all{$pos_snp_tmp}})
										{
											my $this_rank_count_tmp = keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}};
											if ($this_rank_count_tmp < 2 && $this_rank_count_tmp < 0.15*$total_rank_count)
											{
												foreach my $id_tmpi14 (sort {$a <=> $b} keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}})
												{
													delete $mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}{$id_tmpi14};
												}
												delete $mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14};
											}
										}
										
										if (keys %{$mismatch_pattern_all{$pos_snp_tmp}} eq '1')
										{
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern_all{$pos_snp_tmp}})
											{
												if (keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}} > 3)
												{
													my $rank_pattern_tmp = "";
													foreach my $id_tmpi14 (sort {$a <=> $b} keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}})
													{
														if ($rank_pattern_tmp eq "")
														{
															$rank_pattern_tmp = $id_tmpi14;
														}
														else
														{
															$rank_pattern_tmp .= "_".$id_tmpi14
														}
													}
													$rank_pattern{$rank_pattern_tmp}{$nuc_tmp14}{$pos_snp_tmp} = 0.1;
												}
											}
										}
										
										my $gap_check_tmp2 = "";
										foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score_no_rej)
										{
											my $nuc_mismatches_count = '0';
											my $gap_count_tmp = '0';
											my $too_short_count = '0';
											my $match_count = '0';
											my $total_count_tmp = '0';
											
											foreach my $rank_tmp13 (keys %{$split_patterns_final_score_no_rej{$nuc_tmp13}})
											{
												if (exists($rank_to_id{$rank_tmp13}))
												{
													my $id_tmpi = $rank_to_id{$rank_tmp13};
													if (exists($mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi}))
													{
														$nuc_mismatches_count++;
														my @mismatch_pattern_all_tmp = split /\+/, $mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp13}{$id_tmpi};
														if ($mismatch_pattern_all_tmp[0] eq "-" || $mismatch_pattern_all_tmp[1] eq "-")
														{
															$gap_count_tmp++;
														}
													}
													elsif (exists($alignment_length_save{$id_tmpi}))
													{
														my $overlap_tmp = $alignment_length_save{$id_tmpi};
														if ($position - $pos_snp_tmp > $overlap_tmp)
														{
															$too_short_count++;
														}
														else
														{
															$match_count++;
														}
													}
												}
												$total_count_tmp++;
											}
											if (($match_count < 2 && $nuc_mismatches_count > 2 && $nuc_mismatches_count > $total_count_tmp*0.3 && $nuc_mismatches_count > $match_count*4
												&& $match_count < $total_count_tmp*0.1) || ($match_count eq '0' && $nuc_mismatches_count > 2))
											{
												$one_nuc_no_match = $nuc_tmp13;
											}
											elsif (($nuc_mismatches_count < $total_count_tmp*0.1 && $match_count > 2 && $match_count > 3*$nuc_mismatches_count
												  ) || ($nuc_mismatches_count eq '0' && $match_count > 2))
											{
												$one_nuc_match = $nuc_tmp13;
											}
											if ($gap_count_tmp > $nuc_mismatches_count*0.4)
											{
												$gap_check_tmp2 = "yes";
											}
										}
										if ($one_nuc_match ne "" && $one_nuc_no_match ne "")
										{
											if ($gap_check_tmp2 eq "yes")
											{
												$pos_no_matches{$one_nuc_no_match} += 0.2;
											}
											else
											{
												$pos_no_matches{$one_nuc_no_match} += 1;
											}
											
											print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_PATTERN_MATCH2\n";
											print {$filehandle{$seed_id2}} $one_nuc_no_match." FINAL_PATTERN_MATCH_NUC2\n";
										}
									}
								}
	
								my $nuc_to_delete = '0';
								my $nuc_to_delete2 = '0';
								my $count_below_5 = '0';
								my $high_pos_count = "";
								my $high_pos_nuc = "";
								my $rank1_check = "";
								foreach my $nuc (keys %pos_no_matches)
								{
									my $pos_count = $pos_no_matches{$nuc};
									$nuc_to_delete++;
									print {$filehandle{$seed_id2}} $nuc." NUC\n";
									print {$filehandle{$seed_id2}} $pos_count." POS_COUNT\n";
									if ($pos_count > 5 || (keys %pos_no_matches < 2 && $pos_count > 4 && $post_pattern_match eq "yes3"))
									{
										$nuc_to_delete2++;
										foreach my $rank_tmp14 (keys %{$split_patterns_final_score_no_rej{$nuc}})
										{
											$reads_to_remove{$rank_tmp14}{$rank_tmp14} = undef;
											if ($rank_tmp14 < 5)
											{
												$count_below_5++;
											}
											if ($rank_tmp14 eq "1")
											{
												$rank1_check = "yes";
												foreach my $length_tmp (keys %longest_match)
												{
													if ($length_tmp ne $longest_longest_match && $length_tmp > 0.85*$longest_longest_match)
													{
														$rank1_check = "";
													}
												}
											}
										}
										$high_pos_count = $pos_count;
										$high_pos_nuc = $nuc;
									}
									print {$filehandle{$seed_id2}} $count_below_5." COUNT_BELOW_5\n";
								}
								my $multi_match_check = "";
								foreach my $nuc (keys %pos_no_matches)
								{
									if ($high_pos_nuc ne $nuc)
									{
										my $pos_count = $pos_no_matches{$nuc};
										if (exists($pos_no_matches1{$nuc}))
										{
											$multi_match_check = "no";
										}
										elsif ($pos_count > $high_pos_count*0.2)
										{
											$multi_match_check = "no";
										}
									}
								}
								
								my $pos_no_matches1_check = "";
								if (keys %pos_no_matches1 eq '1')
								{
									foreach my $nuci (keys %pos_no_matches1)
									{
										if ($pos_no_matches1{$nuci} > 6 || ($NP_reads_support ne "" && $pos_no_matches1{$nuci} > 0))
										{
											$pos_no_matches1_check = $nuci;
											$high_pos_nuc = $nuci;
										}
									}
								}
								if ($pos_no_matches1_check ne "" && $nuc_to_delete2 > 1)
								{
									undef %reads_to_remove;
									foreach my $rank_tmp14 (keys %{$split_patterns_final_score{$pos_no_matches1_check}})
									{
										$reads_to_remove{$rank_tmp14}{$rank_tmp14} = undef;
									}
								}
								$multi_match_check = "no";
								foreach my $pos_tmpi (keys %{$split_positions_VIP{$seed_id}})
								{
									if ($pos_tmpi > $position-$lowest_longest_match)
									{
										#$multi_match_check = "";
									}
								}
								if ($trace_back_check ne "")
								{
									$multi_match_check = "no";
								}
								my $high_pos_count_limit = '60';
								if ($NP_reads_support ne "")
								{
									$multi_match_check = "";
									$high_pos_count_limit = '3';
								}
								print {$filehandle{$seed_id2}} $multi_match_check." MULTIM_CHECK\n";
								if (((($nuc_to_delete eq '1' || ($high_pos_count > 60 && $check_mismatch_pattern1 > 1)) && ($check_mismatch_pattern1 > 4 || $high_pos_count > 60 || $multi_match_check eq "")
									  && $nuc_to_delete2 eq '1' && ($count_below_5 < 3 || ($high_pos_count > 20 && $count_below_5 < 4 && $total_nuc_count > 10)))
									 || $pos_no_matches1_check ne "") && ($rank1_check eq "" || ($count_below_5 < 3 && $nuc_to_delete eq '1' && $high_pos_count > 10) || $high_pos_count > $high_pos_count_limit) && $check_mismatch_pattern1 > 0
									&& ($check_mismatch_pattern1 > 4 || $high_pos_count > $high_pos_count_limit) && $remove_reads eq "")
								{
									$remove_reads = "yes";
									print {$filehandle{$seed_id2}} $high_pos_nuc." REMOVE_BY_all_MISMATCH\n";
									
									my $one_nuc_match_tmp = "";
									foreach my $nuc_tmp13 (sort {$a <=> $b} keys %split_patterns_final_score_no_rej)
									{
										my $count_ranks_tmp = keys %{$split_patterns_final_score_no_rej{$nuc_tmp13}};
										if ($nuc_tmp13 ne $high_pos_nuc && $count_ranks_tmp > $total_nuc_count*0.25)
										{
											if ($one_nuc_match_tmp eq "")
											{
												$one_nuc_match_tmp = $nuc_tmp13
											}
											else
											{
												$one_nuc_match_tmp = "";
												last;
											}
										}
									}
									#if ($one_nuc_match_tmp ne "")
									#{
										#my $last_11 = substr $best_extension, -11, 11;
										#$track_split_NP{$id}{$position+length($best_extension)} = $last_10."+".$one_nuc_match_tmp;
										#foreach my $posie_tmp (keys %SNP_patterns_prev_match)
										#{
											#my $last_10_tmp = substr $best_extension, $posie_tmp-$position-10, 10;
											#$track_split_NP{$id}{$posie_tmp} = $last_10_tmp."+".$SNP_patterns_prev_match{$posie_tmp};
										#}
									#}
									
									goto REMOVE_READS_NP;
								}
#Go back to resolve previous SNP position-----------------------------------------------------------------------------------------------------------------
								elsif ($post_pattern_match eq "yes3")
								{				
									undef %trace_back_split_NP_backup;
									undef %reads_to_remove;
									my $found_pos = "";
									my $A1 = '2';
									my $A2 = '3';
									if ($high_quality_ONT eq "yes")
									{
										$A1 = '1';
										$A2 = '1';
									}

									foreach my $pos_snp_tmp (sort {$a <=> $b} keys %mismatch_pattern_N)
									{
										my %N_matches;
										undef %N_matches;
										my %N_matches2;
										undef %N_matches2;
										my %N_matches3;
										undef %N_matches3;
										if (exists($quality_scores{$seed_id}{$pos_snp_tmp}))
										{
											my @q_score_tmp = split / /, $quality_scores{$seed_id}{$pos_snp_tmp};
											my $total_tmp = $q_score_tmp[1]+$q_score_tmp[2]+$q_score_tmp[3]+$q_score_tmp[4]+$q_score_tmp[5];
											my $count_check_tmp = '0';
											my $UU = '1';
											while ($UU < 5)
											{
												if ($q_score_tmp[$UU] > 0.15*$total_tmp)
												{
													$count_check_tmp++;
												}
												$UU++;
											}
											if ($count_check_tmp eq '2' && $high_quality_ONT eq "yes")
											{
												$A1 = '0';
												$A2 = '0';
											}
											elsif ($count_check_tmp eq '2' && $high_quality_ONT eq "")
											{
												$A1 = '2';
												$A2 = '2';
											}
										}
											
										foreach my $nuc_split14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}})
										{
											my $total_pattern_count_tmp = '0';
											my $split_patterns_count_tmp = keys %{$split_patterns_final_score_no_rej{$nuc_split14}};
											my $gap_count_tmp = '0';
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}})
											{
												$total_pattern_count_tmp += keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}{$nuc_tmp14}};
												if ($nuc_tmp14 eq '-')
												{
													$gap_count_tmp = keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}{$nuc_tmp14}};
												}
											}
											if ($gap_count_tmp < $total_pattern_count_tmp*0.21)
											{
												$total_pattern_count_tmp -= $gap_count_tmp;
											}
											my $print_tmp = "";
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}})
											{
												my $nuc_count_tmp4 = keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}{$nuc_tmp14}};
												if ($nuc_count_tmp4 > 0.8*$total_pattern_count_tmp && $nuc_count_tmp4 > $A1 && ($nuc_count_tmp4 > $split_patterns_count_tmp*0.25 || $nuc_count_tmp4 > $A2))
												{
													$N_matches{$nuc_tmp14} = $nuc_count_tmp4;
													$N_matches2{$nuc_tmp14} = $split_patterns_count_tmp;
													$N_matches3{$nuc_tmp14} = $total_pattern_count_tmp;
													my $last_10 = substr $read, $pos_snp_tmp-11, 10;							
													$print_tmp = "yes";
												}
											}
											if ($print_tmp eq "yes")
											{
												foreach my $nuc_tmp14 (keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}})
												{
													my $nuc_count_tmp4 = keys %{$mismatch_pattern_N{$pos_snp_tmp}{$nuc_split14}{$nuc_tmp14}};
													my $last_10 = substr $read, $pos_snp_tmp-11, 10;
													print {$filehandle{$seed_id2}} $pos_snp_tmp." ".$nuc_tmp14." ".$nuc_count_tmp4." ".$nuc_split14." ".$last_10." N_MATCH\n";
												}
											}
										}
										if (keys %N_matches > 1)
										{
											print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_N_PATTERN_MATCH\n";
											my $indel_check_tmp = "";
											my $score_tmp = '0';
											foreach my $nuc_tmp15 (keys %N_matches)
											{
												if ($nuc_tmp15 eq "-")
												{
													$indel_check_tmp = "yes";
													print {$filehandle{$seed_id2}} $nuc_tmp15." GAP\n";
												}
												$score_tmp += $N_matches{$nuc_tmp15};
											}
											
											my $last_11 = substr $read, $pos_snp_tmp-12, 11;
											my $N_check = $last_11 =~ tr/N/N/;
											if ($N_check > 0)
											{
												$score_tmp *= 0.85;
											}
											
N_MATCHES_NP:								foreach my $nuc_tmp15 (keys %N_matches)
											{
												foreach my $pos_tb_tmp (keys %{$trace_back_split_NP{$id}})
												{
													if ($pos_snp_tmp > $pos_tb_tmp-30 && $pos_snp_tmp < $pos_tb_tmp+30)
													{
														print {$filehandle{$seed_id2}} $pos_tb_tmp." SIM_POS\n";
														next N_MATCHES_NP;
													}
												}
												if (exists($trace_back_split_NP{$id}{$pos_snp_tmp}))
												{
													print {$filehandle{$seed_id2}} $pos_snp_tmp." POS_EXISTS\n";
												}
												elsif ($indel_check_tmp eq "")
												{
													print {$filehandle{$seed_id2}} $last_11." LAST11\n";
													my $last_8 = substr $read, $pos_snp_tmp-9, 8;
													my $AT_rich_tmp = AT_rich_test ($last_8, '1');
													my $next_8 = substr $read, $pos_snp_tmp, 8;
													my $AT_rich_tmp2 = AT_rich_test ($next_8, '1');
													
													my $last_3 = substr $read, $pos_snp_tmp-4, 3;
													my $next_3 = substr $read, $pos_snp_tmp, 3;
													my $next_last = $last_3.$next_3;
													my $AT_rich_tmp3 = AT_rich_test ($next_last, '1');

													if ($AT_rich_tmp ne "yes" && $AT_rich_tmp2 ne "yes" && $AT_rich_tmp3 ne "yes")
													{
														my $last_20 = substr $read, $pos_snp_tmp-21, 20;
														my $next_20 = substr $read, $pos_snp_tmp, 20;
														my $AT_rich_tmp2a = AT_rich_test ($last_20, '1');
														my $AT_rich_tmp2b = AT_rich_test ($next_20, '1');
														my $last_5 = substr $read, $pos_snp_tmp-6, 5;
														my $next_5 = substr $read, $pos_snp_tmp, 5;
														my $AT_rich_tmp2c = AT_rich_test2 ($last_5, '0');
														my $AT_rich_tmp2d = AT_rich_test2 ($next_5, '0');
														my $extra_check_tmp = "";
														foreach my $nuc_tmp15 (keys %N_matches)
														{
															print {$filehandle{$seed_id2}} $N_matches{$nuc_tmp15}." ".$N_matches2{$nuc_tmp15}." ".$N_matches3{$nuc_tmp15}." STATS\n";
															if ($N_matches{$nuc_tmp15} > $N_matches3{$nuc_tmp15}*0.9 && (($N_matches{$nuc_tmp15} > 4 && $N_matches{$nuc_tmp15} > $N_matches2{$nuc_tmp15}*0.5)
															   || $N_matches{$nuc_tmp15} > 6 || $N_matches{$nuc_tmp15} > $N_matches2{$nuc_tmp15}*0.7))
															{
																if ($extra_check_tmp eq "")
																{
																	$extra_check_tmp = "ye";
																}
																else
																{
																	$extra_check_tmp = "yes";
																}
															}
														}
														print {$filehandle{$seed_id2}} $AT_rich_tmp2a." ".$AT_rich_tmp2b." ".$AT_rich_tmp2c." ".$AT_rich_tmp2d." STATS_SNR\n";
														if (($AT_rich_tmp2a ne "yes" && $AT_rich_tmp2b ne "yes" && $AT_rich_tmp2c ne "yes" && $AT_rich_tmp2d ne "yes") || $extra_check_tmp eq "yes")
														{
															foreach my $pos_snp_tmp2 (keys %{$trace_back_split_NP{$id}})
															{
																if ($pos_snp_tmp2 > $pos_snp_tmp-1000 && $pos_snp_tmp2 < $pos_snp_tmp+1000)
																{
																	if ($last_11 eq $trace_back_split_NP{$id}{$pos_snp_tmp2})
																	{
																		next N_MATCHES_NP;
																	}
																}
															}
															foreach my $pos_snp_tmp2 (keys %{$trace_back_split_NP_exclude{$id}})
															{
																if ($pos_snp_tmp2 > $pos_snp_tmp-1000 && $pos_snp_tmp2 < $pos_snp_tmp+1000)
																{
																	if ($last_11 eq $trace_back_split_NP_exclude{$id}{$pos_snp_tmp2})
																	{
																		next N_MATCHES_NP;
																	}
																}
															}
															$trace_back_split_NP_backup{$score_tmp}{$pos_snp_tmp} = $last_11;
															print {$filehandle{$seed_id2}} $nuc_tmp15." FINAL_N_PATTERN_MATCH_NUC\n";
															print {$filehandle{$seed_id2}} $N_matches{$nuc_tmp15}." FINAL_N_PATTERN_MATCH_COUNT\n";
															print {$filehandle{$seed_id2}} $last_11." LAST11\n";
		
															if ($found_pos eq "")
															{
																$found_pos = $pos_snp_tmp;
															}
														}
													}
												}
											}		
										}
									}
									
									if ($found_pos eq "")
									{
										my $yy = keys %mismatch_pattern_all;
										print {$filehandle{$seed_id2}} $yy." MISMATCH_PATTER_ALL\n";
MISMATCH_PATTER_ALL:					foreach my $pos_snp_tmp (sort {$a <=> $b} keys %mismatch_pattern_all)
										{
											my %all_matches;
											undef %all_matches;
											my %nuc_matches;
											undef %nuc_matches;
											my %nuc_matches2;
											undef %nuc_matches2;
											my $total_pattern_count_tmp = '0';
											my $nucie_tmp = '0';
											my $nucie_tmp2 = '0';
						my $within_range2 = "";					
											foreach my $nuc_tmp14 (keys %{$mismatch_pattern_all{$pos_snp_tmp}})
											{
												my $tmp_count = keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}};
												$total_pattern_count_tmp += $tmp_count;

												foreach my $id_tmp14 (keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}})
												{
													my $nuc_tmp2 = $mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14}{$id_tmp14};
													my @nuc_tmp2 = split /\+/, $nuc_tmp2;
													$nuc_matches{$nuc_tmp2[0]} += 1;
													$nuc_matches2{$nuc_tmp2[1]} += 1;
												}
												
												if ($nuc_matches2{"-"} < $tmp_count*0.3)
												{
													$tmp_count -= $nuc_matches2{"-"};
												}
												
												foreach my $nuc_tmp15 (keys %nuc_matches)
												{
													if ($nuc_matches{$nuc_tmp15} > 0.87*$tmp_count && $tmp_count > 4)
													{
														if ($nuc_matches{$nuc_tmp15} ne "-")
														{
															$nucie_tmp += 1;
														}
													}
												}
												foreach my $nuc_tmp15 (keys %nuc_matches2)
												{
													if ($nuc_matches2{$nuc_tmp15} > 0.87*$tmp_count && $tmp_count > 4)
													{
														if ($nuc_matches2{$nuc_tmp15} ne "-")
														{
															$nucie_tmp2 += 1;
														}
													}
												}
											}
											
											
											if ($nucie_tmp < 1 || $nucie_tmp2 < 1)
											{
												next MISMATCH_PATTER_ALL;
											}
											my $score_tmp = '0';
											my $match_check = "";
											my $no_match_check = "";
											my $no_match_count = "";
											
											foreach my $nuc_tmp14b (keys %split_patterns_final_score_no_rej)
											{
												my $count_ranks_tmp = keys %{$split_patterns_final_score_no_rej{$nuc_tmp14b}};
												if ($count_ranks_tmp > 2 && $count_ranks_tmp > 0.18*$total_nuc_count)
												{
													my $within_range = '0';
													my $total_count_tmp = '0';
													foreach my $rank_tmp13 (keys %{$split_patterns_final_score_no_rej{$nuc_tmp14b}})
													{
														if (exists($rank_to_id{$rank_tmp13}))
														{
															my $id_tmpi = $rank_to_id{$rank_tmp13};
															
															if (exists($alignment_length_save{$id_tmpi}))
															{
																my $overlap_tmp = $alignment_length_save{$id_tmpi};
																if ($position - $pos_snp_tmp > $overlap_tmp)
																{
																}
																else
																{
																	$within_range++;
																}
															}
														}
														$total_count_tmp++;
													}
													if ($within_range eq 2)
													{
														if (exists($mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14b}))
														{
															my $nuc_count_tmp4 = keys %{$mismatch_pattern_all{$pos_snp_tmp}{$nuc_tmp14b}};
															if ($nuc_count_tmp4 < 0.1*$within_range)
															{
																$match_check = $nuc_tmp14b;
															}
															elsif ($nuc_count_tmp4 > 4 && $nuc_count_tmp4 > 0.9*$within_range && ($nuc_count_tmp4 > $total_count_tmp*0.5 || $nuc_count_tmp4 > 5))
															{
																$no_match_check = $nuc_tmp14b;
																$no_match_count = $nuc_count_tmp4;
															}
														}
														else
														{
															$match_check = $nuc_tmp14b;
														}
													}
												}
											}
												
											if ($match_check ne "" && $no_match_check ne "")
											{
												$all_matches{$no_match_check} = $no_match_count;
												print {$filehandle{$seed_id2}} $no_match_check." FINAL_ALL_PATTERN_MATCH_TEST\n";
											}
												
											if (keys %all_matches eq 1)
											{
												print {$filehandle{$seed_id2}} $pos_snp_tmp." FINAL_ALL_PATTERN_MATCH\n";
												
												my $last_11 = substr $read, $pos_snp_tmp-12, 11;
												my $N_check = $last_11 =~ tr/N/N/;
												if ($N_check > 0)
												{
													$score_tmp *= 0.85;
												}
	
ALL_MATCHES_NP:  								foreach my $nuc_tmp15 (keys %all_matches)
												{
													if ($nuc_tmp15 ne "-")
													{
														print {$filehandle{$seed_id2}} $nuc_tmp15." FINAL_ALL_PATTERN_MATCH_NUC\n";
														print {$filehandle{$seed_id2}} $all_matches{$nuc_tmp15}." FINAL_ALL_PATTERN_MATCH_COUNT\n";
												
														foreach my $pos_tb_tmp (keys %{$trace_back_split_NP{$id}})
														{
															if ($pos_snp_tmp > $pos_tb_tmp-50 && $pos_snp_tmp < $pos_tb_tmp+50)
															{
																next ALL_MATCHES_NP;
															}
														}
														if (exists($trace_back_split_NP{$id}{$pos_snp_tmp}))
														{}
														else
														{
															print {$filehandle{$seed_id2}} $last_11." LAST10\n";
															my $last_8 = substr $read, $pos_snp_tmp-9, 8;
															my $AT_rich_tmp = AT_rich_test ($last_8, '1');
															my $next_8 = substr $read, $pos_snp_tmp, 8;
															my $AT_rich_tmp2 = AT_rich_test ($next_8, '1');
															
															my $last_3 = substr $read, $pos_snp_tmp-4, 3;
															my $next_3 = substr $read, $pos_snp_tmp, 3;
															my $next_last = $last_3.$next_3;
															my $AT_rich_tmp3 = AT_rich_test ($next_last, '1');
		
															if ($AT_rich_tmp ne "yes" && $AT_rich_tmp2 ne "yes" && $AT_rich_tmp3 ne "yes")
															{
																foreach my $pos_snp_tmp2 (keys %{$trace_back_split_NP{$id}})
																{
																	if ($pos_snp_tmp2 > $pos_snp_tmp-1000 && $pos_snp_tmp2 < $pos_snp_tmp+1000)
																	{
																		if ($last_11 eq $trace_back_split_NP{$id}{$pos_snp_tmp2})
																		{
																			next ALL_MATCHES_NP;
																		}
																	}
																}
																foreach my $pos_snp_tmp2 (keys %{$trace_back_split_NP_exclude{$id}})
																{
																	if ($pos_snp_tmp2 > $pos_snp_tmp-1000 && $pos_snp_tmp2 < $pos_snp_tmp+1000)
																	{
																		if ($last_11 eq $trace_back_split_NP_exclude{$id}{$pos_snp_tmp2})
																		{
																			next ALL_MATCHES_NP;
																		}
																	}
																}
										
																$trace_back_split_NP_backup{$score_tmp}{$pos_snp_tmp} = $last_11;
																print {$filehandle{$seed_id2}} length($read)." READ\n";
																print {$filehandle{$seed_id2}} $pos_snp_tmp." POS\n";
																print {$filehandle{$seed_id2}} $last_11." LAST11\n";
																
																if ($found_pos eq "")
																{
																	$found_pos = $pos_snp_tmp;
																}
															}
														}
													}
												}		
											}
										}
									}

									if ($found_pos ne "")
									{
										foreach my $score_tmpi (sort {$b <=> $a} keys %trace_back_split_NP_backup)
										{
											foreach my $pos_tmpi (sort {$b <=> $a} keys %{$trace_back_split_NP_backup{$score_tmpi}})
											{
												$trace_back_split_NP{$id}{$pos_tmpi} = $trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi};
												if ($NP_reads_support ne "")
												{
													$trace_back_split_PB{$id}{$pos_tmpi} = $trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi};
												}
												print {$filehandle{$seed_id2}} $pos_tmpi." TRACE_BACK_POS\n";
												$found_pos = $pos_tmpi;
												last;
											}
											last;
										}
										foreach my $score_tmpi (sort {$b <=> $a} keys %trace_back_split_NP_backup)
										{
											foreach my $pos_tmpi (sort {$b <=> $a} keys %{$trace_back_split_NP_backup{$score_tmpi}})
											{
												if ($pos_tmpi > $found_pos)
												{
													$trace_back_split_NP{$id}{$pos_tmpi} = $trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi};
													if ($NP_reads_support ne "")
													{
														$trace_back_split_PB{$id}{$pos_tmpi} = $trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi};
													}
													print {$filehandle{$seed_id2}} $pos_tmpi." TRACE_BACK_POS2\n";
												}
											}
										}
										
										$read = substr $read, 0, $found_pos-800;									
										delete $exclude_reads_NP{$seed_id};
										delete $save_alignment_data_NP{$seed_id};
										delete $rejected_alignment_data_NP{$seed_id};
										$position = length($read);
										$position{$id} = $position;
										$seed{$id} = $read;
										foreach my $pos_split (keys %{$split_positions{$id}})
										{
											if (exists($split_positions_VIP{$id}{$pos_split}))
											{}
											elsif ($pos_split > $position)
											{
												delete $split_positions{$id}{$pos_split};
											}
										}
										foreach my $pos_split (keys %{$split_positions_DUP{$id}})
										{
											if (exists($split_positions_VIP{$id}{$pos_split}))
											{}
											elsif ($pos_split > $position)
											{
												delete $split_positions_DUP{$id}{$pos_split};
												delete $split_positions_DUP2{$id}{$pos_split};
											}
										}
										
										if ($hap_compare_pos{$id} > $position)
										{
											$hap_compare_pos{$id} = $position;
										}
										
										print {$filehandle{$seed_id2}} $position." ".$best_extension."\nHALLE5\n";
										$best_extension = "";
										$halle5 = "yes";
										
										if ($NP_reads_support ne "")
										{
											delete $exclude_reads_PB{$seed_id};
											delete $save_alignment_data_PB{$seed_id};
											delete $rejected_alignment_data_PB{$seed_id};
											goto PB_READS;
										}
										goto NP_READS;
									}

									my %score_by_nuc;
									undef %score_by_nuc;
									foreach my $rank_pattern_tmp13 (sort {$a <=> $b} keys %rank_pattern)
									{
										if (keys %{$rank_pattern{$rank_pattern_tmp13}} eq '1')
										{
											foreach my $nuc_tmp14 (keys %{$rank_pattern{$rank_pattern_tmp13}})
											{
												if (keys %{$rank_pattern{$rank_pattern_tmp13}{$nuc_tmp14}} > 3)
												{
													my $count_tmp = '0';
													my $score_tmp = '0';
													foreach my $pos_snp_tmp (keys %{$rank_pattern{$rank_pattern_tmp13}{$nuc_tmp14}})
													{
														$count_tmp++;
														$score_tmp += $rank_pattern{$rank_pattern_tmp13}{$nuc_tmp14}{$pos_snp_tmp};
													}
													if ($count_tmp > 4 && $score_tmp > 5)
													{
														print {$filehandle{$seed_id2}} $rank_pattern_tmp13." RANK_PATTERN_TEST\n";
														print {$filehandle{$seed_id2}} $nuc_tmp14." NUC ".$count_tmp." COUNT ".$score_tmp." SCORE\n";
														$score_by_nuc{$nuc_tmp14} += $score_tmp;
													}
												}
											}
										}
									}
									my $nuc_to_remove = "";
									if (keys %score_by_nuc eq '1')
									{ 
										foreach my $nuc_tmp41 (keys %score_by_nuc)
										{
											if (($score_by_nuc{$nuc_tmp41} > 18 || ($N > 10 && $N_resolved > length($best_extension)*0.08 && $score_by_nuc{$nuc_tmp41} > 12)) && $split_patterns_final{'1'} ne $nuc_tmp41)
											{
												foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
												{
													if ($split_patterns_final{$rank_tmp8} eq $nuc_tmp41)
													{
														$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
														$remove_reads = "yes";
														$nuc_to_remove = $nuc_tmp41;
														if ($rank_tmp8 eq '1')
														{
															$remove_reads = "";
															undef %reads_to_remove;
															last;
														}
													}
												}
											}
										}
									}
									elsif ($post_pattern_match eq "yes3" && $N > 10 && $N_resolved > length($best_extension)*0.08)
									{
SCORE_BY_NUC_NP:     					foreach my $nuc_tmp41 (keys %score_by_nuc)
										{
											if ($score_by_nuc{$nuc_tmp41} > 15)
											{
												foreach my $nuc_tmp41b (keys %score_by_nuc)
												{
													if ($nuc_tmp41 ne $nuc_tmp41b && $score_by_nuc{$nuc_tmp41} > $score_by_nuc{$nuc_tmp41b}*5 && $nuc_to_remove eq "")
													{
														$nuc_to_remove = $nuc_tmp41;
													}
													elsif ($nuc_tmp41 ne $nuc_tmp41b && $score_by_nuc{$nuc_tmp41} > $score_by_nuc{$nuc_tmp41b}*5)
													{
														$nuc_to_remove = "";
														last SCORE_BY_NUC_NP;
													}
												}
											}
										}
										if ($split_patterns_final{'1'} ne $nuc_to_remove)
										{
											foreach my $rank_tmp8 (sort {$a <=> $b} keys %split_patterns_final)
											{
												if ($split_patterns_final{$rank_tmp8} eq $nuc_to_remove)
												{
													$reads_to_remove{$rank_tmp8}{$rank_tmp8} = undef;
													$remove_reads = "yes";
													if ($rank_tmp8 eq '1')
													{
														$remove_reads = "";
														undef %reads_to_remove;
														last;
													}
												}
											}
										}
									}
																			
									if ($remove_reads eq "yes")
									{
										my $reads_to_remove = '0';
										foreach my $rank_tmp0 (keys %reads_to_remove)
										{
											foreach my $rank_tmp2 (keys %{$reads_to_remove{$rank_tmp0}})
											{
												$reads_to_remove++;
											}
										}
										if ($reads_to_remove < $total_nuc_count*0.68 && ($total_nuc_count - $reads_to_remove >= 6 || $post_pattern_match ne "yes3"))
										{
											print {$filehandle{$seed_id2}} $nuc_to_remove." NUC ".$score_by_nuc{$nuc_to_remove}." REMOVE_BY_RANK_PATTERN\n";
											foreach my $rank_tmp0 (keys %reads_to_remove)
											{
												foreach my $rank_tmp2 (keys %{$reads_to_remove{$rank_tmp0}})
												{
													my $id_tmp0 = $rank_to_id{$rank_tmp2};
													delete $read_start_pos_rej{$id_tmp0};
												}
											}
											goto REMOVE_READS_NP;
										}
										else
										{
											$remove_reads = "";
											undef %reads_to_remove;
										}
									}
									elsif ($one_rej_read_found eq "yes")
									{
										$one_rej_read_found = "yes2";
										goto ADD_REJ_NP;
									}
									elsif ($trace_back_check ne "")
									{
										$trace_back_split_NP_exclude{$id}{$trace_back_check} = $trace_back_split_NP{$id}{$trace_back_check};
										$trace_back_check = "";
										$post_pattern_match = "";
										delete $trace_back_split_NP{$id}{$trace_back_check};
										my $count_tmp8 = '0';
										foreach my $pos_tmp (keys %{$trace_back_split_NP{$id}})
										{
											$count_tmp8++;
											print {$filehandle{$seed_id2}} $pos_tmp." TRACE_BACK_POS\n";
										}
										if ($count_tmp8 eq '0')
										{
											$unresolvable_NP = "yes2";
											print {$filehandle{$seed_id2}} "TRACE_BACK_DEAD_END\n";
										}
									}
								}
								undef %reads_to_remove;
							}
						}
                        
                        my $time_split3 = time;
     my $testy_time2 = $time_split2-$time_split3;
     if ($testy_time2 > 0)
    {
        print {$filehandle{$seed_id2}} $testy_time2." TIME_CHECK_SPLIT2\n";
    }
                    }
					my $count_options = '0';
					foreach my $nucs_tmp (keys %nucs)
					{
						if ($nucs{$nucs_tmp} > 2 || $nucs{$nucs_tmp} > 0.3*$total_nuc_count || $nucs{$nucs_tmp} > $sequencing_depth_NP*0.2)
						{
							$count_options++;
						}
					}
					if ($post_pattern_match eq "yes3" && $full_reset_NP eq "" && $find_haps_in_seed eq "" && $SNR_read_ahead eq "" && $NP_reads_support eq "" && $post_pattern_match_count > 2)
                    {
                        delete $exclude_reads_NP{$seed_id};
						#delete $save_alignment_data_NP{$seed_id};
						delete $rejected_alignment_data_NP{$seed_id};
						$full_reset_NP = $best_extension;
						print {$filehandle{$seed_id2}} $best_extension." FULL_RESET\n";

						$best_extension = "";
						$seed_id = $id;
						$y++;
						$y{$id} = $y;
						goto FULL_RESET;
                    }
					if ($post_pattern_match eq "yes3" && $full_reset_time ne "" && $find_haps_in_seed eq "" && $SNR_read_ahead eq "" && $NP_reads_support eq "" && $post_pattern_match_count > 2)
                    {
						$full_reset_time = "";
						$full_reset_time_stop{$seed_id} = $full_reset_time{$seed_id};
						delete $full_reset_time{$seed_id};
						print {$filehandle{$seed_id2}} $best_extension." FULL_RESET_TIME_STOP\n";

						$mismatch_retry++;
						$best_extension = "";
						$best_extension_part = "";
						undef %quality_scores_tmp;
						undef %id_matches;
						undef %double_matches;
						undef %reverse_list;
						undef %hash_NP_reads_tmp;
                        goto SKIP_CONFIRMED_NP;
                    }
					elsif ($high_quality eq "" && $post_pattern_match eq "yes3" && ($N_resolved > length($best_extension)*0.08 || $local_pattern_matches2 > 8) && $trace_back_check eq ""
						   && $post_pattern_match_count > 2 && $find_haps_in_seed eq "" && $PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $count_options > 1 && ($SNR_read_ahead eq "" || $local_pattern_matches2 > 10))
                    {
						print {$filehandle{$seed_id2}} $best_extension." LAST_EXTENSION0\n";
						$high_quality = "yes";
						$mismatch_retry++;
						$best_extension = "";
						$best_extension_part = "";
						undef %quality_scores_tmp;
                        goto SELECT_LENGTH_NP;
					}
					
#Add rejected and no match reads to look for more VIP positions---------------------------------------------------------------------------------------------------------------------------------------------

					elsif ($unresolvable_NP eq "yes2" || ($post_pattern_match eq "yes3" && $trace_back_check eq "" && $post_pattern_match_count > 2 && $find_haps_in_seed eq "" && $PB_reads eq ""
						   && $input_reads_DB_folder_PB eq "" && $count_options > 1 && $SNR_read_ahead eq "" && $add_rejected_reads eq "" && $add_no_match_reads eq "") && $add_rejected_and_no_match_reads eq "")
                    {
						my $count_tmp = '0';
						my $count_tmp3 = '0';
						my %read_start_pos_rej_tmp;
						undef %read_start_pos_rej_tmp;
						my $rej_rej_check = "";
						undef %id_matches;
						$no_go_back_sort_matches = "yes";
						
						foreach my $id_tmp5 (keys %read_start_pos_rej)
						{                                   
							if ($read_start_pos_rej{$id_tmp5} > $lowest_longest_match-600 && length($read) > 1000)
							{
								$count_tmp++;
							}
						}
						if ($count_tmp < 35)
						{
							foreach my $id_tmp5 (keys %read_start_pos_rej)
							{                                   
								if ($read_start_pos_rej{$id_tmp5} > $lowest_longest_match-600 && length($read) > 1000)
								{
									if (exists($store_mismatches_NP{$id_tmp5}))
									{
										print {$filehandle{$seed_id2}} $id_tmp5." ID ".$read_start_pos_rej{$id_tmp5}." POS_REJ\n";
										my $long_read_tmp = "";
										if (exists($reverse_list{$id_tmp5}))
										{
											$long_read_tmp = reverse($hash_NP_reads_tmp{$id_tmp5});
											$long_read_tmp =~ tr/ACTG/TGAC/;
										}
										else
										{
											$long_read_tmp = $hash_NP_reads_tmp{$id_tmp5};
										}
										
										my $long_read_end_pos_tmp = $long_read_end_pos_save{$id_tmp5};
										my $ext = substr $long_read_tmp, $long_read_end_pos_tmp-90, $length_extension;
										if (exists($scores2{'0'}))
										{
											$scores2{'0'} .= ",$id_tmp5"; 
										}
										else
										{
											$scores2{'0'} = $id_tmp5;
										}
										$extensions2_tmp{$id_tmp5} = $ext;
									}
									else
									{
										$id_matches{$id_tmp5} = undef;
										print {$filehandle{$seed_id2}} $id_tmp5." ID ".$read_start_pos_rej{$id_tmp5}." POS_REJ80\n";
										delete $save_alignment_data_NP{$seed_id}{$id_tmp5};
										delete $read_start_pos_rej{$id_tmp5};	
									}
									
								}
							}
						}
						else
						{
							$count_tmp = '0';
						}
						
						my %extensions_nomatch2b_tmp;
						undef %extensions_nomatch2b_tmp;
						
						foreach my $ext_id_tmp (keys %extensions_nomatch2b)
						{
							foreach my $ext_tmp (keys %{$extensions_nomatch2b{$ext_id_tmp}})
							{
								foreach my $score_no_match_tmp (keys %{$extensions_nomatch2b{$ext_id_tmp}{$ext_tmp}})
								{
									if (length($ext_tmp) > length($best_extension) && $alignment_length_save{$ext_id_tmp} > $lowest_longest_match)
									{
										$extensions_nomatch2b_tmp{$ext_id_tmp} = undef;
										print {$filehandle{$seed_id2}} $ext_id_tmp." ADD_NOMATCH\n";
										$count_tmp++;
									}
								}
							}
						}
						foreach my $ext_id_tmp (keys %extensions_nomatch2b_saved)
						{
							if (exists($extensions_nomatch2b{$ext_id_tmp}))
							{}
							else
							{
								foreach my $score_match_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}})
								{
									foreach my $score_no_match_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}})
									{
										foreach my $aln_length_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}{$score_no_match_tmp}})
										{
											foreach my $pos_prev_tmp (keys %{$extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}{$score_no_match_tmp}{$aln_length_tmp}})
											{
												if ($extensions_nomatch2b_saved{$ext_id_tmp}{$score_match_tmp}{$score_no_match_tmp}{$aln_length_tmp}{$pos_prev_tmp}+$pos_prev_tmp > $position+length($best_extension)
													&& $position-$pos_prev_tmp+$aln_length_tmp > $lowest_longest_match)
												{
													$extensions_nomatch2b_tmp{$ext_id_tmp} = undef;
													print {$filehandle{$seed_id2}} $ext_id_tmp." ADD_NOMATCH_SAVED\n";
													$count_tmp++;
												}
											}
										}
									}
								}
							}
						}
						if ($count_tmp < 50 && $count_tmp > 1)
						{
							foreach my $id_tmp55 (keys %extensions_nomatch2b_tmp)
							{	
								if (exists($extensions_nomatch2b_saved{$id_tmp55}))
								{
									$id_matches{$id_tmp55} = undef;
								}
								if (exists($extensions_nomatch2b{$id_tmp55}))
								{
									if (exists($scores2{'0'}))
									{
										$scores2{'0'} .= ",$id_tmp55"; 
									}
									else
									{
										$scores2{'0'} = $id_tmp55;
									}
									foreach my $ext_tmp (keys %{$extensions_nomatch2b{$id_tmp55}})
									{
										$extensions2_tmp{$id_tmp55} = $ext_tmp; 
									}
								}
							}
	
							foreach my $pos_tmp14 (keys %{$split_positions_DUP{$id}})
							{
								if (exists($split_positions_VIP{$id}{$pos_tmp14}))
								{}
								elsif ($pos_tmp14 > $position+length($best_extension)+150)
								{
									 delete $split_positions_DUP{$id}{$pos_tmp14};
									 delete $split_positions_DUP2{$id}{$pos_tmp14};
								}
							}
							
							$add_rejected_and_no_match_reads = $total_nuc_count_original;
							$add_rejected_reads_low_longest = $lowest_longest_match;
							$add_rejected_reads = "";
							$add_no_match_reads = "";
							print {$filehandle{$seed_id2}} $best_extension."\nHALLE8\n";
							$mismatch_retry++;
							$best_extension = "";
							$best_extension_part = "";
							undef %quality_scores_tmp;
							delete $exclude_reads_NP{$seed_id};
							delete $rejected_alignment_data_NP{$seed_id};
							$remove_reads_check = "";                                    
							
							if (keys %id_matches > 0)
							{
								goto ADD_REJ_POS_NP;
							}
							goto SELECT_LENGTH_NP2;
						}
					}
#Go back and full reset every iteration---------------------------------------------------------------------------------------------------------------
					my $overlap_max5 = '0';
					foreach my $overlap_id_tmp (keys %alignment_length_save)
					{          
						my $overlap_tmp = $alignment_length_save{$overlap_id_tmp};
						if ($overlap_tmp > $overlap_max5)
						{
							$overlap_max5 = $overlap_tmp;
						}
					}
					my $full_reset_time_tmp = $full_reset_time;
					if (exists($full_reset_time{$seed_id}))
					{
						$full_reset_time_tmp = "yes";
					}
					if (exists($full_reset_time_stop{$seed_id}))
					{
						if ($position < $full_reset_time_stop{$seed_id}+$overlap_max5+50000)
						{
							$full_reset_time_tmp = "yes";
						}
					}
					if ($full_reset_time_tmp eq "" && $position > $overlap_max5+50000 && ($unresolvable_NP eq "yes2" || ($post_pattern_match eq "yes3" && $trace_back_check eq "" && $post_pattern_match_count > 3 && $find_haps_in_seed eq "" && $PB_reads eq ""
						&& $input_reads_DB_folder_PB eq "" && $count_options > 1 && (length($best_extension) < 2000 || length($best_extension) < $length_extension*0.7) && $SNR_read_ahead eq "")))
                    {
						$full_reset_time{$seed_id} = $position+50000;
						$read = substr $read, 0, -($overlap_max5+50000);
						delete $exclude_reads_NP{$seed_id};
						delete $save_alignment_data_NP{$seed_id};
						delete $rejected_alignment_data_NP{$seed_id};
						$position = length($read);
						$position{$id} = $position;
						$seed{$id} = $read;
						foreach my $pos_split (keys %{$split_positions{$id}})
						{
							if (exists($split_positions_VIP{$id}{$pos_split}))
							{}
							elsif ($pos_split > $position+length($best_extension)+150)
							{
								delete $split_positions{$id}{$pos_split};
							}
						}
						foreach my $pos_split (keys %{$split_positions_DUP{$id}})
						{
							if (exists($split_positions_VIP{$id}{$pos_split}))
							{}
							elsif ($pos_split > $position+length($best_extension)+150)
							{
								delete $split_positions_DUP{$id}{$pos_split};
								delete $split_positions_DUP2{$id}{$pos_split};
							}
						}
						if ($hap_compare_pos{$id} > $position)
						{
							$hap_compare_pos{$id} = $position;
						}
						$best_extension = "";										
						print {$filehandle{$seed_id2}} $full_reset_time{$seed_id}." ".$position." GO_BACK_AND_FULL_RESET\n";  
						goto NP_READS;
					}
	
					if ($clipped_ext eq "yes" && $first_split_pos > 1000 && ($unresolvable_NP eq "yes2" || ($post_pattern_match eq "yes3" && $trace_back_check eq "" && $post_pattern_match_count > 2 && $find_haps_in_seed eq "" && $PB_reads eq ""
						&& $input_reads_DB_folder_PB eq "" && $count_options > 1 && (length($best_extension) < 2000 || length($best_extension) < $length_extension*0.7) && $SNR_read_ahead eq "")))
                    {           
						my $ext_new_tmp = substr $best_extension, 0, $first_split_pos-350;
						print {$filehandle{$seed_id2}} $best_extension." EXT_FIRST_SPLIT_POS\n";
						goto AFTER_NEXT_MAFFT;
					}
					if ($unresolvable_NP eq "yes2" || ($post_pattern_match eq "yes3" && $trace_back_check eq "" && $post_pattern_match_count > 3 && $find_haps_in_seed eq "" && $PB_reads eq ""
						   && $input_reads_DB_folder_PB eq "" && $count_options > 1 && (length($best_extension) < 2000 || length($best_extension) < $length_extension*0.7) && $SNR_read_ahead eq ""))
                    {					
						print {$filehandle{$seed_id2}} $best_extension." LAST_EXTENSION\n";
						$unresolvable_NP = "yes";					
#Split into contigs---------------------------------------------------------------------------------------------------------------
						if ($total_nuc_count > 8 && keys %split_patterns_final_score > 1 && $repetitive_detect2 eq "" && $assembly_length_max ne "WG" && $assembly_refine eq "")
						{						
							my $gap_check = "";
							foreach my $nuc_tmp17 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp17}};
								if ($count_ranks_tmp > 0.16*$total_nuc_count && $nuc_tmp17 eq "-")
								{
									$gap_check = "yes";
								}
							}
							foreach my $nuc_tmp17 (sort {$a <=> $b} keys %split_patterns_final_score)
							{
								my $count_ranks_tmp = keys %{$split_patterns_final_score{$nuc_tmp17}};
								my $best_extension_tmp = $best_extension;
								if ($count_ranks_tmp > 0.16*$total_nuc_count)
								{
									my $second_length_tmp = $lowest_longest_match;
									foreach my $nuc_tmp11 (keys %longest_match2)
									{
										if ($nuc_tmp17 eq $nuc_tmp11)
										{
											my $second_check = "";
											foreach my $length_tmp14 (sort {$b <=> $a} keys %{$longest_match2{$nuc_tmp11}})
											{
												if ($second_check eq "")
												{
													$second_check = "yes";
													next;
												}
												else
												{
													$second_length_tmp = $length_tmp14;
													last;
												}
											}
										}
									}
									my $new_contig_seed = substr $read, -$second_length_tmp, $second_length_tmp;
									$contig_number++;
									
									if ($clipped_ext eq "yes")
									{
										foreach my $pos_tmp13 (sort {$b <=> $a} keys %SNP_patterns_prev_match_for_split)
										{
											my $gap_check2 = "";
											foreach my $nuc_tmp19 (sort {$a <=> $b} keys %{$SNP_patterns_prev_match_for_split{$pos_tmp13}})
											{
												my $rank_count_tmp = keys %{$SNP_patterns_prev_match_for_split{$pos_tmp13}{$nuc_tmp19}};
												if ($rank_count_tmp > $total_nuc_count*0.15 && $nuc_tmp19 eq "-")
												{
													$gap_check2 = "yes";
												}
											}
											
											my %match_tmp;
											undef %match_tmp;
											my $count_tmp = '0';
											
											foreach my $rank_tmp14 (keys %{$split_patterns_final_score{$nuc_tmp17}})
											{													
												foreach my $nuc_tmp19 (keys %{$SNP_patterns_prev_match_for_split{$pos_tmp13}})
												{
													if (exists($SNP_patterns_prev_match_for_split{$pos_tmp13}{$nuc_tmp19}{$rank_tmp14}))
													{
														$match_tmp{$nuc_tmp19} += 1;
														$count_tmp++;
													}
												}
											}
	
											my $match_count_tmp = keys %match_tmp;
											my $nuc_tmp15 = "";
											foreach my $nuc_tmp11 (keys %match_tmp)
											{
												if ($match_tmp{$nuc_tmp11} > $count_tmp*0.85)
												{
													$nuc_tmp15 = $nuc_tmp11;
												}
											}
											
											if ($nuc_tmp15 ne "")
											{
												my $nuc_tmp15b = $nuc_tmp15;
												$nuc_tmp15b =~ tr/actg/ACTG/;
												if ($nuc_tmp15b eq "-" && $pos_tmp13-$position-1 > 0)
												{
													substr $best_extension_tmp, $pos_tmp13-$position-1, 1, "";
												}
												elsif ($pos_tmp13-$position-1 > 0)
												{
													substr $best_extension_tmp, $pos_tmp13-$position-1, 1, $nuc_tmp15b;
													if ($gap_check2 eq "")
													{
														my $pos_tmp5_new = length($new_contig_seed)+$pos_tmp13-$position;
														my $read_end_tmpi = substr $best_extension_tmp, $pos_tmp13-$position-$overlap, $overlap;
														print {$filehandle{$seed_id2}} $pos_tmp5_new." ".$nuc_tmp15b." NUC ".$read_end_tmpi." READ_END1\n";
														$split_positions_DUP{$id."c".$contig_number}{$pos_tmp5_new} = $read_end_tmpi;
														$split_positions_DUP2{$id."c".$contig_number}{$pos_tmp5_new} = $nuc_tmp15b;
														$split_positions_VIP{$id."c".$contig_number}{$pos_tmp5_new} = $read_end_tmpi.",".$nuc_tmp15b;
														$split_positions{$id."c".$contig_number}{$pos_tmp5_new} = $read_end_tmpi.",".$nuc_tmp15b;
													}
												}					
											}
										}
										
										my $nuc_tmp17b = $nuc_tmp17;
										$nuc_tmp17b =~ tr/actg/ACTG/;
										$new_contig_seed .= $best_extension_tmp;
										$new_contig_seed .= $nuc_tmp17b;
										if ($gap_check eq "")
										{
											my $pos_tmp5_new = length($new_contig_seed);
											my $read_end_tmpi = substr $new_contig_seed, -$overlap-1, $overlap;
											print {$filehandle{$seed_id2}} $pos_tmp5_new." ".$nuc_tmp17b." NUC ".$read_end_tmpi." READ_END2\n";
											$split_positions_DUP{$id."c".$contig_number}{$pos_tmp5_new} = $read_end_tmpi;
											$split_positions_DUP2{$id."c".$contig_number}{$pos_tmp5_new} = $nuc_tmp17b;
											$split_positions_VIP{$id."c".$contig_number}{$pos_tmp5_new} = $read_end_tmpi.",".$nuc_tmp17b;
											$split_positions{$id."c".$contig_number}{$pos_tmp5_new} = $read_end_tmpi.",".$nuc_tmp17b;
										}
									}
									$split_contigs_NP = "yes";
									print {$filehandle{$seed_id2}} $second_length_tmp." NEW_CONTIG_LENGTH\n";
									print {$filehandle{$seed_id2}} $nuc_tmp17." NEW_NUC_SPLIT0\n";
									
									foreach my $rank_tmp13 (keys %{$split_patterns_final_score{$nuc_tmp17}})
									{
										if (($add_no_match_reads ne "" && $rank_tmp13 > $add_no_match_reads) || ($add_rejected_reads ne "" && $rank_tmp13 > $add_rejected_reads) || ($add_rejected_and_no_match_reads ne "" && $rank_tmp13 > $add_rejected_and_no_match_reads))
										{}
										elsif (exists($rank_to_id{$rank_tmp13}))
										{
											my $id_tmpi = $rank_to_id{$rank_tmp13};
											print {$filehandle{$seed_id2}} $id_tmpi." NEW_CONTIG_ID\n";
											
											if (exists($reverse_list{$id_tmpi}))
											{
												$split_contigs_reads{$contig_number}{$id}{$new_contig_seed}{$nuc_tmp17}{$id_tmpi} = "yes";
											}
											else
											{
												$split_contigs_reads{$contig_number}{$id}{$new_contig_seed}{$nuc_tmp17}{$id_tmpi} = "no";
											}
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$split_positions{$id}})
									{
										if ($pos_tmp5 > $position-$second_length_tmp)
										{
											my $pos_tmp5_new = $pos_tmp5+$second_length_tmp-$position;
											$split_positions{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions{$id}{$pos_tmp5};
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$split_positions_DUP{$id}})
									{
										if ($pos_tmp5 > $position-$second_length_tmp)
										{
											my $pos_tmp5_new = $pos_tmp5+$second_length_tmp-$position;
											$split_positions_DUP{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions_DUP{$id}{$pos_tmp5};
											$split_positions_DUP2{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions_DUP2{$id}{$pos_tmp5};
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$split_positions_VIP{$id}})
									{
										if ($pos_tmp5 > $position-$second_length_tmp)
										{
											my $pos_tmp5_new = $pos_tmp5+$second_length_tmp-$position;
											$split_positions_VIP{$id."c".$contig_number}{$pos_tmp5_new} = $split_positions_VIP{$id}{$pos_tmp5};
										}
									}
									foreach my $pos_tmp5 (sort {$a <=> $b} keys %{$trace_back_split_NP{$id}})
									{
										if ($pos_tmp5 > $position-$second_length_tmp)
										{
											my $pos_tmp5_new = $pos_tmp5+$second_length_tmp-$position;
											$trace_back_split_NP{$id."c".$contig_number}{$pos_tmp5_new} = $trace_back_split_NP{$id}{$pos_tmp5};
										}
									}
								}	
							}
						}
#----------------------------------------------------------------------------------------------------------------------------------
						last INPUT_MAFFT3_NP;
                    }
					elsif ($unresolvable_NP eq "yes2" || ($post_pattern_match eq "yes3" && $trace_back_check eq "" && $post_pattern_match_count > 3 && $find_haps_in_seed eq "" && $PB_reads eq ""
						   && $input_reads_DB_folder_PB eq "" && $count_options > 1 && $SNR_read_ahead eq ""))
                    {
						substr $best_extension, -100,100, "";  
						my $last_70b = substr $best_extension, -70, 70;
						my $N_test = $last_70b =~ tr/N/N/;
						while ($N_test > 5 && length($best_extension) > 500)
						{
							substr $best_extension, -100,100, "";  
							$last_70b = substr $best_extension, -70, 70;
							$N_test = $last_70b =~ tr/N/N/;
						}
						print {$filehandle{$seed_id2}} $best_extension." EXT0_CUT\n";
						goto AFTER_NEXT_MAFFT;
					}
					
					my $best_extension_part_tmp = substr $best_extension, -500;
					my $CG = $best_extension_part_tmp =~ tr/CGN/CGN/;
					my $N_part = $best_extension_part_tmp =~ tr/N/N/;
					my $CG_rich = "";
					my $AF0 = 0.65;
					my $AF2 = 0.78;
					
					if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
					{
						$AF0 = 0.75;
					}
					if ($clipped_ext ne "yes")
					{
						$AF2 = 0.64;
					}
					if ($high_quality_ONT eq "yes")
					{
						$AF0 = 0.7;
						$AF2 = 0.79;
					}
					if ($CG > 0.52*length($best_extension_part_tmp) && $N > 10 && ($N > length($best_extension)*0.08 || $N_part > length($best_extension_part_tmp)*0.08))
					{
						$CG_rich = "yes";
						$AF2 = 0.65;
						$AF0 = 0.62;
						if ($high_quality_ONT eq "yes")
						{
							$AF0 = 0.66;
							$AF2 = 0.69;
						}
					}
					if ($post_pattern_match_average_save eq "" && $N > 10 && ($N > length($best_extension)*0.11 || $N_part > length($best_extension_part_tmp)*0.11))
					{
						$AF0 = 0.6;
						$AF2 = 0.62;
						if ($high_quality_ONT eq "yes")
						{
							$AF0 = 0.64;
							$AF2 = 0.68;
						}
					}
					if ($SNR_read_ahead ne "" || ($total_nuc_count < 12 && $total_nuc_count < $sequencing_depth_NP/1.8))
					{
						$AF0 = 0.55;
						$AF2 = 0.62;
						if ($high_quality_ONT eq "yes")
						{
							$AF0 = 0.6;
							$AF2 = 0.65;
						}
					}
					
					#print {$filehandle{$seed_id2}} $AF0." AF0 ".$AF2." AF2\n";
BASECALL2_NP:					
                    if ($found_haps_in_seed eq "" && ($clipped_ext ne "yes" || $best_extension eq "" || length($best_extension_part) < $length_extension_part*0.8 || ($SNR_read_ahead ne "" && $N < 4)
						|| $N < 5 || $N < length($best_extension)*0.1 || ($NP_reads_support ne "yes" && $NP_reads_support ne "") || ($longer_extension_for_repeat ne "" && $N < length($best_extension)*0.15)
						|| $total_nuc_count < 6 || ($CG_rich eq "yes" && $N < length($best_extension)*0.2) || (length($best_extension) < $length_extension*0.8 && $N < length($best_extension)*0.3)))
                    {
                        my $last4 = substr $best_extension, -4, 4;
						$N_resolved++;
						if ($nucs{"a"} > $total_nuc_count*$AF0 && ($nucs{"-"} > $total_nuc_count*0.35 || $nucs{"a"} > $total_nuc_count*$AF2
                         || ($nucs{"a"} > 2 && $nucs{"c"} < $total_nuc_count*0.2 && $nucs{"g"} < $total_nuc_count*0.2 && $nucs{"t"} < $total_nuc_count*0.2)))
                        {
                            $best_extension .= "A";
							$best_extension_part .= "A";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"a"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "A";
                        }
                        elsif ($nucs{"c"} > $total_nuc_count*$AF0 && ($nucs{"-"} > $total_nuc_count*0.35 || $nucs{"c"} > $total_nuc_count*$AF2 ||
                              ($nucs{"c"} > 2 && $nucs{"a"} < $total_nuc_count*0.2 && $nucs{"g"} < $total_nuc_count*0.2 && $nucs{"t"} < $total_nuc_count*0.2)))
                        {
                            $best_extension .= "C";
							$best_extension_part .= "C";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"c"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "C";
                        }
                        elsif ($nucs{"t"} > $total_nuc_count*$AF0 && ($nucs{"-"} > $total_nuc_count*0.35 || $nucs{"t"} > $total_nuc_count*$AF2  ||
                            ($nucs{"t"} > 2 && $nucs{"c"} < $total_nuc_count*0.2 && $nucs{"g"} < $total_nuc_count*0.2 && $nucs{"a"} < $total_nuc_count*0.2)))
                        {
                            $best_extension .= "T";
							$best_extension_part .= "T";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"t"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "T";
                        }
                        elsif ($nucs{"g"} > $total_nuc_count*$AF0 && ($nucs{"-"} > $total_nuc_count*0.35 || $nucs{"g"} > $total_nuc_count*$AF2 ||
                              ($nucs{"g"} > 2 && $nucs{"c"} < $total_nuc_count*0.2 && $nucs{"a"} < $total_nuc_count*0.2 && $nucs{"t"} < $total_nuc_count*0.2)))
                        {
                            $best_extension .= "G";
							$best_extension_part .= "G";
                            if ($total_nuc_count > 2)
                            {
                                $quality_scores_tmp{length($best_extension)} = ($nucs{"g"}+($nucs{"-"}/2))/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            }
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "G";
                        }
						elsif ($nucs{"-"} > $total_nuc_count*$AF2 || ($nucs{"-"} > $total_nuc_count*0.6 && $nucs{"c"} < $total_nuc_count*0.2 && $nucs{"g"} < $total_nuc_count*0.2 &&
                                $nucs{"t"} < $total_nuc_count*0.2 && $nucs{"a"} < $total_nuc_count*0.2))
                        {
							if ($nucs{"-"}/$total_nuc_count < 0.8)
							{
								$quality_scores_gap_tmp{length($best_extension)} = $nucs{"-"}/$total_nuc_count." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
							}
                            $nuc_match = "";
                        }
                        else
                        {
                            $N++;
                            $best_extension .= "N";
							$best_extension_part .= "N";
                            $quality_scores_tmp{length($best_extension)} = '0'." ".$nucs{"a"}." ".$nucs{"c"}." ".$nucs{"t"}." ".$nucs{"g"}." ".$nucs{"-"};
                            #print {$filehandle{$seed_id2}} length($best_extension)." POS_QUAL ".$quality_scores_tmp{length($best_extension)}." QUAL ".$nucs{"a"}." A ".$nucs{"c"}." C ".$nucs{"t"}." T ".$nucs{"g"}." G ".$nucs{"-"}." GAP\n";
                            $nuc_match = "N";
                        }
					}
                    else
                    {
                        print {$filehandle{$seed_id2}} $nuc_match." TERMINATE EARLY2\n";
						goto AFTER_NEXT_MAFFT;
                    }
                                    
SKIP_INPUT_BLAST3_NP:
					if ($trace_back_check ne "" && $nuc_match ne "N" && $nuc_match ne "" && ($nucs{"a"} > ($total_nuc_count-$nucs{"-"})*0.76 || $nucs{"c"} > ($total_nuc_count-$nucs{"-"})*0.76
						|| $nucs{"t"} > ($total_nuc_count-$nucs{"-"})*0.76 || $nucs{"g"} > ($total_nuc_count-$nucs{"-"})*0.76 || $check_N_correction eq "yes"))
					{
						my $count_SNR = '0';
						my $last_11_prev = $trace_back_split_NP{$id}{$trace_back_check};
						my $N_check = $last_11_prev =~ tr/N/N/;
                        foreach my $subject_rank (sort {$a <=> $b} keys %subject_list)
                        {
							my $p = '0';
							my $k = $trace_back_check-($position+length($best_extension));
                            while ($p < $k+65)
                            {
                                my $next_11 = "";
								my $p2b = '0';
								my $pb = '1';
								while ($p2b < 11 && $pb < 100)
								{
									my $nuc2 = substr $subject_list{$subject_rank}, $cp+$pb+$p, 1;
									if ($nuc2 ne "-")
									{
										$next_11 .= $nuc2;
										$p2b++;
									}
									$pb++;
								}
								
                                if ($next_11 eq $last_11_prev)
								{			
									$count_SNR++
								}
								elsif ($N_check > 0)
								{
									$last_11_prev =~ tr/N/\./;
									if ($next_11 =~ m/$last_11_prev/)
									{
										$count_SNR++
									}
								}
                                $p++;
                            }
						}
						if ($count_SNR < $total_nuc_count*0.2 || $check_N_correction eq "yes")
						{
							my $posiie = length($best_extension)+$position-1;
							my $read_end_tmpi = substr $best_extension, -$overlap-1, $overlap;
							$split_positions_DUP{$seed_id}{$posiie} = $read_end_tmpi;
							$split_positions_DUP2{$seed_id}{$posiie} = $nuc_match;
							$split_positions_VIP{$seed_id}{$posiie} = $read_end_tmpi.",".$nuc_match;
							print {$filehandle{$seed_id2}} $seed_id."\t".$trace_back_check."\t".$posiie."\t".$nuc_match."\t".$read_end_tmpi." DUP_POS_TMP00\n";
	
							my $min_pos = $position+length($best_extension);
							if ($trace_back_check ne $min_pos)
							{
								my $diff = $min_pos-$trace_back_check;
								$trace_back_check += $diff;
								print {$filehandle{$seed_id2}} $diff." MAKE_POS_COR\n";
								foreach my $pos_tmp (keys %{$trace_back_split_NP{$id}})
								{
									if ($pos_tmp >= $trace_back_check)
									{
										my $new_pos_tmp = $pos_tmp+$diff;
										$trace_back_split_NP{$id}{$new_pos_tmp} = $trace_back_split_NP{$id}{$pos_tmp};									
										delete $trace_back_split_NP{$id}{$pos_tmp};
									}
								}
							}
						}
					}
					elsif ($trace_back_check ne "" && $nuc_match ne "" && $VIP_position_check eq "")
					{
						my $found_pos = "";
						foreach my $score_tmpi (sort {$b <=> $a} keys %trace_back_split_NP_backup)
						{
TRACE_BACK_POS_NEW_NP:		foreach my $pos_tmpi (sort {$b <=> $a} keys %{$trace_back_split_NP_backup{$score_tmpi}})
							{
								if ($pos_tmpi < $trace_back_check-5)
								{
									foreach my $pos_tb_tmp (keys %{$trace_back_split_NP{$id}})
									{
										if ($pos_tmpi > $pos_tb_tmp-50 && $pos_tmpi < $pos_tb_tmp+50)
										{
											next TRACE_BACK_POS_NEW_NP;
										}
									}
									foreach my $pos_snp_tmp2 (keys %{$trace_back_split_NP{$id}})
									{
										if ($pos_snp_tmp2 > $pos_tmpi-1000 && $pos_snp_tmp2 < $pos_tmpi+1000)
										{
											if ($trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi} eq $trace_back_split_NP{$id}{$pos_snp_tmp2})
											{
												next TRACE_BACK_POS_NEW_NP;
											}
										}
									}
									$trace_back_split_NP{$id}{$pos_tmpi} = $trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi};
									print {$filehandle{$seed_id2}} $pos_tmpi." TRACE_BACK_POS_NEW\n";
									$found_pos = $pos_tmpi;
									last;
								}
							}
							last;
						}
						foreach my $score_tmpi (sort {$b <=> $a} keys %trace_back_split_NP_backup)
						{
							foreach my $pos_tmpi (sort {$b <=> $a} keys %{$trace_back_split_NP_backup{$score_tmpi}})
							{
								if ($pos_tmpi > $found_pos && $pos_tmpi < $trace_back_check)
								{
									$trace_back_split_NP{$id}{$pos_tmpi} = $trace_back_split_NP_backup{$score_tmpi}{$pos_tmpi};
									print {$filehandle{$seed_id2}} $pos_tmpi." TRACE_BACK_POS2_NEW\n";
								}
							}
						}
						if ($found_pos ne "")
						{
							$read = substr $read, 0, $found_pos-800;							
							delete $exclude_reads_NP{$seed_id};
							delete $save_alignment_data_NP{$seed_id};
							delete $rejected_alignment_data_NP{$seed_id};
							$position = length($read);
							$position{$id} = $position;
							$seed{$id} = $read;
							foreach my $pos_split (keys %{$split_positions{$id}})
							{
								if (exists($split_positions_VIP{$id}{$pos_split}))
								{}
								elsif ($pos_split > $position+length($best_extension)+150)
								{
									delete $split_positions{$id}{$pos_split};
								}
							}
							foreach my $pos_split (keys %{$split_positions_DUP{$id}})
							{
								if (exists($split_positions_VIP{$id}{$pos_split}))
								{}
								elsif ($pos_split > $position+length($best_extension)+150)
								{
									delete $split_positions_DUP{$id}{$pos_split};
									delete $split_positions_DUP2{$id}{$pos_split};
								}
							}
							$best_extension = "";
							if ($hap_compare_pos{$id} > $position)
							{
								$hap_compare_pos{$id} = $position;
							}
							
							print {$filehandle{$seed_id2}} $position." HALLE5b\n";
							goto NP_READS;
						}
					}
                    if ($hap_position eq "" && $find_haps_in_seed ne "")
                    {
                        $extensions_seed{"HAP1"} .= $nuc_match;
                        $extensions_seed{"HAP2"} .= $nuc_match;
                    }
                    $hap_position = "";

                    #if (($N > length($best_extension)*0.08 || ($N > length($best_extension)*0.045 && length($best_extension) > 1000)) && $N > 5 && $confirmed_reads_count_NP > 4 && $skip_confirmed eq "" && $only_confirmed eq "yes")
                   # {
                        #print {$filehandle{$seed_id2}} $best_extension." EXT_remove\n";
                        #$best_extension = "";
                        #$skip_confirmed = "yes";
                       # undef %quality_scores_tmp;
                        
                        #goto SKIP_CONFIRMED_NP;
                    #}
                    foreach my $subject_rank (keys %subject_list)
                    {
                        if (exists($length_ext{$subject_rank}))
                        {
                            if ($length_ext{$subject_rank} < $track_length_ext_total{$subject_rank}+$track_length_ext{$subject_rank}+100)
                            {
                                delete $subject_list{$subject_rank}
                            }
                            if ($length_ext{$subject_rank} < length($best_extension))
                            {
                                delete $subject_list{$subject_rank}
                            }
							
							if ($track_length_ext{$subject_rank} > $length_extension_part)
                            {
                                $end_this_mafft_part = "yes";
                            }
                        }
                    }
                    $nuc_prev = $nuc_match;
                    $cp++;
                }
#Go to the next mafft consensus------------------------------------------------------------------------------------------------------

				my $time_CONS3 = time;
                my $time10 = $time_CONS3 - $time_BLAST3;
                print {$filehandle{$seed_id2}} $time10." TIME_CONS\n\n";
				print {$filehandle{$seed_id2}} $time_mafft_tmp1." TIME_CONS1\n";
				  print {$filehandle{$seed_id2}} $time_mafft_tmp2." TIME_CONS2\n";
				  print {$filehandle{$seed_id2}} $time_mafft_tmp2b." TIME_CONS2b\n";
				
				if (length($best_extension) < $length_extension-$extension_part_length && length($best_extension) > 0 && $unresolvable_NP eq "" && $loop_check eq "yes")
				{
					if ($mafft_count < 3)
					{
						foreach my $rank_tmp3 (keys %track_length_ext)
						{
							$track_length_ext_total{$rank_tmp3} = $track_length_ext{$rank_tmp3};
						}
					}
					else
					{
						foreach my $rank_tmp3 (keys %track_length_ext_total)
						{
							$track_length_ext_total{$rank_tmp3} += $track_length_ext{$rank_tmp3};
						}
					}
					print {$filehandle{$seed_id2}} length($best_extension)." NEXT_MAFFT\n";   
					goto MAFFT_NP;
				}
				$halle5 = "";
AFTER_NEXT_MAFFT:			
#remove bad alignments------------------------------------------------------------------------------------------               
                if ($find_haps_in_seed eq "" && $total_nuc_count_original > 700000000000000000000000000 && $total_nuc_count_original < 16 && $total_nuc_count_original > $sequencing_depth_NP/2 && $unresolvable_NP eq "")
                {
                    print {$filehandle{$seed_id2}} length($best_extension)." EXT_LENGTH\n";                  
                    my $highest_score = '0';
                    my $count_remaining_reads = '1';
                    my %best_read_score2;
                    undef %best_read_score2;
                    
                    foreach my $read_numb_tmp (sort {$a <=> $b} keys %best_read_score)
                    {
                        my $length_align = $track_length_ext_total{$read_numb_tmp};

                        if ($length_align > 0)
                        {
                            my $score_by_length = $best_read_score{$read_numb_tmp}/$length_align;
                            print {$filehandle{$seed_id2}} $read_numb_tmp." = ".$score_by_length." ALIGNMENT_SCORES\n";
                            $best_read_score2{$score_by_length} = $read_numb_tmp;
                        }
                        $count_remaining_reads++;
                    }
                    my $gg = '0';
                    foreach my $score_tmp (sort {$b <=> $a} keys %best_read_score2)
                    {
                        $gg++;
                        if ($gg eq '2')
                        {
                            $highest_score = $score_tmp;
                        }
                    }
                    
                    my $removed_reads = '0';
                    foreach my $score_tmp (sort {$a <=> $b} keys %best_read_score2)
                    {
                        my $rank_tmp9 = $best_read_score2{$score_tmp};

                        if (($score_tmp < $highest_score*0.7 || $score_tmp eq "") && $count_remaining_reads > 2 && $count_remaining_reads > 0.5*($count_remaining_reads+$removed_reads)
							&& ($rank_tmp9 > 4 || ($score_tmp < $highest_score*0.7)) && $rank_tmp9 > 5)
                        {
                            $count_remaining_reads--;
                            $removed_reads++;
                            $ignore_reads{$rank_tmp9} = undef;
                            my $id_tmp0 = $rank_to_id{$rank_tmp9};
                            delete $extensions2_tmp{$id_tmp0};
                            delete $extensions{$extensions2{$id_tmp0}};
                            delete $extensions2{$id_tmp0};
                            delete $extensions_nomatch{$extensions2{$id_tmp0}};
                            delete $extensions_nomatch2{$id_tmp0};
                            delete $extensions_unknown{$extensions2{$id_tmp0}};
                            delete $extensions_unknown2{$id_tmp0};
                            delete $save_reads_for_next{$id_tmp0};
                            delete $add_rej_reads_extra{$id_tmp0};
                            $ext2_count = keys %extensions2_tmp;
                        }
                    }
                    if ($removed_reads > 0 && $removed_reads > 0.08*($count_remaining_reads+$removed_reads) && ($post_pattern_match ne "yes3" || $removed_reads < 3) && ($removed_reads < 0.3*($count_remaining_reads+$removed_reads) ||
                        ($ext2_count > 0 && $removed_reads < 0.5*($count_remaining_reads+$removed_reads)) || $removed_reads < 3 ||
                        ($count_remaining_reads > 4 && $count_matches_with_high_scores > $sequencing_depth_NP*5) || length($best_extension) < 500) && $count_remaining_reads > 4)
                    {		
                        #if ($confirmed_reads_count_NP > 4 && $skip_confirmed eq "" && $confirmed_reads_count_NP-$removed_reads < 4 && $sequencing_depth_NP > 12 && $only_confirmed eq "yes")
                        #{
                            #$skip_confirmed = "yes";
                            #print {$filehandle{$seed_id2}} "REMOVE_BAD_ALIGNMENTS SKIP_CONFIRMED\n";
                            #goto SKIP_CONFIRMED_NP;
                        #}
                        $mismatch_retry++;
                        undef %quality_scores_tmp; #CHECK THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        if ($removed_reads eq '1000000000')
                        {
                            print {$filehandle{$seed_id2}} "REMOVE_BAD_ALIGNMENTS0\n";
							if ($mafft_count < 3)
							{
								$best_extension = "";
							}
							else
							{
								substr $best_extension, -length($best_extension_part), length($best_extension_part), "";
							}
							$best_extension_part = "";
                            goto IGNORE_REMOVED_READS_NP;
                        }
						$best_extension = "";
                        print {$filehandle{$seed_id2}} $removed_reads." REMOVE_BAD_ALIGNMENTS\n";  
                        goto MISMATCH_RETRY_NP;
                    }
                    elsif ($first_split_pos > 400 && $post_pattern_match eq "yes3")
                    {
                    }
                    elsif (($post_pattern_match eq "yes3" || ($removed_reads > 0.3*($count_remaining_reads+$removed_reads) && $total_nuc_count > 5 && length($best_extension) < 350)) && $full_reset_NP eq "")
                    {
                        delete $exclude_reads_NP{$seed_id};
						delete $save_alignment_data_NP{$seed_id};
						delete $rejected_alignment_data_NP{$seed_id};
						$full_reset_NP = $best_extension;
						$best_extension = "";
						print {$filehandle{$seed_id2}} $full_reset_NP." FULL_RESET2\n";  
						goto NP_READS;
                    }
                    elsif ($post_pattern_match eq "yes3" || ($removed_reads > 0.3*($count_remaining_reads+$removed_reads) && $total_nuc_count > 5 && length($best_extension) < 350))
                    {
                        $best_extension = "";                      
                        print {$filehandle{$seed_id2}} $last_non_complex_region{$seed_id}." LAST_NON_COMPLEX\n";  
                        goto AFTER_EXT;
                    }
                }
			
 #-------------------------------------------------------------------------------------------------------------------------

                if ($found_haps_in_seed ne "yes" && ($clipped_ext eq "yes" || ($find_haps_in_seed eq "yes" && $best_extension ne "")))
                {
					if ($unresolvable_NP ne "" && length($full_reset_NP) > length($best_extension)+1 && $split_contigs_NP eq "")
					{
						$best_extension = $full_reset_NP;
					}
					
					my $last_15b = substr $best_extension, -15, 15;
					my $N_test = $last_15b =~ tr/N/N/;
					while ($N_test > 0 && length($best_extension) > 300)
					{
						substr $best_extension, -15,15, "";  
						$last_15b = substr $best_extension, -15, 15;
						$N_test = $last_15b =~ tr/N/N/;
					}
					
					my $last_70b = substr $best_extension, -70, 70;
					my $N_test2 = $last_70b =~ tr/N/N/;
					while ($N_test2 > 5 && length($best_extension) > 500)
					{
						substr $best_extension, -100,100, "";  
						$last_70b = substr $best_extension, -70, 70;
						$N_test2 = $last_70b =~ tr/N/N/;
					}
                    print {$filehandle{$seed_id2}} $best_extension." EXT0\n";
                }
                elsif ($found_haps_in_seed eq "yes")
                {
                    print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_FOUND_HAPS\n"; 
                    $best_extension = "";
                    delete $seed{$id};
                    $compare_haps = "yes2";
                    foreach my $id_tmp (keys %extensions_seed)
                    {
                        $seed{$id."_".$id_tmp} = $extensions_seed{$id_tmp};
						if ($find_haps_in_seed eq "yes2")
                        {
                            $seed{$id."_".$id_tmp} = $read.$extensions_seed{$id_tmp};
                        }
						$original_seed_length{$id."_".$id_tmp} = length($seed{$id."_".$id_tmp});
                        print {$filehandle{$seed_id2}} $extensions_seed{$id_tmp}." EXT_SEED\n"; 
                        
                        $hap_compare_pos{$id."_".$id_tmp} = 0;
                        delete $find_haps_in_seed{$id};
                        $position{$id."_".$id_tmp} = length($seed{$id."_".$id_tmp});

						my $fh;
						$filehandle{$id."_".$id_tmp} = $fh;
						$output_file5  = $output_path."log_extended_".$project."_".$id."_".$id_tmp.".txt";
						open($filehandle{$id."_".$id_tmp}, ">".$output_file5) or die "Can't open file $output_file5, $!\n";
						
						my $fh4;
						$filehandle4{$id."_".$id_tmp} = $fh4;
						$output_file13 = $output_path."quality_scores_".$project."_".$id."_".$id_tmp.".txt";
						open($filehandle4{$id."_".$id_tmp}, ">".$output_file13) or die "Can't open file $output_file13, $!\n";
                    }
                }
                elsif ($NP_reads_support ne "yes" && $NP_reads_support ne "" && $clipped_ext eq "")
                {        
                    $best_extension = "";
                    print {$filehandle{$seed_id2}} "BACK TO PB\n";
                    goto AFTER_EXT2;
                }
                else
                {
                    print {$filehandle{$seed_id2}} "NOCLIP\n";
                    print {$filehandle{$seed_id2}} $best_extension." EXT\n";
                    $best_extension = "";
                    delete $seed{$id};
					
					foreach my $subject_id (keys %subject_list)
					{
						my $read_tmp = $subject_list{$subject_id};
						print {$filehandle{$seed_id2}} $subject_id."+".$read_tmp."\n";
					}
                }
                
                my $cut_repeat_seq = "";
                
                if (length($best_extension) > 150 && ($clipped_ext eq "yes" || $found_haps_in_seed ne "yes") && $unresolvable_NP eq "")
                {
                    my $best_extension_original = length($best_extension);
CUT_AGAIN_NP:       my $h = '70';
                    my $last_70 = substr $best_extension, -$h, 70;
                    my $AT_rich_tmp = AT_rich_test ($last_70, '10');
                    
                    while (length($best_extension) > $h+90 && $AT_rich_tmp eq "yes")
                    {
                        $h += 70;
                        $last_70 = substr $best_extension, -$h, 70;
                        $AT_rich_tmp = AT_rich_test ($last_70, '10');
                    }
                    
                    if ($h > 70)
                    {
                        $h -= 60;
                        if (length($best_extension) > $h+150)
                        {
                            substr $best_extension, -$h, $h, "";
                            $cut_repeat_seq{$seed_id} = undef;
                            $cut_repeat_seq = "yes";
                            print {$filehandle{$seed_id2}} $best_extension." CUT_REPEAT_SEQ0\n";
                            if (length($best_extension) > 150)
                            {
                                goto CUT_AGAIN_NP;
                            }   
                        }
                        elsif ($longer_extension_for_repeat eq "" && $best_extension_original < 3900)
                        {
                            $longer_extension_for_repeat = $best_extension_original+3000;
                            $length_extension = 3900;
                            print {$filehandle{$seed_id2}} $longer_extension_for_repeat." LONGER_EXTENSIONS0\n";
                            $best_extension = "";
                            #$high_quality = "yes";
                            undef %quality_scores_tmp;
                            goto SELECT_LENGTH_NP;
                        }
                    }
                    my $h3 = '0';
                    my $h3_limit = '30';
                    my $check_rep15_full = "";
CUT_AGAIN_NP2:                   
                    my $h2 = '15';
                    my $last_15 = substr $best_extension, -$h2-$h3, 15;
                    my $last_250 = substr $best_extension, -250, 250;
                    my $check_rep15 = $last_250 =~ s/$last_15/$last_15/g;
                    my $N_check = $last_15 =~ tr/N/N/;
                    my $best_extension_tmp = $best_extension;
                    #my $check_rep15_full = $best_extension_tmp =~ s/$last_15/\+/g;
                 
                    my @check_rep15_full = split /$last_15/, $best_extension_tmp;
                    my %lengths_tmp;
                    undef %lengths_tmp;
                    
                    if (@check_rep15_full > 2)
                    {
                        foreach my $seq_tmp (@check_rep15_full)
                        {
                            if (exists($lengths_tmp{length($seq_tmp)}))
                            {
                                my $count_tmp = $lengths_tmp{length($seq_tmp)}+1;
                                $lengths_tmp{length($seq_tmp)} = $count_tmp;
                            }
                            else
                            {
                                 $lengths_tmp{length($seq_tmp)} = '1';
                            }                    
                        }
                        my $score_tmp = '0';
                        my $prev_length = "";
                        
                        foreach my $length_tmp (sort {$a <=> $a} keys %lengths_tmp)
                        {
                            if ($prev_length eq "" || $prev_length < $length_tmp-150 || $prev_length < $length_tmp*0.92)
                            {
                                $score_tmp = $lengths_tmp{$length_tmp};
                            }
                            else
                            {
                                $score_tmp += $lengths_tmp{$length_tmp};
                            }
                            
                            if ($score_tmp > 1)
                            {
                                $check_rep15_full = "yes";
                                if (length($check_rep15_full[0]) > $length_tmp)
                                {
                                    $check_rep15_full = "yes2";
                                }
                                print {$filehandle{$seed_id2}} $score_tmp." LONG_REP_TEST\n";
                            }
                        }
                    }
                    
                    while ($check_rep15 > 1 && length($best_extension) > $h2+$h3+50)
                    {
                        $h2 +=230;
                        $last_15 = substr $best_extension, -$h2-$h3, 15;
                        $last_250 = substr $best_extension, -250-$h2+15, 250;
                        $check_rep15 = $last_250 =~ s/$last_15/$last_15/g;
                    }
                    
                    if (($h2 > 15 || $check_rep15_full eq "yes") && $y > 1)
                    {
                        $h2 -= 15;
                        
                        if (length($best_extension) > $h2+$h3+250 && $h2 > 15)
                        {
                            substr $best_extension, -$h2-$h3-100, $h2+$h3+100, "";
                            $cut_repeat_seq{$seed_id} = undef;
                            $cut_repeat_seq = "yes";
                            print {$filehandle{$seed_id2}} $best_extension." CUT_REPEAT_SEQ1\n";
                            if (length($best_extension) > 150)
                            {
                                goto CUT_AGAIN_NP;
                            }                  
                        }
						elsif ($longer_extension_for_repeat <= $length_extension && $longer_extension_for_repeat < length($best_extension)+1000)
                        {
                            if ($longer_extension_for_repeat eq "")
							{
								$longer_extension_for_repeat = $length_extension+3200
							}
							else
							{
								$longer_extension_for_repeat += 3000;
							}
                            print {$filehandle{$seed_id2}} $longer_extension_for_repeat." LONGER_EXTENSIONS1a\n";
                            $best_extension = "";
                            #$high_quality = "yes";
                            undef %quality_scores_tmp;
                            goto SELECT_LENGTH_NP;
                        }
                        elsif ($check_rep15_full eq "yes2")
                        {
                            my $tmpie = length($check_rep15_full[0])-250;
                            if ($tmpie < 100)
                            {
                                $tmpie = '100';
                            }
                            substr $best_extension, $tmpie, length($best_extension)-$tmpie, "";
                            $cut_repeat_seq{$seed_id} = undef;
                            $cut_repeat_seq = "yes";
                            print {$filehandle{$seed_id2}} $best_extension." CUT_REPEAT_SEQ2\n";                 
                        }
                        elsif ($longer_extension_for_repeat eq "" && $best_extension_original < 3900)
                        {
                            $longer_extension_for_repeat = $best_extension_original+3000;
                            print {$filehandle{$seed_id2}} $length_extension." LONGER_EXTENSIONS1\n";
                            $best_extension = "";
                            #$high_quality = "yes";
                            undef %quality_scores_tmp;
                            goto SELECT_LENGTH_NP;
                        }
                    }
                    elsif ($N_check > 0)
                    {
                        $h3 += 5;
                        $h3_limit += 5;
                        goto CUT_AGAIN_NP2;
                    }
                    elsif ($h3 < $h3_limit)
                    {
                        $h3 += 5;
                        goto CUT_AGAIN_NP2;
                    }
                }
                if ($first_split_pos > 500 && $post_pattern_match eq "yes3" && $unresolvable_NP eq "")
                {            
                    my $ext_new_tmp = substr $best_extension, 0, $first_split_pos-100;
                    my $h = '70';
                    my $last_70 = substr $ext_new_tmp, -$h, 70;
                    my $AT_rich_tmp = AT_rich_test ($last_70, '10');
                    
                    if ($AT_rich_tmp eq "yes")
                    {
                        $best_extension = $ext_new_tmp;
                        print {$filehandle{$seed_id2}} $best_extension." EXT0a\n";
                    }
                }
END_NP:                
                
                my $time_CONSENSUS = time;
                my $time11 = $time_CONSENSUS - $time_BLAST3b;
                print {$filehandle{$seed_id2}} $time11." TIME_CONSENSUS\n";
                
                if ($cut_repeat_seq eq "")
                {
                    delete $cut_repeat_seq{$seed_id};
                }
                
                if ($clipped_ext eq "yes" && $best_extension ne "")
                {
                    foreach my $pos_tmp (sort {$a <=> $b} keys %quality_scores_tmp)
                    {
                        if ($pos_tmp <= length($best_extension))
                        {
                            #my $nuc_tmp = substr $best_extension, $pos_tmp-1, 1;
                            $quality_scores{$id}{$position+$pos_tmp} = $quality_scores_tmp{$pos_tmp};
                            #print {$filehandle{$seed_id2}} $position+$pos_tmp." POS_QUAL ".$quality_scores{$id}{$position+$pos_tmp}." QUAL\n";
                        }   
                    }
                    foreach my $pos_tmp (sort {$a <=> $b} keys %quality_scores_gap_tmp)
                    {
                        if ($pos_tmp <= length($best_extension))
                        {
                            $quality_scores_gap{$id}{$position+$pos_tmp} = $quality_scores_gap_tmp{$pos_tmp};
                            #print {$filehandle{$seed_id2}} $pos_tmp." POS_QUAL\n";
                            #print {$filehandle{$seed_id2}} $quality_scores{$id}{$position+$pos_tmp}." QUAL\n";
                        }   
                    }
                }
                close INPUT_BLAST3;
				
#Store alignment data for the next iteration---------------------------------------------------------------------------------------------------

                if ($find_haps_in_seed eq "" && $unresolvable_NP eq "")
                {
                    foreach my $seed_id_tmp5 (keys %save_alignment_data_NP)
                    {
                        if ($seed_id_tmp5 eq $seed_id)
                        {
                            foreach my $id_tmp4 (keys %{$save_alignment_data_NP{$seed_id_tmp5}})
                            {
                                my @alignment_data = split /_/, $save_alignment_data_NP{$seed_id_tmp5}{$id_tmp4};
                                if ($alignment_data[0] eq "yes" || (($alignment_data[3]+$alignment_data[12]) < $position))
                                {
                                    delete $save_alignment_data_NP{$seed_id_tmp5}{$id_tmp4};
                                }
								elsif ($alignment_data[0] eq "no" && ($alignment_data[15] eq "yes" || $alignment_data[13] ne ""))
								{
									if (($alignment_data[3]+$alignment_data[4]+3000 < $position) || ($alignment_data[3]+$alignment_data[12] < $position) || $repetitive_detect2 ne "")
									{
										delete $save_alignment_data_NP{$seed_id_tmp5}{$id_tmp4};
									}
								}
                            }
                        }
                    }
					delete $rejected_alignment_data_NP{$id};
                    foreach my $id_tmp5 (keys %long_read_end_pos_save)
                    {
                        my $assembled = "no";
                        my $reverse_tmp = "no";
                        my $alignment_length_tmp = '0';
                        my $score_matches_tmp = "_____";
						my $no_match = "";
						if (exists($extensions_nomatch2{$id_tmp5}))
						{
							$no_match = "yes";
						}
						if (exists($extensions_nomatch2b_saved{$id_tmp5}))
						{
							$no_match = "yes";
						}
                        if (exists($save_reads_for_next{$id_tmp5}))
                        {
                            $assembled = "yes";
                        }
                        if (exists($reverse_list{$id_tmp5}))
                        {
                            $reverse_tmp = "yes";
                        }
                        if (exists($double_matches{$id_tmp5}))
                        {
                            delete $save_alignment_data_NP{$seed_id}{$id_tmp5};
							delete $rejected_alignment_data_NP{$seed_id}{$id_tmp5};
							delete $rejected_reads_save{$id_tmp5};
							next;
                        }
                        if (exists($alignment_length_save{$id_tmp5}))
                        {
                            $alignment_length_tmp += $alignment_length_save{$id_tmp5};
                        }
                        if (exists($score_matches_save{$id_tmp5}))
                        {
                            $score_matches_tmp = $score_matches_save{$id_tmp5};
							#$score_matches_save{$id_tmp3} = $score_match."_".$score_no_match."_".$score_match_DUP."_".$score_no_match_DUP."_".$score_match_VIP."_".$score_no_match_VIP;   
                        }
                        $save_alignment_data_NP{$seed_id}{$id_tmp5} = $assembled."_".$reverse_tmp."_".$long_read_end_pos_save{$id_tmp5}."_".$position."_".$alignment_length_tmp
                        ."_".$score_matches_tmp."_".$accuracy{$id_tmp5}."_".$length_ext_all{$id_tmp5}."_".$read_start_pos_rej{$id_tmp5}."_".$hash_NP_reads_tmp{$id_tmp5}."_".$no_match;
    
                        #print {$filehandle{$seed_id2}} $id_tmp5." ".$save_alignment_data_NP{$seed_id}{$id_tmp5}." SAVVEEEE\n";
                    }
					foreach my $id_tmp5 (keys %rejected_reads_save)
					{
						$rejected_alignment_data_NP{$seed_id}{$id_tmp5} = undef;
					}
                }
#Post error correction (polish) -------------------------------------------------------------------------------------------------------------------------------------------------------------------------				
				my $read_count_N_check = keys %extensions2_tmp;
				
				if ($read_count_N_check > 3 || ($read_count_N_check > 2 && $high_quality_ONT ne "") && $NP_reads_support eq "" && $y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
				{
					my %N_mismatches_tmp;
					undef %N_mismatches_tmp;
					foreach my $id_tmp15 (keys %extensions2_tmp)
					{
						foreach my $pos_snp_tmp (sort {$a <=> $b} keys %{$store_mismatches_N_NP{$id_tmp15}})
						{
							my @store_mismatches_N_NP = split /,/, $store_mismatches_N_NP{$id_tmp15}{$pos_snp_tmp};
							$N_mismatches_tmp{$pos_snp_tmp}{$store_mismatches_N_NP[1]} += 1;
						} 
					}
					my $pos_assem_tmp = 1;
					
POST_ERROR_CORR:    while ($pos_assem_tmp < $position)
					{
						my $count_cov = '0';
						my $mismatch_count_tmp = '0';
						my $match_count_tmp = '0';
						my $N_count_tmp = '0';
						my %id_list_tmp;
						undef %id_list_tmp;
						my $corrected_check = "";
						
						foreach my $id_tmp15 (keys %extensions2_tmp)
						{
							my $overlap_pos_tmp = $position - $alignment_length_save{$id_tmp15};
							if ($pos_assem_tmp > $overlap_pos_tmp)
							{
								$count_cov++;
								if (exists($store_mismatches_all_NP{$id_tmp15}{$pos_assem_tmp}))
								{
									$mismatch_count_tmp++;
								}
								elsif (exists($store_mismatches_N_NP{$id_tmp15}{$pos_assem_tmp}))
								{
									$N_count_tmp++;
								}
								else
								{
									$match_count_tmp++;
								}
								$id_list_tmp{$id_tmp15} = undef;
							}
						}
						my $total_count_tmp = $mismatch_count_tmp+$N_count_tmp+$match_count_tmp;
						my $A1 = 3;
						my $A2 = 4;
						my $A3 = 6;
						my $A4 = 9;
						if ($high_quality_ONT ne "")
						{
							$A1 = 2;
							$A2 = 2;
							$A3 = 4;
							$A4 = 6;
						}
						if ($total_count_tmp > $A1 && $total_count_tmp > $read_count_N_check*0.3)
						{
							if ((($mismatch_count_tmp > 3 && $mismatch_count_tmp > 0.81*$total_count_tmp) || ($mismatch_count_tmp > 5 && $mismatch_count_tmp > 0.75*$total_count_tmp))
								&& $y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
							{
								my %all_mismatches_tmp;
								undef %all_mismatches_tmp;
								foreach my $id_tmp15 (keys %id_list_tmp)
								{
									if (exists($store_mismatches_all_NP{$id_tmp15}{$pos_assem_tmp}))
									{
										my @store_mismatches_all_NP = split /,/, $store_mismatches_all_NP{$id_tmp15}{$pos_assem_tmp};
										$all_mismatches_tmp{$store_mismatches_all_NP[1]} += 1;
										#print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$store_mismatches_all_NP{$id_tmp15}{$pos_assem_tmp}." ALL_CORRECTED_TEST0\n";
									}
								}
								my $gap_check_count = "";
								foreach my $nuc_tmp15 (keys %all_mismatches_tmp)
								{
									if ($nuc_tmp15 eq "-" && $all_mismatches_tmp{$nuc_tmp15} > 0.25*$total_count_tmp)
									{
										$gap_check_count = "yes";
									}
								}
								foreach my $nuc_tmp15 (keys %all_mismatches_tmp)
								{
									print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." ".$all_mismatches_tmp{$nuc_tmp15}." ALL_CORRECTED_TEST0\n";
									if ($nuc_tmp15 ne "-" && (($all_mismatches_tmp{$nuc_tmp15} > 4 && $all_mismatches_tmp{$nuc_tmp15} > 0.85*$total_count_tmp) ||
										($all_mismatches_tmp{$nuc_tmp15} > 5 && $all_mismatches_tmp{$nuc_tmp15} > 0.74*$total_count_tmp && $all_mismatches_tmp{$nuc_tmp15} > $read_count_N_check*0.55)))
									{#ADDED $nuc_tmp15 ne "-" && 
										print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." ALL_CORRECTED\n";
										$corrected_check = "yes";
										print {$filehandle{$seed_id2}} $all_mismatches_tmp{$nuc_tmp15}/$total_count_tmp." Nucie_Per\n";

										my $posie_tmp = $pos_assem_tmp-1;
										if ($nuc_tmp15 eq "-")
										{
											$nuc_tmp15 = "";
											my $posie_tmp2 = $pos_assem_tmp;
											while ($posie_tmp2 < length($read) && $y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
											{
												if (exists($quality_scores{$seed_id}{$posie_tmp2+1}))
												{
													$quality_scores{$seed_id}{$posie_tmp2} = $quality_scores{$seed_id}{$posie_tmp2+1};
												}
												if (exists($quality_scores_gap{$seed_id}{$posie_tmp2+1}))
												{
													$quality_scores_gap{$seed_id}{$posie_tmp2} = $quality_scores_gap{$seed_id}{$posie_tmp2+1};
												}
												if (exists($split_positions{$seed_id}{$posie_tmp2}))
												{
													$split_positions{$seed_id}{$posie_tmp2-1} = $split_positions{$seed_id}{$posie_tmp2};
													delete $split_positions{$seed_id}{$posie_tmp2};
												}
												if (exists($split_positions_DUP{$seed_id}{$posie_tmp2}))
												{
													$split_positions_DUP{$seed_id}{$posie_tmp2-1} = $split_positions_DUP{$seed_id}{$posie_tmp2};
													$split_positions_DUP2{$seed_id}{$posie_tmp2-1} = $split_positions_DUP2{$seed_id}{$posie_tmp2};
													delete $split_positions_DUP{$seed_id}{$posie_tmp2};
													delete $split_positions_DUP2{$seed_id}{$posie_tmp2};
												}
												if (exists($split_positions_VIP{$seed_id}{$posie_tmp2}))
												{
													$split_positions_VIP{$seed_id}{$posie_tmp2-1} = $split_positions_VIP{$seed_id}{$posie_tmp2};
													delete $split_positions_VIP{$seed_id}{$posie_tmp2};
												}
												$posie_tmp2++;
											}
											$quality_scores_gap{$seed_id}{$posie_tmp} = $all_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}/$total_count_tmp;
											if ($y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
											{
												$position--;
												$position{$id} = $position;
											}
										}
										else
										{
											$quality_scores{$seed_id}{$pos_assem_tmp} = ($all_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}/$total_count_tmp)-0.05;
										}
										if ($y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
										{
											substr $read, $posie_tmp, 1, $nuc_tmp15;
										}
									}
								}
								print {$filehandle{$seed_id2}} $total_count_tmp." ".$pos_assem_tmp." MISMATCH_CHECK\n";
							}
							elsif ($N_count_tmp > $A1)
							{
								my $q_score_line = "";
								my $line_part_tmp = "A";
								my $total_nuc_count_tmp = '0';
								my $highest_nuc_count_tmp = '0';
								my $highest_nuc_tmp = '0';
NEW_Q_LINE:											
								my $check_tmp = "";
								foreach my $nuc_tmp15 (keys %{$N_mismatches_tmp{$pos_assem_tmp}})
								{	
									if ($nuc_tmp15 eq $line_part_tmp)
									{
										$q_score_line .= " ".$N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15};
										$check_tmp = "yes";
										$total_nuc_count_tmp += $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15};
										if ($N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > $highest_nuc_count_tmp)
										{
											$highest_nuc_count_tmp = $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15};
											$highest_nuc_tmp = $nuc_tmp15;
										}
									}
								}
								
								if ($check_tmp eq "")
								{
									$q_score_line .= " 0"
								}
								if ($line_part_tmp eq "A")
								{
									$line_part_tmp = "C";
									goto NEW_Q_LINE;
								}
								if ($line_part_tmp eq "C")
								{
									$line_part_tmp = "T";
									goto NEW_Q_LINE;
								}
								if ($line_part_tmp eq "T")
								{
									$line_part_tmp = "G";
									goto NEW_Q_LINE;
								}
								if ($line_part_tmp eq "G")
								{
									$line_part_tmp = "-";
									goto NEW_Q_LINE;
								}
								if ($total_nuc_count_tmp > 0)
								{
									my $first_part = "";
									if ($highest_nuc_tmp eq "-")
									{
										$first_part = $highest_nuc_count_tmp/$total_nuc_count_tmp
									}
									else
									{
										$first_part = ($highest_nuc_count_tmp+(($N_mismatches_tmp{$pos_assem_tmp}{"-"})/2))/$total_nuc_count_tmp
									}
									$first_part .= $q_score_line;
									$quality_scores{$seed_id}{$pos_assem_tmp} = $first_part;
								}
								else
								{
									foreach my $nuc_tmp15 (keys %{$N_mismatches_tmp{$pos_assem_tmp}})
									{
										print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." ".$N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}." N_CORRECTED0\n";
									}
								}
							
								my $gap_check_count = "";
								foreach my $nuc_tmp15 (keys %{$N_mismatches_tmp{$pos_assem_tmp}})
								{
									if ($nuc_tmp15 eq "-" && $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > 0.25*$total_count_tmp)
									{
										$gap_check_count = "yes";
									}
								}
								if ($y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
								{
									foreach my $nuc_tmp15 (keys %{$N_mismatches_tmp{$pos_assem_tmp}})
									{
										if ($nuc_tmp15 ne "-" && (($N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > $A1 && $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > 0.81*$total_count_tmp) ||
											($N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > 5 && $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15} > 0.74*$total_count_tmp && $N_mismatches_tmp{$nuc_tmp15} > $read_count_N_check*0.3)))
										{#ADDED $nuc_tmp15 ne "-" && 
											print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." N_CORRECTED\n";
											my $nuci_test = substr $read, $pos_assem_tmp-1, 1;
											$corrected_check = "yes";
											print {$filehandle{$seed_id2}} $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}/$total_count_tmp." Nucie_Per\n";
	
											if ($nuci_test eq "N")
											{
												my $posie_tmp = $pos_assem_tmp-1;
												if ($nuc_tmp15 eq "-")
												{
													$nuc_tmp15 = "";
													my $posie_tmp2 = $pos_assem_tmp;
													while ($posie_tmp2 < length($read) && $y eq "1" && $assembly_length_max ne "WG" && $assembly_refine eq "")
													{
														if (exists($quality_scores{$seed_id}{$posie_tmp2+1}))
														{
															$quality_scores{$seed_id}{$posie_tmp2} = $quality_scores{$seed_id}{$posie_tmp2+1};
															delete $split_positions{$seed_id}{$posie_tmp2+1};
														}
														if (exists($quality_scores_gap{$seed_id}{$posie_tmp2+1}))
														{
															$quality_scores_gap{$seed_id}{$posie_tmp2} = $quality_scores_gap{$seed_id}{$posie_tmp2+1};
															delete $quality_scores_gap{$seed_id}{$posie_tmp2+1}
														}
														if (exists($split_positions{$seed_id}{$posie_tmp2+1}))
														{
															$split_positions{$seed_id}{$posie_tmp2} = $split_positions{$seed_id}{$posie_tmp2+1};
															delete $split_positions{$seed_id}{$posie_tmp2+1};
														}
														if (exists($split_positions_DUP{$seed_id}{$posie_tmp2+1}))
														{
															$split_positions_DUP{$seed_id}{$posie_tmp2} = $split_positions_DUP{$seed_id}{$posie_tmp2+1};
															$split_positions_DUP2{$seed_id}{$posie_tmp2} = $split_positions_DUP2{$seed_id}{$posie_tmp2+1};
															delete $split_positions_DUP{$seed_id}{$posie_tmp2+1};
															delete $split_positions_DUP2{$seed_id}{$posie_tmp2+1};
														}
														if (exists($split_positions_VIP{$seed_id}{$posie_tmp2+1}))
														{
															$split_positions_VIP{$seed_id}{$posie_tmp2} = $split_positions_VIP{$seed_id}{$posie_tmp2+1};
															delete $split_positions_VIP{$seed_id}{$posie_tmp2+1};
														}
														$posie_tmp2++;
													}
													$quality_scores_gap{$seed_id}{$posie_tmp} = $N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}/$total_count_tmp;
													$position--;
													$position{$id} = $position;
												}
												else
												{
													$quality_scores{$seed_id}{$pos_assem_tmp} = ($N_mismatches_tmp{$pos_assem_tmp}{$nuc_tmp15}/$total_count_tmp)-0.05;
												}
												substr $read, $posie_tmp, 1, $nuc_tmp15;
												
												my $posie_tmp1 = $posie_tmp-1-15;
												while ($posie_tmp1 < $posie_tmp-1+5)
												{
													if (exists($split_positions{$seed_id}{$posie_tmp1}))
													{
														my $read_end_tmp = substr $read, $posie_tmp1-$overlap, $overlap;
														my @split_tmp = split /,/, $split_positions{$seed_id}{$posie_tmp1};
														my $nuc_match_tmp = $split_tmp[1];
														$split_positions{$seed_id}{$posie_tmp1} = $read_end_tmp.",".$nuc_match_tmp;
														print {$filehandle{$seed_id2}} $split_tmp[0]." READ_END_OLD\n";
														print {$filehandle{$seed_id2}} length($read)." LENGTH\n";
														print {$filehandle{$seed_id2}} $posie_tmp1." ".$read_end_tmp." ".$nuc_match_tmp." SPLIT_CHANGE\n";
													}
													if (exists($split_positions_DUP{$seed_id}{$posie_tmp1}))
													{
														my $read_end_tmp = substr $read, $posie_tmp1-$overlap, $overlap;
														$split_positions_DUP{$seed_id}{$posie_tmp1} = $read_end_tmp;
														print {$filehandle{$seed_id2}} $posie_tmp1." ".$read_end_tmp." SPLIT_DUP_CHANGE\n";
													}
													if (exists($split_positions_VIP{$seed_id}{$posie_tmp1}))
													{
														my $read_end_tmp = substr $read, $posie_tmp1-$overlap, $overlap;
														my @split_tmp = split /,/, $split_positions_VIP{$seed_id}{$posie_tmp1};
														my $nuc_match_tmp = $split_tmp[1];
														$split_positions_VIP{$seed_id}{$posie_tmp1} = $read_end_tmp.",".$nuc_match_tmp;
														print {$filehandle{$seed_id2}} $posie_tmp1." ".$read_end_tmp." ".$nuc_match_tmp." SPLIT_VIP_CHANGE\n";
													}
													$posie_tmp1++;
												}
											}
											else
											{
												print {$filehandle{$seed_id2}} $pos_assem_tmp." ".$nuc_tmp15." N_CORRECTED_ERROR\n";
												print {$filehandle{$seed_id2}} $nuci_test." Nucie_test\n";
											}
										}	
									}
								}
							}
							elsif (($match_count_tmp > $A2 && $match_count_tmp > 0.9*$total_count_tmp) || ($match_count_tmp > $A3 && $match_count_tmp > 0.75*$total_count_tmp) || ($match_count_tmp > $A4 && $match_count_tmp > 0.5*$total_count_tmp))
							{
								if (exists($quality_scores{$seed_id}{$pos_assem_tmp}))
								{
									my $new_score = $match_count_tmp/$total_count_tmp;
									my @q_score_tmp = split / /, $quality_scores{$seed_id}{$pos_assem_tmp};  
									if ($new_score > $q_score_tmp[0] && $q_score_tmp[0] < 0.8)
									{
										#print {$filehandle{$seed_id2}} $quality_scores{$seed_id}{$pos_assem_tmp}." ".$new_score." NEW_SCORE\n";
										$quality_scores{$seed_id}{$pos_assem_tmp} = $new_score;
									}
								}
							}
						}
						else
						{
							last POST_ERROR_CORR;
						}
						$pos_assem_tmp++;
					}
				}	
            }
#---------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------

AFTER_EXT:
            my $time_END = time;
            my $time_ITERATION = $time_END-$time_START0;
            print {$filehandle{$seed_id2}} $time_ITERATION." TIME_ITERATION\n";
            if ($time_ITERATION > 30)
            {
                print {$filehandle{$seed_id2}}"TIME_ALERT\n";
            }
			
#Close circle--------------------------------------------------------------------------------------------------------------------------------
            my $circle = "";
			my $circle_r = ""; 
			if (length($read) > $assembly_length_max && $circular eq "yes")
			{
				my $start_seq = substr $read, 0, 15000;
				my $start_seq1 = substr $read, 30, 42;
				my $start_seq2 = substr $read, 100, 42;
				my $start_seq3 = substr $read, 150, 42;
				my $end_seq = substr $start_seq, -15000;
				my $end_seq1 = substr $start_seq, -72, 42;
				my $end_seq2 = substr $start_seq, -142, 42;
				my $end_seq3 = substr $start_seq, -192, 42;
				my $end_seq1_merge = "";
				my $end_seq2_merge = "";
				my $end_seq3_merge = "";
				$start_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$start_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$start_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$start_seq3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$end_seq =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$end_seq1 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$end_seq2 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;
				$end_seq3 =~ tr/N|K|R|Y|S|W|M|B|D|H|V/\./;

				if ($end_seq =~ m/.*.$start_seq1(.*)$/)
				{
					my $r = length($1);
					my $r2 = '0';
					my $seq_test = substr $end_seq, -$r-42-30;
					$circle = "maybe";
					$circle_r = $r+42+30;
					if ($start_seq =~ m/(.*.)$seq_test.*$/)
					{
						$circle = "yes";
						$r2 = length($1);
					}
					
					if ($circle eq "yes")
					{
						my $read_new_temp = $read;
						$read = substr $read_new_temp, length($seq_test)+$r2;             
					}	
				}
				elsif ($end_seq =~ m/.*.$start_seq2(.*)$/)
				{
					my $r = length($1);
					my $r2 = '0';
					my $seq_test = substr $end_seq, -$r-42-100;
					$circle = "maybe";
					$circle_r = $r+42+100;
					if ($start_seq =~ m/(.*.)$seq_test.*$/)
					{
						$circle = "yes";
						$r2 = length($1);
					}
					
					if ($circle eq "yes")
					{
						my $read_new_temp = $read;
						$read = substr $read_new_temp, length($seq_test)+$r2;             
					}	
				}
				elsif ($end_seq =~ m/.*.$start_seq3(.*)$/)
				{
					my $r = length($1);
					my $r2 = '0';
					my $seq_test = substr $end_seq, -$r-42-150;
					$circle = "maybe";
					$circle_r = $r+42+150;
					if ($start_seq =~ m/(.*.)$seq_test.*$/)
					{
						$circle = "yes";
						$r2 = length($1);
					}
					
					if ($circle eq "yes")
					{
						my $read_new_temp = $read;
						$read = substr $read_new_temp, length($seq_test)+$r2;             
					}	
				}
				elsif ($start_seq =~ m/(.*.)$end_seq1.*$/)
				{
					my $r = length($1);
					my $r2 = '0';
					my $seq_test = substr $start_seq, 0, $r+42+30;
					$circle = "maybe2";
					$circle_r = $r+42+30;
					if ($end_seq =~ m/.*.$seq_test(.*)$/)
					{
						$circle = "yes";
						$r2 = length($1);
					}
					if ($circle eq "yes")
					{
						my $read_new_temp = $read;
						$read = substr $read_new_temp, 0, -length($seq_test)-$r2;             
					}	
				}
				elsif ($start_seq =~ m/(.*.)$end_seq2.*$/)
				{
					my $r = length($1);
					my $r2 = '0';
					my $seq_test = substr $start_seq, 0, $r+42+100;
					$circle = "maybe2";
					$circle_r = $r+42+100;
					if ($end_seq =~ m/.*.$seq_test(.*)$/)
					{
						$circle = "yes";
						$r2 = length($1);
					}
					if ($circle eq "yes")
					{
						my $read_new_temp = $read;
						$read = substr $read_new_temp, 0, -length($seq_test)-$r2;             
					}	
				}
				elsif ($start_seq =~ m/(.*.)$end_seq3.*$/)
				{
					my $r = length($1);
					my $r2 = '0';
					my $seq_test = substr $start_seq, 0, $r+42+150;
					$circle = "maybe2";
					$circle_r = $r+42+150;
					if ($end_seq =~ m/.*.$seq_test(.*)$/)
					{
						$circle = "yes";
						$r2 = length($1);
					}		
					if ($circle eq "yes")
					{
						my $read_new_temp = $read;
						$read = substr $read_new_temp, 0, -length($seq_test)-$r2;             
					}	
				}
				if ($circle eq "maybe" || $circle eq "maybe2")
				{
					my $seq_test = substr $end_seq, -$circle_r;
					
					my $ref_file = $TMP_directory."circle_ref_tmp_".$project.".fasta";
        
                    open(OUTPUT_CIRCLE_REF, ">" .$ref_file) or die "\nCan't open file $ref_file, $!\n";
                    print OUTPUT_CIRCLE_REF ">ref\n";
                    print OUTPUT_CIRCLE_REF $start_seq;        
                    close OUTPUT_CIRCLE_REF;
                    
                    my $seq_test_file = $TMP_directory."circle_query_tmp_".$project.".fasta";
        
                    open(OUTPUT_CIRCLE_QUERY, ">" .$seq_test_file) or die "\nCan't open file $seq_test_file, $!\n";
                    print OUTPUT_CIRCLE_QUERY ">END_SEQ\n";
                    print OUTPUT_CIRCLE_QUERY $seq_test;        
                    close OUTPUT_CIRCLE_QUERY;
					
					my $N_count = $seq_test =~ tr/N/N/;
					my $N_adjust = ($N_count/length($seq_test))*100;
					my $N_count2 = $start_seq =~ tr/N/N/;
					my $N_adjust2 = ($N_count2/length($start_seq))*100;
					my $accuracy_tmp2 = 99.9-$N_adjust-$N_adjust2;       
                
                    chomp($seq_test_file);
                    chomp($ref_file);
                    my $command = "blastn -query ".$seq_test_file." -subject ".$ref_file." -out ".$TMP_directory."blast_circle_tmp_".$id."_".$y.".txt -outfmt 7 -strand plus -perc_identity ".$accuracy_tmp2." -qcov_hsp_perc 99";
                    system($command);
					
					sleep(2);
					my $input_BLAST_tmp = $TMP_directory."blast_circle_tmp_".$id."_".$y.".txt";
					
					if (-s $input_BLAST_tmp)
					{
						open(BLAST_CIRCLE, $input_BLAST_tmp) or die "\nCan't open file $input_BLAST_tmp, $!\n";
						my $count_lines_tmp = '1';
						
						while (my $line_tmp = <BLAST_CIRCLE>)
                        {
                            chomp($line_tmp);
							if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
                            {
                                last;
                            }
                            elsif ($count_lines_tmp > 5)
                            {
								my $read_new_temp = $read;
								$read = substr $read_new_temp, $circle_r;
								$circle = "yes";
							}
						}
						close BLAST_CIRCLE;
					}
				}
			}
			if ($circle eq "yes")
			{
				print OUTPUT4 "\n".$id." assembly was circularized.\n\n";
				print "\n".$id." assembly was circularized.\n\n";
				$first_back_assembly = "yes";
			}
								
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

            if (($best_extension eq "" || $unresolvable_NP eq "yes" || $unresolvable_PB eq "yes"
				|| (length($read) > $assembly_length_max-$assembly_length_prev{$id} && $assembly_length_max ne "WG" && $assembly_length_max ne "" && $assembly_refine eq ""
				&& ($circular ne "yes" || length($read) > $assembly_length_max+35000)) || $circle eq "yes")
				&& $skip_hap ne $id && $found_haps_in_seed eq "" && $find_haps_in_seed ne "yes")
            { 
				print {$filehandle{$seed_id2}} $best_extension." BEST_EXT_END\n";
				print {$filehandle{$seed_id2}} $assembly_length_prev{$id}." ASS_LENGTH\n";
				if ($split_contigs_PB eq "" || $split_contigs_NP eq "")
				{
					$read .= $best_extension;                                                 
					$position = length($read);
					$position{$id} = $position;
					$best_extension = "";
					$skip_hap = "";
					$full_reset_NP = "";
					$full_reset_PB = "";
				}
				
				my $output_file6  = $output_path."contigs_tmp_".$id."_".$project.".fasta";
				open($filehandle3{$id}, ">".$output_file6) or die "Can't open file $output_file6, $!\n";
				print {$filehandle3{$id}} ">".$id."\n";
				my $m = '0';
				while (length($read) > $m)
				{
					my $value_ref2b = substr $read, $m, 150;
					$m += 150;
					print {$filehandle3{$id}} $value_ref2b."\n";
				}
            	
				delete $seed{$id};
				foreach my $id_tmp (sort {$a <=> $b} keys %quality_scores)
				{
					if ($id eq $id_tmp)
					{
						foreach my $pos_qual (sort {$a <=> $b} keys %{$quality_scores{$id_tmp}})
						{
							print {$filehandle4{$seed_id2}} $pos_qual." ".$quality_scores{$id_tmp}{$pos_qual}."\n";
						}
					}
				}
				my $pos_in_ass = '1';
				my $read_polished = "";
				
				my $homopolymer_AF = 0.6;
				my $gap_AF = 1.3;
				if ($PB_reads ne "" || $input_reads_DB_folder_PB ne "")
				{
					$homopolymer_AF = 1;
					$gap_AF = 1.1;
				}
				while($pos_in_ass < length($read))
				{
					my $nuc_tmp = substr $read, $pos_in_ass-1, 1;
					
					if ($nuc_tmp eq "N" && exists($quality_scores{$id}{$pos_in_ass}))
					{
						my $dd = 1.65;
						my $before3 = substr $read, $pos_in_ass-4, 3;
						my $after3 = substr $read, $pos_in_ass, 3;
						my @q_score_tmp = split / /, $quality_scores{$id}{$pos_in_ass};
	print {$filehandle{$seed_id2}} $pos_in_ass." POS ".$quality_scores{$id}{$pos_in_ass}."\n";
						my $total_tmp = $q_score_tmp[1]+$q_score_tmp[2]+$q_score_tmp[3]+$q_score_tmp[4]+$q_score_tmp[5];
LOWER_DD:						
						if (($q_score_tmp[1] > $q_score_tmp[2]*$dd && $q_score_tmp[1] > $q_score_tmp[3]*$dd && $q_score_tmp[1] > $q_score_tmp[4]*$dd &&
						   ($q_score_tmp[1] > $q_score_tmp[5]*0.8 || ($q_score_tmp[1] > $q_score_tmp[5]*$homopolymer_AF && ($before3 eq "AAA" || $after3 eq "AAA"))))
						   || ($q_score_tmp[1] > $total_tmp*0.35 && (($before3 eq "CCC" && $q_score_tmp[2] > $total_tmp*0.35) || ($before3 eq "TTT" && $q_score_tmp[3] > $total_tmp*0.35) || ($before3 eq "GGG" && $q_score_tmp[4] > $total_tmp*0.35))))
						{
							$read_polished .= "A";
							#print {$filehandle{$seed_id2}} $pos_in_ass." A POLISHED\n";
						}
						elsif (($q_score_tmp[2] > $q_score_tmp[1]*$dd && $q_score_tmp[2] > $q_score_tmp[3]*$dd && $q_score_tmp[2] > $q_score_tmp[4]*$dd && 
						      ($q_score_tmp[2] > $q_score_tmp[5]*0.8 || ($q_score_tmp[2] > $q_score_tmp[5]*$homopolymer_AF && ($before3 eq "CCC" || $after3 eq "CCC"))))
							  || ($q_score_tmp[2] > $total_tmp*0.35 && (($before3 eq "AAA" && $q_score_tmp[1] > $total_tmp*0.35) || ($before3 eq "TTT" && $q_score_tmp[3] > $total_tmp*0.35) || ($before3 eq "GGG" && $q_score_tmp[4] > $total_tmp*0.35))))
						{
							$read_polished .= "C";
							#print {$filehandle{$seed_id2}} $pos_in_ass." C POLISHED\n";
						}
						elsif (($q_score_tmp[3] > $q_score_tmp[2]*$dd && $q_score_tmp[3] > $q_score_tmp[1]*$dd && $q_score_tmp[3] > $q_score_tmp[4]*$dd &&
						      ($q_score_tmp[3] > $q_score_tmp[5]*0.8 || ($q_score_tmp[3] > $q_score_tmp[5]*$homopolymer_AF && ($before3 eq "TTT" || $after3 eq "TTT"))))
							   || ($q_score_tmp[3] > $total_tmp*0.35 && (($before3 eq "CCC" && $q_score_tmp[2] > $total_tmp*0.35) || ($before3 eq "AAA" && $q_score_tmp[1] > $total_tmp*0.35) || ($before3 eq "GGG" && $q_score_tmp[4] > $total_tmp*0.35))))
						{
							$read_polished .= "T";
							#print {$filehandle{$seed_id2}} $pos_in_ass." T POLISHED\n";
						}
						elsif (($q_score_tmp[4] > $q_score_tmp[2]*$dd && $q_score_tmp[4] > $q_score_tmp[3]*$dd && $q_score_tmp[4] > $q_score_tmp[1]*$dd && 
						      ($q_score_tmp[4] > $q_score_tmp[5]*0.8 || ($q_score_tmp[4] > $q_score_tmp[5]*$homopolymer_AF && ($before3 eq "GGG" || $after3 eq "GGG"))))
							   || ($q_score_tmp[4] > $total_tmp*0.35 && (($before3 eq "CCC" && $q_score_tmp[2] > $total_tmp*0.35) || ($before3 eq "TTT" && $q_score_tmp[3] > $total_tmp*0.35) || ($before3 eq "AAA" && $q_score_tmp[1] > $total_tmp*0.35))))
						{
							$read_polished .= "G";
							#print {$filehandle{$seed_id2}} $pos_in_ass." G POLISHED\n";
						}
						elsif ($q_score_tmp[5] > $q_score_tmp[2]*$gap_AF && $q_score_tmp[5] > $q_score_tmp[3]*$gap_AF && $q_score_tmp[5] > $q_score_tmp[1]*$gap_AF && $q_score_tmp[5] > 0.55*$total_tmp)
						{
							#print {$filehandle{$seed_id2}} $pos_in_ass." GAP POLISHED\n";
						}
						elsif ($dd > 1.4)
						{
							$dd = '1.4';
							goto LOWER_DD;
						}
						else
						{
							$read_polished .= "N";
						}
					}		
					else
					{
						$read_polished .= $nuc_tmp;
					}
					if (exists($quality_scores_gap{$id}{$pos_in_ass}))
					{
						my $before3 = substr $read, $pos_in_ass-4, 3;
						my $after3 = substr $read, $pos_in_ass, 3;
						my @q_score_tmp = split / /, $quality_scores_gap{$id}{$pos_in_ass};
						if ($q_score_tmp[0] < 0.75)
						{
							print {$filehandle{$seed_id2}} $pos_in_ass." POS ".$quality_scores_gap{$id}{$pos_in_ass}." GAP_SCORE\n";
							if 	($q_score_tmp[1] > $q_score_tmp[2]*1.2 && $q_score_tmp[1] > $q_score_tmp[3]*1.2 && $q_score_tmp[1] > $q_score_tmp[4]*1.2 &&
								($q_score_tmp[1] > $q_score_tmp[5]*0.8 || ($q_score_tmp[1] > $q_score_tmp[5]*0.6 && ($before3 eq "AAA" || $after3 eq "AAA"))))
							{
								$read_polished .= "A";
								print {$filehandle{$seed_id2}} $pos_in_ass." A POLISHED GAP\n";
							}
							elsif ($q_score_tmp[2] > $q_score_tmp[1]*1.2 && $q_score_tmp[2] > $q_score_tmp[3]*1.2 && $q_score_tmp[2] > $q_score_tmp[4]*1.2 && 
								  ($q_score_tmp[2] > $q_score_tmp[5]*0.8 || ($q_score_tmp[2] > $q_score_tmp[5]*0.6 && ($before3 eq "CCC" || $after3 eq "CCC"))))
							{
								$read_polished .= "C";
								print {$filehandle{$seed_id2}} $pos_in_ass." C POLISHED GAP\n";
							}
							elsif ($q_score_tmp[3] > $q_score_tmp[2]*1.2 && $q_score_tmp[3] > $q_score_tmp[1]*1.2 && $q_score_tmp[3] > $q_score_tmp[4]*1.2 &&
								  ($q_score_tmp[3] > $q_score_tmp[5]*0.8 || ($q_score_tmp[3] > $q_score_tmp[5]*0.6 && ($before3 eq "TTT" || $after3 eq "TTT"))))
							{
								$read_polished .= "T";
								print {$filehandle{$seed_id2}} $pos_in_ass." T POLISHED GAP\n";
							}
							elsif ($q_score_tmp[4] > $q_score_tmp[2]*1.2 && $q_score_tmp[4] > $q_score_tmp[3]*1.2 && $q_score_tmp[4] > $q_score_tmp[1]*1.2 && 
								  ($q_score_tmp[4] > $q_score_tmp[5]*0.8 || ($q_score_tmp[4] > $q_score_tmp[5]*0.6 && ($before3 eq "GGG" || $after3 eq "GGG"))))
							{
								$read_polished .= "G";
								print {$filehandle{$seed_id2}} $pos_in_ass." G POLISHED GAP\n";
							}
						}
					}
					$pos_in_ass++;
				}
				$read = $read_polished;
				
                if ($first_back_assembly eq "" && $y < 3 && $assembly_length_max eq "WG" && $circle ne "yes")
				{		
				}
				elsif (length($read) > 1500)
				{
					my $output_file7  = $output_path."assembly_tmp_".$project."_".$seed_id2.".fasta";               
					open(OUTPUT7, ">".$output_file7) or die "Can't open file $output_file7, $!\n";
					print OUTPUT7 ">".$id."\n";
					
					if ($assembly_length_max eq "WG")
					{
						print OUTPUT20 ">".$id."\n";
					}
					
					if ($final_assembly_file_check eq "ye")
					{
						open(OUTPUT_FINAL, ">>".$final_assembly_file) or die "Can't open file $final_assembly_file, $!\n";
						$final_assembly_file_check = "yes";
					}
					elsif ($final_assembly_file_check ne "yes")
					{
						open(OUTPUT_FINAL, ">".$final_assembly_file) or die "Can't open file $final_assembly_file, $!\n";
						$final_assembly_file_check = "yes";
					}
					
					if ($first_back_assembly ne "" || ($assembly_length_max ne "WG" && $assembly_refine eq ""))
					{
						print OUTPUT_FINAL ">".$id."\n";
					}
					
					
					my $m = '0';
					while (length($read) > $m)
					{
						my $value_ref2b = substr $read, $m, 150;
						$m += 150;
						print OUTPUT7 $value_ref2b."\n";
						if ($assembly_length_max eq "WG")
						{
							print OUTPUT20 $value_ref2b."\n";
						}
						if ($first_back_assembly ne "" || ($assembly_length_max ne "WG" && $assembly_refine eq ""))
						{
							print OUTPUT_FINAL $value_ref2b."\n";
						}
					}
					close OUTPUT7;
				}
				
                $compare_haps_stop = "yes";
                $skip_hap = "";
                close $filehandle{$seed_id2};
            }
            elsif ($find_haps_in_seed eq "yes" && $found_haps_in_seed eq "")
            {
                $read = $best_extension;
                $position = length($best_extension);
                $position{$id} = $position;
                $best_extension = "";
                $seed{$id} = $read;
                $skip_hap = "";
                print {$filehandle{$seed_id2}} $position." POSSS\n";
            }
            elsif ($best_extension ne "" && $found_haps_in_seed eq "")
            {
                $read .= $best_extension;                                                 
                $position = length($read);
                $position{$id} = $position;
                $best_extension = "";
                $seed{$id} = $read;
                $skip_hap = "";
				$full_reset_NP = "";
				$full_reset_PB = "";		
            }
            
            if ($find_haps_in_seed ne "")
            {
                if ($found_haps_in_seed eq "yes")
                {
                    $find_haps_in_seed = "";
                    $found_haps_in_seed = "";
                    $y = '1';
					$y{$id} = $y;
                    close $filehandle{$seed_id2};
                }
                else
                {
                    $find_haps_in_seed = "yes2";
                    $find_haps_in_seed{$id} = "yes2";
                }
            }
AFTER_EXT2:    
        }
    $y0++;
	$y++;
	$y{$id} = $y;
	$contig_length{$id} = length($read);
}

$circular = "";

END1:
#close OUTPUT18;
if ($seed_id2 ne "")
{
	close $filehandle{$seed_id2};
	close $filehandle3{$seed_id2};
	close $filehandle4{$seed_id2};
}
#print $id." ID_CURRENT\n";
#print length($read)." ID_CURRENT_LENGTH\n";

if ($first_back_assembly eq "yes" && length($read) < 1500)
{
	unlink $output_file5;
	unlink $output_file13;
	foreach my $seed_id_tmp (keys %seed)
	{
		my $contig_tmp_file = $output_path."contigs_tmp_".$seed_id_tmp."_".$project.".fasta";
		unlink $contig_tmp_file;
	}
}

if ($y < 4 && $first_back_assembly eq "" && $assembly_length_max eq "WG")
{
	#unlink $output_file18;
	unlink $output_file5;
	unlink $output_file13;
	foreach my $seed_id_tmp (keys %seed)
	{
		my $contig_tmp_file = $output_path."contigs_tmp_".$seed_id_tmp."_".$project.".fasta";
		unlink $contig_tmp_file;
	}
	$first_back_assembly = "yes";
}

if (($assembly_length_max eq "WG" || keys %split_contigs_reads > 0 || $assembly_refine ne "") && $last_seed ne "yes")
{
	$y = '1';
	if ($ploidy > 1 && $assembly_length_max eq "WG")
	{
		$find_haps_in_seed = "yes";
	}
	else
	{
		$find_haps_in_seed = "";
	}
	$seed_input = "";
	$position = '0';
	$position_back = '0';
	$compare_haps = "";
	$compare_haps_stop = "";
	delete $no_hap_track{$id};
	$skip_hap = ""; #CHECKKKKKKKKKKKKKKKKKKK
	delete $last_non_complex_region{$id};	
	delete $filehandle{$seed_id2};
	delete $filehandle3{$seed_id2};
	delete $filehandle4{$seed_id2};
	delete $seed{$id};
	delete $position{$id};
	delete $position_back{$id};
	delete $split_positions{$id};
	delete $split_positions_VIP{$id};
	delete $split_positions_extra{$id};
	delete $split_positions_DUP{$id};
	delete $split_positions_DUP2{$id};
	delete $split_positions_back{$id};
	delete $quality_scores{$id};
	delete $quality_scores_gap{$id};
	delete $cut_repeat_seq{$id};
	delete $hap_compare_pos{$id};
	$hap_compare_mismatch_extend = '0';
	undef %PB_split_nucs;
	undef %PB_split_ids;
	$PB_extension = "";
	undef @seed_list_sorted;
	$full_reset_NP = "";	
	delete $save_alignment_data_NP{$id};
	delete $rejected_alignment_data_NP{$id};
	delete $save_alignment_data_PB{$id};
	delete $rejected_alignment_data_PB{$id};
	delete $trace_back_split_NP{$id};
	delete $trace_back_split_NP_exclude{$id};
	undef %seeds_list;
	undef %seeds_list_sorted;
	delete $prev_position_hap_compare{$id};
	delete $exclude_reads_PB{$id};
	delete $exclude_reads_NP{$id};
	delete $exclude_reads_PB_back{$id};
	delete $exclude_reads_NP_back{$id};
	delete $trace_back_split_PB{$id};
	delete $track_coverage{$id};
	$seed_id2 = "";
	my $id_tmp5 = $id;
	$id = "";
	
	if ($first_back_assembly eq "" && ($assembly_length_max eq "WG" || $assembly_refine ne ""))
	{
		if ($assembly_length_max eq "WG")
		{
			substr $read, 0, $original_seed_length{$id_tmp5}, "";
		}
		my $read_tmp = reverse($read);
		$read_tmp =~ tr/ACTG/TGAC/;
		$seed_input = $read_tmp;
		$seeds_list{$id_tmp5."b"} = $seed_input;
		$first_back_assembly{$id_tmp5."b"} = "yes";
		$seeds_list_sorted{$keep_track_of_reads_number} = $id_tmp5."b";
		$y{$id_tmp5."b"} = $y;
		$read = "";
		if ($assembly_refine ne "")
		{
			$assembly_refine_done{$id_tmp5} = undef;
		}
		goto FIRST_SEED;
	}
	if ($assembly_refine ne "")
	{
		my $id_tmp6 = $id_tmp5;
		chop($id_tmp6);
		$contigs_ass{$id_tmp6} = $read;
		$lengths_ass{$id_tmp6} = length($read);
	}
	
	foreach my $contig_number_tmp (sort {$a <=> $b} keys %split_contigs_reads)
	{
		print $contig_number_tmp." CONTIG_NUMBER\n";
		foreach my $id_tmp (keys %{$split_contigs_reads{$contig_number_tmp}})
		{
			print $id_tmp." ID\n";
			if (exists($first_back_assembly{$id_tmp}))
			{
				foreach my $new_contig_seed (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp}})
				{
					$split_contigs_ends{$id_tmp} = $new_contig_seed;
					foreach my $nuc_tmp (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}})
					{
						print $nuc_tmp." NEW_NUC_SPLITbbb\n";
						$seeds_list{$id_tmp."c".$contig_number_tmp} = $new_contig_seed;
						$keep_track_of_reads_number++;
						$seeds_list_sorted{$keep_track_of_reads_number."c".$contig_number_tmp} = $id_tmp."c".$contig_number_tmp;
						$y{$id_tmp."c".$contig_number_tmp} = $y;
						$compare_haps_stop_final{$id_tmp."c".$contig_number_tmp} = undef;
						foreach my $id_read (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}{$nuc_tmp}})
						{
							$split_contigs_reads2{$id_tmp."c".$contig_number_tmp}{$id_read} = $split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}{$nuc_tmp}{$id_read};
						}
						delete $split_contigs_reads{$contig_number_tmp};
					}
				}		
				$read = "";
				goto FIRST_SEED;
			}
			else
			{
				my $found_tmp = "";
				foreach my $new_contig_seed (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp}})
				{
					print length($new_contig_seed)." LENGTH_READ\n";
		
					if (keys %split_contigs_ends > 0)
					{
						my $output_file30  = $output_path."Sequence_new_contig_".$id_tmp.".fasta";			
						open(OUTPUT30, ">".$output_file30) or die "Can't open file $output_file30, $!\n";
						OUTPUT30->autoflush(1);
						print OUTPUT30 ">".$id_tmp."\n";
						print OUTPUT30 $new_contig_seed."\n";
						close OUTPUT30;
					
						my $output_file29  = $output_path."Prev_contig_ends_".$id_tmp.".fasta";
						open(OUTPUT29, ">".$output_file29) or die "Can't open file $output_file29, $!\n";
						OUTPUT29->autoflush(1);
						
						my $id_tmp_tmp = $id_tmp;
						my $contig_n_tmp = $contig_number_tmp-1;
						my $id_tmp1 = substr $id_tmp_tmp, -1, 1, $contig_n_tmp;
						my $count_contigs_tmp = '0';
						foreach my $id_contigs (keys %split_contigs_ends)
						{
							if ($id_contigs ne $id_tmp && $id_contigs ne $id_tmp1)
							{
								my $lenth_alignment = length($new_contig_seed);
								if (length($split_contigs_ends{$id_contigs}) < length($new_contig_seed))
								{
									$lenth_alignment = $split_contigs_ends{$id_contigs};
								}
								my $end_contig_seq = substr $split_contigs_ends{$id_contigs}, -$lenth_alignment;
								print OUTPUT29 ">".$id_contigs."\n";
								print OUTPUT29 $end_contig_seq."\n";
								$count_contigs_tmp++;
							}
						}
						close OUTPUT29;
						sleep(1);
			
						if (-s $output_file29 && $count_contigs_tmp > 0)
						{			
							my $file_tmp = $output_path."blast_seed_test_".$id_tmp.".txt";
							my $command = "blastn -query ".$output_file30." -subject ".$output_file29." -out ".$file_tmp." -outfmt 7 -qcov_hsp_perc 90";
							system($command);
							my $count_tmp = '0';
NEXT_SEED_ACCEPT:									
							if (-s $file_tmp)
							{
								open(SEED_TEST, $file_tmp) or die "\nCan't open file $file_tmp, $!\n";
								
								my $count_lines_tmp = '1';
								while (my $line_tmp = <SEED_TEST>)
								{
									chomp($line_tmp);
									if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
									{
										close SEED_TEST;
										goto NEXT_SEED_ACCEPT2;
									}
									elsif ($count_lines_tmp eq '5' && $line_tmp eq "# BLAST processed 1 queries")
									{
										close SEED_TEST;
										goto NEXT_SEED_ACCEPT;
									}
									elsif ($count_lines_tmp > 5)
									{
										my @line_tmp = split /\t/, $line_tmp;
										my $accuracy_tmp = $line_tmp[2];
			
										if ($accuracy_tmp > 99.8 || ($PB_reads eq "" && $input_reads_DB_folder_PB eq "" && $accuracy_tmp > 80))
										{
											close SEED_TEST;
							print $line_tmp." CONTIG_BREAK_MATCH\n";
											goto NEXT_SEED_ACCEPT3;
										}  
									}
									$count_lines_tmp++;
								}
								close SEED_TEST;
							}
							elsif ($count_tmp < 100000)
							{
								$count_tmp++;
								goto NEXT_SEED_ACCEPT;
							}
						}
NEXT_SEED_ACCEPT2:									
					}
					print length($new_contig_seed)." NEW_SEED\n";
					$found_tmp = "yes";
					$split_contigs_ends{$id_tmp} = $new_contig_seed;

					foreach my $nuc_tmp (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}})
					{
						print $id_tmp."c".$contig_number_tmp." NEW_ID\n";
						print $nuc_tmp." NEW_NUC_SPLIT\n";
						$seeds_list{$id_tmp."c".$contig_number_tmp} = $new_contig_seed;
						$keep_track_of_reads_number++;
						$seeds_list_sorted{$keep_track_of_reads_number."c".$contig_number_tmp} = $id_tmp."c".$contig_number_tmp;
						$contig_connections{$id_tmp}{$id_tmp."c".$contig_number_tmp} = undef;
						$y{$id_tmp."c".$contig_number_tmp} = $y;
						$compare_haps_stop_final{$id_tmp."c".$contig_number_tmp} = undef;
						if (exists($assembly_length_prev{$id_tmp}))
						{
							$assembly_length_prev{$id_tmp."c".$contig_number_tmp} = $contig_length{$id_tmp}-length($new_contig_seed)+$assembly_length_prev{$id_tmp};
						}
						else
						{
							$assembly_length_prev{$id_tmp."c".$contig_number_tmp} = $contig_length{$id_tmp}-length($new_contig_seed);
						}
						print $assembly_length_prev{$id_tmp."c".$contig_number_tmp}." ASS_LENGTH1\n";
						foreach my $id_read (keys %{$split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}{$nuc_tmp}})
						{
							$split_contigs_reads2{$id_tmp."c".$contig_number_tmp}{$id_read} = $split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}{$nuc_tmp}{$id_read};
						}
						delete $split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed}{$nuc_tmp};
					}					
					delete $split_contigs_reads{$contig_number_tmp}{$id_tmp}{$new_contig_seed};
					delete $split_contigs_reads{$contig_number_tmp}{$id_tmp};
					delete $split_contigs_reads{$contig_number_tmp};
NEXT_SEED_ACCEPT3:
				}
				if ($found_tmp eq "yes")
				{
					$read = "";
					goto FIRST_SEED;
				}
			}
		}
	}
	if ($assembly_refine ne "")
	{
		my $new_contig_refine = "";
		my $command_remove = "rm -R $DB_direc_refine_tmp";
		system($command_remove);
		my $refined_assembly_file = $output_path."Refined_assembly_".$project.".fasta";
		open(OUTPUT_REFINE, ">".$refined_assembly_file) or die "Can't open file $refined_assembly_file, $!\n";
		foreach my $id_contig_tmp (sort keys %contigs_ass)
		{
			my $last_nuc_tmp = substr $id_contig_tmp, -1, 1;
			if (exists($assembly_refine_done{$id_contig_tmp}))
			{
			}
			elsif (length($contigs_ass{$id_contig_tmp}) > 25000 && $new_contig_refine eq "" && $last_nuc_tmp ne "c")
			{
				$new_contig_refine = $id_contig_tmp;
			}
			print OUTPUT_REFINE ">".$id_contig_tmp."\n";
			my $m = '0';
			my $contig_seq_tmp = $contigs_ass{$id_contig_tmp};
			while (length($contig_seq_tmp) > $m)
			{
				my $value_ref2b = substr $contig_seq_tmp, $m, 150;
				$m += 150;
				print OUTPUT_REFINE $value_ref2b."\n";
			}
		}
		close OUTPUT_REFINE;
		mkdir $DB_direc_refine_tmp;		
		
		my $DB_output_tmp = $output_path."DB_ASSEMBLY_tmp_file.txt";    
		my $command_make_DB = "makeblastdb -in ".$refined_assembly_file." -dbtype nucl -out ".$DB_direc_refine_tmp." > ".$DB_output_tmp."";
		system($command_make_DB);
		
		if ($new_contig_refine ne "")
		{
			my $contig_seq1 = $contigs_ass{$new_contig_refine};
			substr $contig_seq1, 0, 10000, "";
			substr $contig_seq1, -10000, 10000, "";
			$seeds_list{$new_contig_refine} = $contig_seq1;
			$seeds_list_sorted{'1'} = $new_contig_refine;
			$y{$new_contig_refine} = '1';
			$seed_input = $contig_seq1;
			print OUTPUT4 "Assembly contig ID    : ".$new_contig_refine."\n";
			print OUTPUT4 "Assembly contig length: ".$lengths_ass{$new_contig_refine}."\n";
			$read = "";
			$last_merge_check_pos = "";
			goto FIRST_SEED;
		}
	}

	$read = "";
	if ($assembly_length_max eq "WG")
	{
		goto NEXT_SEED;
	}
}
END_LAST:

close OUTPUT10;
close OUTPUT11;
close OUTPUT12;
close OUTPUT19;
close OUTPUT20;
close OUTPUT_FINAL;


#Merge contigs---------------------------------------------------------------------------------------------------------


select(STDERR);
$| = 1;
select(STDOUT); # default
$| = 1;
print "\nMerging contigs...";

my $length_seq = '1000';

my $DB_direc_tmp = $output_path."DB_MERGE/DB_MERGE";
mkdir $DB_direc_tmp;
my $DB_output_tmp = $TMP_directory."DB_tmp_file.txt";    
my $command_make_DB = "makeblastdb -in ".$final_assembly_file." -dbtype nucl -out ".$DB_direc_tmp." > ".$DB_output_tmp."";
system($command_make_DB);

my %lengths;
undef %lengths;
my %contigs;
undef %contigs;
my %aligned;
undef %aligned;
my %merged;
undef %merged;

my $FILE_ASS1;
open($FILE_ASS1, $final_assembly_file) or die "\n\nCan't open assembly file $final_assembly_file, $!\n";
my $contig_id1 = "";
my $contig_seq1 = "";

while (my $line1 = <$FILE_ASS1>)
{   
    chomp $line1;
    $line1 =~ tr/\r//d;
    $line1 =~ s/\R/\012/;
    my $first_char = substr $line1, 0, 1;
    if ($first_char eq ">" && $contig_id1 eq "")
    {
        $contig_id1 = substr $line1, 1;
        next;
    }
    elsif ($first_char eq ">")
    {
        $lengths{$contig_id1} = length($contig_seq1);
        $contigs{$contig_id1} = $contig_seq1;
        $contig_id1 = substr $line1, 1;
        $contig_seq1 = "";
    }
    else
    {
        $contig_seq1 .= $line1;
    }
}
$lengths{$contig_id1} = length($contig_seq1);
$contigs{$contig_id1} = $contig_seq1;
close $FILE_ASS1;
my $first_start = "";
my $skip_length = "1500";
my $DB_direc_tmp_new = $DB_direc_tmp;

START_MERGE:
my %files;
undef %files;
my %files_done;
undef %files_done;

foreach my $contig_id (sort keys %contigs)
{   
    my $contig_seq = $contigs{$contig_id};
    my $query_coverage0 = "98";
    my $query_accuracy0 = "98";
    
    my $first_start_seq = "";
    if ($first_start eq "yes")
    {
         $first_start_seq = substr $contig_seq, -$length_seq-$skip_length, $length_seq;
    }
    else
    {
         $first_start_seq = substr $contig_seq, $skip_length, $length_seq;
    }

    my $N_count = $first_start_seq =~ tr/N/N/;
    $query_coverage0 -= (($N_count/$length_seq)/100);
    $query_accuracy0 -= (($N_count/$length_seq)/100);

    my $query_file_DB = $TMP_directory."query_".$contig_id.".fasta";
    open(INPUT_QUERY, ">" .$query_file_DB) or die "\nCan't open file $query_file_DB, $!\n";
    INPUT_QUERY->autoflush(1);
    print INPUT_QUERY $first_start_seq;        
    close INPUT_QUERY;
    
    my $file_tmp = $TMP_directory."blast_tmp_DB_".$contig_id."_first_".$first_start.".txt";
    my $command_DB = "blastn -query ".$query_file_DB." -db ".$DB_direc_tmp_new." -out ".$file_tmp." -outfmt 7 -perc_identity ".$query_accuracy0." -qcov_hsp_perc ".$query_coverage0." -num_threads 2 &";
    syscmd($command_DB);
    $files{$contig_id} = $file_tmp;
}

sleep(1);
my $files_total = keys %files;
my %files2;
undef %files2;
my %files_done2;
undef %files_done2;
my $align_count = '0';
my $group_count = '1';

NEXT_CONTIG0:

NEXT_CONTIG: foreach my $contig_id (sort keys %files)
{     
    if (exists($files_done{$contig_id}))
    {
        next NEXT_CONTIG;
    }
    my $file_complete = "";
    my $file_tmp = $files{$contig_id};
    if (-e $file_tmp)
    {
        my $contig_seq = $contigs{$contig_id};
    
DB_RESULTS: 
        open(BLAST_RESULTS_DB, $file_tmp) or die "\nCan't open file $file_tmp, $!\n";
        my $count_lines_tmp = '1';
       
BLAST_RESULTS1:   while (my $line_tmp = <BLAST_RESULTS_DB>)
        {
            chomp($line_tmp);
            if ($count_lines_tmp eq '4' && $line_tmp eq "# 0 hits found")
            {
                $files_done{$contig_id} = undef;
                close BLAST_RESULTS_DB;
                last;
            }
            elsif ($count_lines_tmp eq '5' && $line_tmp eq "# BLAST processed 1 queries")
            {
                print OUTPUT4 "ERROR_BLAST_MERGE1\n";
            }
            elsif ($count_lines_tmp > 5 && $line_tmp eq "# BLAST processed 1 queries" && $file_complete eq "")
            {
                $file_complete = "yes";
                $files_done{$contig_id} = undef;
                close BLAST_RESULTS_DB;
                goto DB_RESULTS;
            }
            elsif ($count_lines_tmp > 5 && $file_complete eq "yes")
            {
                my @line_tmp = split /\t/, $line_tmp;
                my $id_tmp = $line_tmp[1];
                my $accuracy_tmp = $line_tmp[2];
                my $alignment_length = $line_tmp[3];
                my $read_pos_start_tmp = $line_tmp[8];
                my $read_pos_end_tmp = $line_tmp[9];
                
                if (exists($contigs{$id_tmp}))
                {}
                elsif (exists($merged{$id_tmp}))
                {
                    while (exists($merged{$id_tmp}))
                    {
                        my @line_tmp5 = split /_m_/, $merged{$id_tmp};
                        foreach my $id_tmp8 (@line_tmp5)
                        {
                            if ($id_tmp8 eq $contig_id)
                            {
                                next BLAST_RESULTS1;
                            }
                        }
                        my $id_tmp_tmp = $id_tmp;
                        $id_tmp = $merged{$id_tmp_tmp};
                    }
                }
                else
                {
                    next BLAST_RESULTS1;
                }
    
                if ($id_tmp ne $contig_id)
                {
                    my $reverse_tmp = "no";
                    my $length_tmp = $lengths{$id_tmp}-$read_pos_end_tmp+$skip_length+$length_seq;
                     
                    if ($first_start eq "yes" && $read_pos_end_tmp > $read_pos_start_tmp)
                    {
                        $length_tmp = $read_pos_end_tmp + $skip_length;
                    }
                    elsif ($first_start eq "" && $read_pos_end_tmp < $read_pos_start_tmp) 
                    {
                        $reverse_tmp = "yes";
                        $length_tmp = $read_pos_end_tmp+$skip_length + $length_seq;
                    }
                    elsif ($first_start eq "yes" && $read_pos_end_tmp < $read_pos_start_tmp)
                    {
                        $reverse_tmp = "yes";
                        $length_tmp = $lengths{$id_tmp}-$read_pos_end_tmp;
                    }
    
                    #my $length_tmp = $lengths{$id_tmp}-$read_pos_end_tmp2+$length_seq+$skip_length;
                   #if ($first_start eq "yes")
                    #{
                        #$length_tmp = $read_pos_end_tmp2+$length_seq+$skip_length;
                    #}
    
                    if (exists($aligned{$id_tmp.$contig_id}{$reverse_tmp}{$first_start}))
                    {
                        #print $id_tmp." ".$contig_id." SKIP\n";
                    }
                    elsif ($lengths{$id_tmp} > 5000)
                    {
                        my $query_coverage2 = (($length_tmp/$lengths{$id_tmp})*0.98)*100;      
                        my $query_seq_tmp = "";
                        my $query_seq_full = $contigs{$id_tmp};
                        my $query_seq_full2 = $contigs{$id_tmp};
                        if ($reverse_tmp eq "no")
                        {
                            $query_seq_tmp = substr $contigs{$id_tmp}, $read_pos_start_tmp-$skip_length;
                            if ($first_start eq "yes")
                            {
                                $query_seq_tmp = substr $contigs{$id_tmp}, 0, $read_pos_end_tmp+$skip_length;
                            }
                        }
                        elsif ($reverse_tmp eq "yes")
                        {
                            my $query_seq_tmp2 = substr $contigs{$id_tmp}, $read_pos_end_tmp;
                            $query_seq_full = reverse($query_seq_full2);
                            $query_seq_full =~ tr/ACTGactg/TGACTGAC/;
                            $query_seq_tmp = reverse($query_seq_tmp2);
                            $query_seq_tmp =~ tr/ACTGactg/TGACTGAC/;
                        }
                        
                        my $subject_seq_tmp = substr $contigs{$contig_id}, 0, $length_tmp*1.08;
                        if ($first_start eq "yes")
                        {
                            $subject_seq_tmp = substr $contigs{$contig_id}, -$length_tmp*1.08;
                        }
                        $align_count++;
                        my $query_file3 = $TMP_directory."query3".$contig_id."_".$align_count.".fasta";
                        my $subject_file3 = $TMP_directory."subject2".$contig_id."_".$align_count.".fasta";
                        my $N_count = $subject_seq_tmp =~ tr/N/N/;
                        my $N_adjust = ($N_count/length($subject_seq_tmp))*100;
                        my $N_count2 = $query_seq_tmp =~ tr/N/N/;
                        my $N_adjust2 = ($N_count2/length($query_seq_tmp))*100;
                        my $accuracy_tmp2 = 99.9-$N_adjust-$N_adjust2;       
    
                        open(INPUT_QUERY3, ">" .$query_file3) or die "\nCan't open file $query_file3, $!\n";
                        INPUT_QUERY3->autoflush(1);
                        print INPUT_QUERY3 $query_seq_tmp;        
                        close INPUT_QUERY3;
                        open(INPUT_SUBJECT3, ">" .$subject_file3) or die "\nCan't open file $subject_file3, $!\n";
                        INPUT_SUBJECT3->autoflush(1);
                        print INPUT_SUBJECT3 $subject_seq_tmp;        
                        close INPUT_SUBJECT3;
                        
                        my $file_tmp2 = $TMP_directory."blast_tmp3_".$contig_id."_".$id_tmp."_".$length_tmp."_first2_".$first_start.".txt";
                        my $command_DB = "blastn -query ".$query_file3." -subject ".$subject_file3." -out ".$file_tmp2." -outfmt 7 -perc_identity ".$accuracy_tmp2." -qcov_hsp_perc ".$query_coverage2. "&";
                        syscmd($command_DB);
                        $aligned{$id_tmp.$contig_id}{$reverse_tmp}{$first_start} = undef;
                        $aligned{$contig_id.$id_tmp}{$reverse_tmp}{$first_start} = undef;
                        my $N_adjust3 = $N_adjust+$N_adjust2;
                        $N_adjust3 .= "+".$read_pos_end_tmp."+".length($subject_seq_tmp)."+".$reverse_tmp."+".$length_tmp."+".length($query_seq_tmp)."+".$read_pos_start_tmp;
                        $files2{$group_count}{$contig_id}{$id_tmp}{$N_adjust3} = $file_tmp2;
                    }
                }
            }
            $count_lines_tmp++;
        }
        close BLAST_RESULTS_DB;
        $group_count++;
    }
}

if (keys %files_done < keys %files)
{
    goto NEXT_CONTIG0;
}
my %merge_matches;
undef %merge_matches;
NEXT_CONTIG20:
foreach my $group_id (sort keys %files2)
{
NEXT_CONTIG2: foreach my $contig_id (sort keys %{$files2{$group_id}})
    {     
        foreach my $id_tmp (keys %{$files2{$group_id}{$contig_id}})
        {
            foreach my $extra (keys %{$files2{$group_id}{$contig_id}{$id_tmp}})
            { 
                my $file_tmp2 = $files2{$group_id}{$contig_id}{$id_tmp}{$extra};
                if (-e $file_tmp2)
                {
                    if (exists($files_done2{$group_id}{$contig_id}{$id_tmp}))
                    {
                        goto MERGE_NEW;
                    }
                    my $file_complete2 = "";        
                    my @extra = split /\+/, $extra;
                    my $N_adjust3 = $extra[0];
                    my $read_pos_end_tmp = $extra[1];
                    my $length_subject_seq_tmp = $extra[2];
                    my $reverse_tmp = $extra[3];
                    my $length_tmp = $extra[4];
                    my $length_query_seq_tmp = $extra[5];
                    my $read_pos_start_tmp = $extra[6];          
                    
DB_RESULTS2:          
                    open(BLAST_RESULTS_DB2, $file_tmp2) or die "\nCan't open file $file_tmp2, $!\n";
                    my $count_lines_tmp2 = '1';
                               
BLAST_RESULTS2:     while (my $line_tmp2 = <BLAST_RESULTS_DB2>)
                    {
                        chomp($line_tmp2);
                        
                        if ($count_lines_tmp2 eq '4' && $line_tmp2 eq "# 0 hits found")
                        {
                            close BLAST_RESULTS_DB2;
                            $files_done2{$group_id}{$contig_id}{$id_tmp} = undef;
                            last BLAST_RESULTS2;
                        }
                        elsif ($count_lines_tmp2 eq '5' && $line_tmp2 eq "# BLAST processed 1 queries")
                        {
                            print OUTPUT4 "ERROR_BLAST_MERGE2\n";
                        }
                        elsif ($count_lines_tmp2 > 5 && $line_tmp2 eq "# BLAST processed 1 queries" && $file_complete2 eq "")
                        {
                            $file_complete2 = "yes";
                            $files_done2{$group_id}{$contig_id}{$id_tmp} = undef;
                            print OUTPUT4 "\n\n".$contig_id." ID\n";         
                            close BLAST_RESULTS_DB2;
                            goto DB_RESULTS2;
                        }
                        elsif ($count_lines_tmp2 > 5 && $file_complete2 eq "yes")
                        {
                            my @line_tmp2 = split /\t/, $line_tmp2;
                            my $accuracy_tmp2 = $line_tmp2[2];
                            my $alignment_length2 = $line_tmp2[3];
                            my $mismatches = $line_tmp2[4];
                            my $query_start_tmp2 = $line_tmp2[6];
                            my $query_end_tmp2 = $line_tmp2[7];
                            my $subject_start_tmp2 = $line_tmp2[8];
                            my $subject_end_tmp2 = $line_tmp2[9];
                            
                            if ($alignment_length2 > 0)
                            {
                                my $mismatch_rate = ($mismatches/$alignment_length2)*100;
                                if ($mismatch_rate-$N_adjust3 < 0.006)
                                {
                                    if ($query_start_tmp2 < 20 && $read_pos_end_tmp-($skip_length+$length_seq) < 100 && $query_end_tmp2 > length($query_end_tmp2)-100 && $first_start eq "")
                                    {
                                        print OUTPUT4 $id_tmp." ".$lengths{$id_tmp}." DELETE\n";
                                        delete $lengths{$id_tmp};
                                        delete $contigs{$id_tmp};
                                        undef %aligned;
                                        next NEXT_CONTIG2;
                                    }
                                    if ($subject_start_tmp2 < 20 && $subject_end_tmp2 > $length_subject_seq_tmp-100 && $first_start eq "")
                                    {
                                        print OUTPUT4 $contig_id." ".$lengths{$contig_id}." DELETE\n";
                                        delete $lengths{$contig_id};
                                        delete $contigs{$contig_id};
                                        undef %aligned;
                                        next NEXT_CONTIG2;
                                    }
                                    elsif ($subject_start_tmp2 < 20 && $subject_end_tmp2 > $lengths{$contig_id}-100)
                                    {
                                        print OUTPUT4 $contig_id." ".$lengths{$contig_id}." DELETE\n";
                                        delete $lengths{$contig_id};
                                        delete $contigs{$contig_id};
                                        undef %aligned;
                                        next NEXT_CONTIG2;
                                    }
                                    elsif ($subject_start_tmp2 < 100 && $query_end_tmp2 > $lengths{$id_tmp}-100 && $reverse_tmp eq "no")
                                    {
                                        my $id_new = $id_tmp."_m_".$contig_id;
                
                                        $merge_matches{$group_id}{$id_tmp}{$accuracy_tmp2}{$alignment_length2} = $subject_end_tmp2."+".$length_tmp."+".$query_end_tmp2."+".$reverse_tmp."+".$read_pos_end_tmp."+".$id_new;
                                        #print $group_id." ".$merge_matches{$group_id}{$id_tmp}{$accuracy_tmp2}{$alignment_length2}." MERGE1\n";
                                    }
                                    elsif ($query_start_tmp2 < 100 && $subject_end_tmp2 > $length_query_seq_tmp-100 && $first_start eq "" && $reverse_tmp eq "no")
                                    {
                                        my $id_new = $id_tmp."_m_".$contig_id;

                                        my $read_pos_end_tmp5 = $read_pos_start_tmp-$skip_length;
                                        $merge_matches{$group_id}{$id_tmp}{$accuracy_tmp2}{$alignment_length2} = $subject_end_tmp2."+".$length_tmp."+".$query_end_tmp2."+".$reverse_tmp."+".$read_pos_end_tmp5."+".$id_new."+".$first_start;
                                        #print $group_id." ".$merge_matches{$group_id}{$id_tmp}{$accuracy_tmp2}{$alignment_length2}." MERGE2\n";
                                    }
                                    elsif ($query_start_tmp2 < 100 && $subject_end_tmp2 > $length_subject_seq_tmp-100 && $first_start eq "yes" && $reverse_tmp eq "no")
                                    {
                                        my $id_new = $contig_id."_m_".$id_tmp;

                                        my $read_pos_end_tmp5 = $read_pos_start_tmp-$skip_length;
                                        $merge_matches{$group_id}{$id_tmp}{$accuracy_tmp2}{$alignment_length2} = $subject_end_tmp2."+".$length_tmp."+".$query_end_tmp2."+".$reverse_tmp."+".$read_pos_end_tmp5."+".$id_new."+".$first_start;
                                        #print $group_id." ".$merge_matches{$group_id}{$id_tmp}{$accuracy_tmp2}{$alignment_length2}." MERGE3\n";
                                    }
                                    elsif ($subject_start_tmp2 eq "1")
                                    {
                                       #print $line_tmp2."\n";
                                       #print $contig_id." ".$lengths{$contig_id}." LENGTH\n";
                                       #print $id_tmp." ".$lengths{$id_tmp}." LENGTH2\n";
                                    }
                                }
                            }
                        }
                        $count_lines_tmp2++;
                    }
                    close BLAST_RESULTS_DB2;
                    
MERGE_NEW:
                    my %merge_matches_new;
                    undef %merge_matches_new;
                    
                    my $group_count_total_tmp = '0';
                    my $group_count_done_tmp = '0';
                    foreach my $contig_id_tmp (sort keys %{$files2{$group_id}})
                    {
                        foreach my $id_tmp (sort keys %{$files2{$group_id}{$contig_id_tmp}})
                        {
                            $group_count_total_tmp++;
                        }
                    }
                    foreach my $contig_id_tmp (sort keys %{$files_done2{$group_id}})
                    {
                        foreach my $id_tmp (sort keys %{$files_done2{$group_id}{$contig_id_tmp}})
                        {
                            $group_count_done_tmp++;
                        }
                    }
                    if ($group_count_total_tmp eq $group_count_done_tmp && $group_count_total_tmp > 0)
                    {
                        my $highest = "";
                        my $highest_length = "";
                        my $highest_length_id = "";

                        foreach my $id_blast_tmp2 (keys %{$merge_matches{$group_id}})
                        {
                            foreach my $acc_tmp (sort {$b <=> $a} keys %{$merge_matches{$group_id}{$id_blast_tmp2}})
                            {
                                foreach my $alignment_length2_tmp (sort {$b <=> $a} keys %{$merge_matches{$group_id}{$id_blast_tmp2}{$acc_tmp}})
                                {
                                   if ($highest eq "")
                                   {
                                        $highest = $acc_tmp;
                                        #print $id_blast_tmp2." ".$highest." ".$merge_matches{$group_id}{$id_blast_tmp2}{$acc_tmp}{$alignment_length2_tmp}." HIGHEST_ACC\n";
                                        $merge_matches_new{$id_blast_tmp2} = $merge_matches{$group_id}{$id_blast_tmp2}{$acc_tmp}{$alignment_length2_tmp};
                                        next;
                                   }
                                   if ($highest > $acc_tmp+0.05)
                                   {}
                                   else
                                   {
                                        $merge_matches_new{$id_blast_tmp2} = $merge_matches{$group_id}{$id_blast_tmp2}{$acc_tmp}{$alignment_length2_tmp};
                                        #print $id_blast_tmp2." ".$acc_tmp." ACC\n";
                                   }
                                   if ($highest_length eq "" || $alignment_length2_tmp > $highest_length)
                                   {
                                        $highest_length = $alignment_length2_tmp;
                                        $highest_length_id = $id_blast_tmp2;
                                   }
                                }
                            }
                        }
                        my $count_matches2 = keys %merge_matches_new;
                        if ($count_matches2 > 1)
                        {
                            #print $highest_length." HIGHEST_LENGTH\n";
                            foreach my $id_blast_tmp2 (keys %{$merge_matches{$group_id}})
                            {
                                #print $id_blast_tmp2." ID_CHECK\n";
                                foreach my $acc_tmp (sort {$b <=> $a} keys %{$merge_matches{$group_id}{$id_blast_tmp2}})
                                {
                                    foreach my $alignment_length2_tmp (sort {$b <=> $a} keys %{$merge_matches{$group_id}{$id_blast_tmp2}{$acc_tmp}})
                                    {
                                        if ($id_blast_tmp2 ne $highest_length_id && ($alignment_length2_tmp < $highest_length/5) && $highest_length > 250000)
                                        {
                                            delete $merge_matches_new{$id_blast_tmp2};
                                             #print $id_blast_tmp2." DELETE_MERGE\n";
                                        }
                                    }
                                }
                            }
                        }
                        $count_matches2 = keys %merge_matches_new;
                        if ($count_matches2 eq '1')
                        {
                            undef %{$merge_matches{$group_id}};
                            foreach my $id_blast_tmp2 (keys %merge_matches_new)
                            {
                                #print $id_blast_tmp2." ID_CHECK2\n";
                                my @data_tmp = split /\+/, $merge_matches_new{$id_blast_tmp2};
                                my $subject_end_tmp2 = $data_tmp[0];
                                my $length_tmp = $data_tmp[1];
                                my $query_end_tmp2 = $data_tmp[2];
                                my $reverse_tmp = $data_tmp[3];
                                my $read_pos_end_tmp = $data_tmp[4];
                                my $id_new = $data_tmp[5];
                                my $first_start_tmp = $data_tmp[6];
                
                                my $subject_seq = "";
                                if ($first_start_tmp eq "")
                                {
                                    $subject_seq = $contigs{$contig_id};
                                }
                                else
                                {
                                    $subject_seq = substr $contigs{$contig_id}, 0, $read_pos_end_tmp;
                                }
                                my $query_seq = "";
                                my $query_seq_tmp = "";
                                my $query_seq_full = $contigs{$id_blast_tmp2};
                                my $query_seq_full2 = $contigs{$id_blast_tmp2};
                                if ($reverse_tmp eq "no")
                                {
                                    $query_seq_tmp = substr $contigs{$id_blast_tmp2}, 0, $read_pos_end_tmp;
                                }
                                elsif ($reverse_tmp eq "yes")
                                {
                                    my $query_seq_tmp2 = substr $contigs{$id_blast_tmp2}, $read_pos_end_tmp;
                                    $query_seq_full = reverse($query_seq_full2);
                                    $query_seq_full =~ tr/ACTGactg/TGACTGAC/;
                                    $query_seq_tmp = reverse($query_seq_tmp2);
                                    $query_seq_tmp =~ tr/ACTGactg/TGACTGAC/;
                                }
                                
                                if ($first_start_tmp eq "")
                                {
                                    $query_seq = substr $contigs{$id_blast_tmp2}, 0, $read_pos_end_tmp;
                                }
                                else
                                {
                                    $query_seq = $contigs{$id_blast_tmp2};
                                }
                                
                                if ($reverse_tmp eq "yes")
                                {
                                    #$query_seq = substr $query_seq_full, $query_end_tmp2;
                                }
                                else
                                {
                                    #$query_seq = substr $query_seq_full, $query_end_tmp2;
                                }
                                my $merged_contig = "";
                                #substr $merged_contig, -5000, 5000, "";
                                if ($first_start_tmp eq "")
                                {
                                    $merged_contig = $query_seq.$subject_seq;
                                }
                                else
                                {
                                    $merged_contig = $subject_seq.$query_seq;
                                }
                
                                $contigs{$id_new} = $merged_contig;
                                $lengths{$id_new} = length($merged_contig);
                                $merged{$id_blast_tmp2} = $id_new;
                                $merged{$contig_id} = $id_new;
                                delete $lengths{$id_blast_tmp2};
                                delete $contigs{$id_blast_tmp2};
                                delete $lengths{$contig_id};
                                delete $contigs{$contig_id};
                                print OUTPUT4 "Merge contigs : ".$contig_id." + ".$id_blast_tmp2."\n";
                                print OUTPUT4 "Overlap length: ".$query_end_tmp2."\n";
                                close BLAST_RESULTS_DB;
                                next NEXT_CONTIG2;
                            }
                        }
                        elsif ($count_matches2 > 1)
                        {
                             print OUTPUT4 $id_tmp." MULTI_MATCH_REJECT\n";
                        }
                    }
                }
            }
        }
    }
}
my $group_count_total_tmp = '0';
my $group_count_done_tmp = '0';
foreach my $group_id_tmp (sort keys %files2)
{
    foreach my $contig_id_tmp (sort keys %{$files2{$group_id_tmp}})
    {
        foreach my $id_tmp (sort keys %{$files2{$group_id_tmp}{$contig_id_tmp}})
        {
            $group_count_total_tmp++;
        }
    }
}
foreach my $group_id_tmp(sort keys %files_done2)
{
    foreach my $contig_id_tmp (sort keys %{$files_done2{$group_id_tmp}})
    {
        foreach my $id_tmp (sort keys %{$files_done2{$group_id_tmp}{$contig_id_tmp}})
        {
            $group_count_done_tmp++;
        }
    }
}
if ($group_count_done_tmp < $group_count_total_tmp)
{
    goto NEXT_CONTIG20;
}

if ($first_start eq "")
{
    $first_start = "yes";
    undef %aligned;
    
    my $output_file5b  = $output_path."Merged_contigs_tmp.fasta";
    open(OUTPUT_MERGED_TMP, ">" .$output_file5b) or die "\nCan't open file $output_file5b, $!\n";
    foreach my $id_tmp (keys %contigs)
    {
        print OUTPUT_MERGED_TMP ">".$id_tmp."\n";
        my $seq = $contigs{$id_tmp};
        while (length($seq) > 0)
        {
            my $line_cut = substr $seq, 0, 150, "";
            print OUTPUT_MERGED_TMP $line_cut."\n";
        }
    }
    close OUTPUT_MERGED_TMP;
    my $DB_direc_tmp2 = $output_path."DB_MERGE2/DB_MERGE2";
    mkdir $DB_direc_tmp2;
    $DB_direc_tmp_new = $DB_direc_tmp2;
    my $DB_output_tmp2 = $TMP_directory."DB_tmp_file2.txt";    
    my $command_make_DB2 = "makeblastdb -in ".$output_file5b." -dbtype nucl -out ".$DB_direc_tmp2." > ".$DB_output_tmp2."";
    system($command_make_DB2);
                      
    goto START_MERGE;
}

my $output_file55  = $output_path."assembly_final_".$project.".fasta";
open(OUTPUT_MERGED, ">" .$output_file55) or die "\nCan't open file $output_file55, $!\n";
foreach my $id_tmp (keys %contigs)
{
    print OUTPUT_MERGED ">".$id_tmp."\n";
    my $seq = $contigs{$id_tmp};
    while (length($seq) > 0)
    {
        my $line_cut = substr $seq, 0, 150, "";
        print OUTPUT_MERGED $line_cut."\n";
    }
}
close OUTPUT_MERGED;

print "...OK\n";

close OUTPUT4;

if ($TMP_directory ne "" && $TMP_directory ne $output_path)
{
	opendir(DIR_TMP, $TMP_directory) or die "Could not open $TMP_directory\n";
				
	for my $filename (readdir(DIR_TMP))
	{
		if ($filename ne "." && $filename ne "..")
		{
			unlink $filename;
		}
	}
	closedir DIR_TMP;
}

sleep(6);
if ($NP_reads ne "" || $PB_reads ne "" || $input_reads_DB_folder_NP ne "" || $input_reads_DB_folder_PB ne "")
{
	$chnl->end;
    MCE::Child->waitall;
}

print "\nThank you for using NOVOLoci!\n\n";
